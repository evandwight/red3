{"version":3,"file":"static/js/727.6a8eb6e1.chunk.js","mappings":"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","sources":["components/MediaElement/components/VideoHandler.tsx"],"sourcesContent":["import muxjs from 'mux.js';\nimport { useEffect, useRef, useState } from \"react\";\n\n\n\nexport default function VideoHandler({ videoInfo, audio, onLoadingComplete }) {\n    if (!videoInfo?.hasAudio && !!audio) {\n        return <SeparateAudioVideoHandler videoUrl={videoInfo.url} audioUrl={audio} onLoadingComplete={onLoadingComplete} />\n    } else {\n        return <video className=\"max-h-screen\"\n            controls={true} autoPlay={false} muted loop preload=\"auto\" playsInline draggable={false}\n            onLoadStart={onLoadingComplete}>\n            <source data-src={videoInfo.url} src={videoInfo.url} type=\"video/mp4\" />\n        </video>\n    }\n}\n\nasync function* loadVideoSegments(url) {\n    try {\n        const reader = await fetch(url).then((response) => {\n            if (response?.body === null) {\n                throw new Error(\"response null, no video\");\n            }\n            return response.body.getReader();\n        });\n        while (true) {\n            const result = await reader.read();\n            if (result.done) {\n                break;\n            }\n            yield result.value;\n        }\n    } catch (error) {\n        console.error(error);\n    }\n    return;\n}\nfunction getMimeType(firstSegment) {\n    const probe = muxjs.mp4.probe.tracks(firstSegment)\n    const codec = probe[0].codec;\n    return `video/mp4; codecs=\"${codec}\"`;\n}\n\nasync function loadVideoUrl(url) {\n    try {\n        const vidBlob = await (await fetch(url)).blob();\n        const vidBuff = await vidBlob.arrayBuffer();\n        const vidInt8 = new Int8Array(vidBuff);\n        const mimeCodec = getMimeType(vidInt8);\n        if (!MediaSource.isTypeSupported(mimeCodec)) {\n            throw new Error(`Unsupported MIME type or codec: ${mimeCodec}`);\n        }\n        return {\n            arrayBuffer: vidBuff,\n            mimeCodec,\n        }\n    } catch (error) {\n        return { error };\n    }\n}\n\nexport function SeparateAudioVideoHandler({ videoUrl, audioUrl, onLoadingComplete }) {\n    const video = useRef<HTMLVideoElement>(null);\n    const [play, setPlay] = useState(false);\n    useEffect(() => {\n        if (play) {\n            video.current?.play();\n        }\n    },[play])\n    useEffect(() => {\n        async function loadVideo() {\n            if (!('MediaSource' in window)) {\n                console.error(\"MediaSource unsupported\");\n                return;\n            }\n            if (video.current === null) {\n                console.error('videoRef not set');\n                return;\n            }\n\n            let mediaSource = new MediaSource();\n\n            const generator = loadVideoSegments(videoUrl);\n            const firstSegmentResult = await generator.next();\n            let first = true;\n            mediaSource.addEventListener('sourceopen', async () => {\n                if (firstSegmentResult.done) {\n                    throw new Error(\"no first segment\");\n                }\n                const mimeCodec = getMimeType(firstSegmentResult.value);\n                const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n                const addBuffer = async () => {\n                    const result = await generator.next();\n                    if (result.done) {\n                        mediaSource.endOfStream();\n                    } else {\n                        sourceBuffer.appendBuffer(result.value.buffer);\n                    }\n                    if (first) {\n                        first = false;\n                        onLoadingComplete();\n                        setPlay(true);\n                    }\n                }\n                sourceBuffer.addEventListener('updateend', addBuffer);\n                sourceBuffer.appendBuffer(firstSegmentResult.value.buffer);\n            });\n\n            const audioData = await loadVideoUrl(audioUrl);\n            let { arrayBuffer, mimeCodec, error } = audioData;\n            if (error) {\n                console.error(error);\n            } else {\n                mediaSource.addEventListener('sourceopen', () => {\n                    const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec as any);\n                    sourceBuffer.addEventListener('updateend', () => {\n                    });\n                    sourceBuffer.appendBuffer(arrayBuffer as any);\n                });\n            }\n\n            const url = URL.createObjectURL(mediaSource);\n            video.current.src = URL.createObjectURL(mediaSource);\n            URL.revokeObjectURL(url);\n        }\n        loadVideo();\n    }, [audioUrl, videoUrl]);\n\n    return <video className={`max-h-screen ${play ? \"\" : \"hidden\"}`}\n        ref={video} controls autoPlay={false} muted loop preload=\"auto\" playsInline draggable={false}>\n    </video>\n}"],"names":["VideoHandler","videoInfo","audio","onLoadingComplete","hasAudio","className","controls","autoPlay","muted","loop","preload","playsInline","draggable","onLoadStart","url","src","type","SeparateAudioVideoHandler","videoUrl","audioUrl","loadVideoSegments","fetch","then","response","body","Error","getReader","reader","read","result","done","value","console","error","getMimeType","firstSegment","codec","muxjs","loadVideoUrl","blob","vidBlob","arrayBuffer","vidBuff","vidInt8","Int8Array","mimeCodec","MediaSource","isTypeSupported","video","useRef","useState","play","setPlay","useEffect","current","window","mediaSource","generator","next","firstSegmentResult","first","addEventListener","sourceBuffer","addSourceBuffer","addBuffer","endOfStream","appendBuffer","buffer","audioData","URL","createObjectURL","revokeObjectURL","loadVideo","ref"],"sourceRoot":""}