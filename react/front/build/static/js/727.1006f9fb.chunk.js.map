{"version":3,"file":"static/js/727.1006f9fb.chunk.js","mappings":"yRAKe,SAASA,EAAT,GAAgE,IAAxCC,EAAuC,EAAvCA,UAAWC,EAA4B,EAA5BA,MAAOC,EAAqB,EAArBA,kBACrD,OAAI,OAACF,QAAD,IAACA,GAAAA,EAAWG,WAAcF,KAAU,gBAAiBG,SAIrDC,QAAQC,IAAI,eACL,kBAAOC,UAAU,wBACpBC,UAAQ,EAACC,UAAQ,EAACC,OAAK,EAACC,MAAI,EAACC,QAAQ,OAAOC,aAAW,EAACC,WAAW,EACnEC,YAAab,EAFV,UAGH,mBAAQ,WAAUF,EAAUgB,IAAKC,IAAKjB,EAAUgB,IAAKE,KAAK,kBAP9Db,QAAQC,IAAI,mBACL,SAACa,EAAD,CAA2BC,SAAUpB,EAAUgB,IAAKK,SAAUpB,EAAOC,kBAAmBA,IAStG,UAEeoB,EAAAA,GAAAA,OAAAA,EAAAA,MAAAA,KAAAA,UAAAA,CAAAA,SAAAA,IAAhB,OAAgBA,GAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,KAAAA,MAAhB,WAAkCN,GAAlC,+GAE6BO,MAAMP,GAAKQ,MAAK,SAACC,GAClC,GAAuB,QAAX,OAARA,QAAQ,IAARA,OAAA,EAAAA,EAAUC,MACV,MAAM,IAAIC,MAAM,2BAEpB,OAAOF,EAASC,KAAKE,WACxB,KAPT,OAEcC,EAFd,sCASiCA,EAAOC,QATxC,YASkBC,EATlB,QAUuBC,KAVvB,qDAaY,OAbZ,UAakBD,EAAOE,MAbzB,iFAgBQ5B,QAAQ6B,MAAR,MAhBR,mHAoBA,SAASC,EAAYC,GACjB,IACMC,EADQC,IAAAA,IAAAA,MAAAA,OAAuBF,GACjB,GAAGC,MACvB,MAAM,sBAAN,OAA6BA,EAA7B,IACH,UAEcE,EAAAA,GAAAA,OAAAA,EAAAA,MAAAA,KAAAA,UAAAA,CAAAA,SAAAA,IAAf,OAAeA,GAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,KAAAA,MAAf,WAA4BvB,GAA5B,2GAEqCO,MAAMP,GAF3C,8BAEiDwB,OAFjD,cAEcC,EAFd,gBAG8BA,EAAQC,cAHtC,UAGcC,EAHd,OAIcC,EAAU,IAAIC,UAAUF,GACxBG,EAAYX,EAAYS,GACzBG,YAAYC,gBAAgBF,GANzC,uBAOkB,IAAInB,MAAJ,0CAA6CmB,IAP/D,iCASe,CACHJ,YAAaC,EACbG,UAAAA,IAXZ,2DAce,CAAEZ,MAAK,OAdtB,iFAkBO,SAASf,EAAT,GAA+E,IAA1CC,EAAyC,EAAzCA,SAAUC,EAA+B,EAA/BA,SAAUnB,EAAqB,EAArBA,kBACtD+C,GAAQC,EAAAA,EAAAA,QAAyB,MACvC,GAAwBC,EAAAA,EAAAA,WAAS,GAAjC,eAAOC,EAAP,KAAaC,EAAb,KA6DA,OA5DAC,EAAAA,EAAAA,YAAU,WACK,IAAD,EAANF,IACA,UAAAH,EAAMM,eAAN,SAAeH,OAEtB,GAAC,CAACA,KACHE,EAAAA,EAAAA,YAAU,WAAM,8CACZ,4GAC0B,OAAlBL,EAAMM,QADd,uBAEQlD,QAAQ6B,MAAM,oBAFtB,iCAMQsB,EAAc,IAAIT,YAEhBU,EAAYnC,EAAkBF,GARxC,SASqCqC,EAAUC,OAT/C,cASUC,EATV,OAUQC,GAAQ,EACZJ,EAAYK,iBAAiB,cAA7B,uBAA2C,iGACnCF,EAAmB3B,KADgB,sBAE7B,IAAIL,MAAM,oBAFmB,OAIjCmB,EAAYX,EAAYwB,EAAmB1B,OAC3C6B,EAAeN,EAAYO,gBAAgBjB,GAC3CkB,EANiC,yCAMrB,yGACOP,EAAUC,OADjB,QACR3B,EADQ,QAEHC,KACPwB,EAAYS,cAEZH,EAAaI,aAAanC,EAAOE,MAAMkC,QAEvCP,IACAA,GAAQ,EACR1D,IACAmD,GAAQ,IAVE,2CANqB,qDAmBvCS,EAAaD,iBAAiB,YAAaG,GAC3CF,EAAaI,aAAaP,EAAmB1B,MAAMkC,QApBZ,4CAX/C,UAkC4B5B,EAAalB,GAlCzC,QAkCU+C,EAlCV,OAmCU1B,EAAkC0B,EAAlC1B,YAAaI,EAAqBsB,EAArBtB,WAAWZ,EAAUkC,EAAVlC,OAE1B7B,QAAQ6B,MAAMA,GAEdsB,EAAYK,iBAAiB,cAAc,WACvC,IAAMC,EAAeN,EAAYO,gBAAgBjB,GACjDgB,EAAaD,iBAAiB,aAAa,WAC1C,IACDC,EAAaI,aAAaxB,EAC7B,IAGC1B,EAAMqD,IAAIC,gBAAgBd,GAChCP,EAAMM,QAAQtC,IAAMoD,IAAIC,gBAAgBd,GACxCa,IAAIE,gBAAgBvD,GAjDxB,4CADY,yBAAC,WAAD,wBAoDZwD,EACH,GAAE,CAACnD,EAAUD,EAAUlB,KAEjB,kBAAOK,UAAS,gCAA2B6C,EAAO,GAAK,aAC1DqB,IAAKxB,EAAOzC,UAAQ,EAACC,UAAU,EAAOC,OAAK,EAACC,MAAI,EAACC,QAAQ,OAAOC,aAAW,EAACC,WAAW,GAE9F,C","sources":["components/MediaElement/components/VideoHandler.tsx"],"sourcesContent":["import muxjs from 'mux.js';\nimport { useEffect, useRef, useState } from \"react\";\n\n\n\nexport default function VideoHandler({ videoInfo, audio, onLoadingComplete }) {\n    if (!videoInfo?.hasAudio && !!audio && ('MediaSource' in window)) {\n        console.log('separate audio')\n        return <SeparateAudioVideoHandler videoUrl={videoInfo.url} audioUrl={audio} onLoadingComplete={onLoadingComplete} />\n    } else {\n        console.log('all in one')\n        return <video className=\"max-h-full max-w-full\"\n            controls autoPlay muted loop preload=\"auto\" playsInline draggable={false}\n            onLoadStart={onLoadingComplete}>\n            <source data-src={videoInfo.url} src={videoInfo.url} type=\"video/mp4\" />\n        </video>\n    }\n}\n\nasync function* loadVideoSegments(url) {\n    try {\n        const reader = await fetch(url).then((response) => {\n            if (response?.body === null) {\n                throw new Error(\"response null, no video\");\n            }\n            return response.body.getReader();\n        });\n        while (true) {\n            const result = await reader.read();\n            if (result.done) {\n                break;\n            }\n            yield result.value;\n        }\n    } catch (error) {\n        console.error(error);\n    }\n    return;\n}\nfunction getMimeType(firstSegment) {\n    const probe = muxjs.mp4.probe.tracks(firstSegment)\n    const codec = probe[0].codec;\n    return `video/mp4; codecs=\"${codec}\"`;\n}\n\nasync function loadVideoUrl(url) {\n    try {\n        const vidBlob = await (await fetch(url)).blob();\n        const vidBuff = await vidBlob.arrayBuffer();\n        const vidInt8 = new Int8Array(vidBuff);\n        const mimeCodec = getMimeType(vidInt8);\n        if (!MediaSource.isTypeSupported(mimeCodec)) {\n            throw new Error(`Unsupported MIME type or codec: ${mimeCodec}`);\n        }\n        return {\n            arrayBuffer: vidBuff,\n            mimeCodec,\n        }\n    } catch (error) {\n        return { error };\n    }\n}\n\nexport function SeparateAudioVideoHandler({ videoUrl, audioUrl, onLoadingComplete }) {\n    const video = useRef<HTMLVideoElement>(null);\n    const [play, setPlay] = useState(false);\n    useEffect(() => {\n        if (play) {\n            video.current?.play();\n        }\n    },[play])\n    useEffect(() => {\n        async function loadVideo() {\n            if (video.current === null) {\n                console.error('videoRef not set');\n                return;\n            }\n\n            let mediaSource = new MediaSource();\n\n            const generator = loadVideoSegments(videoUrl);\n            const firstSegmentResult = await generator.next();\n            let first = true;\n            mediaSource.addEventListener('sourceopen', async () => {\n                if (firstSegmentResult.done) {\n                    throw new Error(\"no first segment\");\n                }\n                const mimeCodec = getMimeType(firstSegmentResult.value);\n                const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n                const addBuffer = async () => {\n                    const result = await generator.next();\n                    if (result.done) {\n                        mediaSource.endOfStream();\n                    } else {\n                        sourceBuffer.appendBuffer(result.value.buffer);\n                    }\n                    if (first) {\n                        first = false;\n                        onLoadingComplete();\n                        setPlay(true);\n                    }\n                }\n                sourceBuffer.addEventListener('updateend', addBuffer);\n                sourceBuffer.appendBuffer(firstSegmentResult.value.buffer);\n            });\n\n            const audioData = await loadVideoUrl(audioUrl);\n            let { arrayBuffer, mimeCodec, error } = audioData;\n            if (error) {\n                console.error(error);\n            } else {\n                mediaSource.addEventListener('sourceopen', () => {\n                    const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec as any);\n                    sourceBuffer.addEventListener('updateend', () => {\n                    });\n                    sourceBuffer.appendBuffer(arrayBuffer as any);\n                });\n            }\n\n            const url = URL.createObjectURL(mediaSource);\n            video.current.src = URL.createObjectURL(mediaSource);\n            URL.revokeObjectURL(url);\n        }\n        loadVideo();\n    }, [audioUrl, videoUrl, onLoadingComplete]);\n\n    return <video className={`max-h-full max-w-full ${play ? \"\" : \"invisible\"}`}\n        ref={video} controls autoPlay={false} muted loop preload=\"auto\" playsInline draggable={false}>\n    </video>\n}"],"names":["VideoHandler","videoInfo","audio","onLoadingComplete","hasAudio","window","console","log","className","controls","autoPlay","muted","loop","preload","playsInline","draggable","onLoadStart","url","src","type","SeparateAudioVideoHandler","videoUrl","audioUrl","loadVideoSegments","fetch","then","response","body","Error","getReader","reader","read","result","done","value","error","getMimeType","firstSegment","codec","muxjs","loadVideoUrl","blob","vidBlob","arrayBuffer","vidBuff","vidInt8","Int8Array","mimeCodec","MediaSource","isTypeSupported","video","useRef","useState","play","setPlay","useEffect","current","mediaSource","generator","next","firstSegmentResult","first","addEventListener","sourceBuffer","addSourceBuffer","addBuffer","endOfStream","appendBuffer","buffer","audioData","URL","createObjectURL","revokeObjectURL","loadVideo","ref"],"sourceRoot":""}