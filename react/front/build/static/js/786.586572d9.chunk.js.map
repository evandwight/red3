{"version":3,"file":"static/js/786.586572d9.chunk.js","mappings":"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","sources":["../node_modules/global/window.js","../node_modules/mux.js/dist/mux.js","../node_modules/@babel/runtime/helpers/esm/AwaitValue.js","../node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js","../node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js","../node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js"],"sourcesContent":["var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n","/*! @name mux.js @version 6.2.0 @license Apache-2.0 */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('global/window')) :\n  typeof define === 'function' && define.amd ? define(['global/window'], factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.muxjs = factory(global.window));\n}(this, (function (window) { 'use strict';\n\n  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\n  var window__default = /*#__PURE__*/_interopDefaultLegacy(window);\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * A lightweight readable stream implemention that handles event dispatching.\n   * Objects that inherit from streams should call init in their constructors.\n   */\n\n  var Stream = function Stream() {\n    this.init = function () {\n      var listeners = {};\n      /**\n       * Add a listener for a specified event type.\n       * @param type {string} the event name\n       * @param listener {function} the callback to be invoked when an event of\n       * the specified type occurs\n       */\n\n      this.on = function (type, listener) {\n        if (!listeners[type]) {\n          listeners[type] = [];\n        }\n\n        listeners[type] = listeners[type].concat(listener);\n      };\n      /**\n       * Remove a listener for a specified event type.\n       * @param type {string} the event name\n       * @param listener {function} a function previously registered for this\n       * type of event through `on`\n       */\n\n\n      this.off = function (type, listener) {\n        var index;\n\n        if (!listeners[type]) {\n          return false;\n        }\n\n        index = listeners[type].indexOf(listener);\n        listeners[type] = listeners[type].slice();\n        listeners[type].splice(index, 1);\n        return index > -1;\n      };\n      /**\n       * Trigger an event of the specified type on this stream. Any additional\n       * arguments to this function are passed as parameters to event listeners.\n       * @param type {string} the event name\n       */\n\n\n      this.trigger = function (type) {\n        var callbacks, i, length, args;\n        callbacks = listeners[type];\n\n        if (!callbacks) {\n          return;\n        } // Slicing the arguments on every invocation of this method\n        // can add a significant amount of overhead. Avoid the\n        // intermediate object creation for the common case of a\n        // single callback argument\n\n\n        if (arguments.length === 2) {\n          length = callbacks.length;\n\n          for (i = 0; i < length; ++i) {\n            callbacks[i].call(this, arguments[1]);\n          }\n        } else {\n          args = [];\n          i = arguments.length;\n\n          for (i = 1; i < arguments.length; ++i) {\n            args.push(arguments[i]);\n          }\n\n          length = callbacks.length;\n\n          for (i = 0; i < length; ++i) {\n            callbacks[i].apply(this, args);\n          }\n        }\n      };\n      /**\n       * Destroys the stream and cleans up.\n       */\n\n\n      this.dispose = function () {\n        listeners = {};\n      };\n    };\n  };\n  /**\n   * Forwards all `data` events on this stream to the destination stream. The\n   * destination stream should provide a method `push` to receive the data\n   * events as they arrive.\n   * @param destination {stream} the stream that will receive all `data` events\n   * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n   *                            when the current stream emits a 'done' event\n   * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n   */\n\n\n  Stream.prototype.pipe = function (destination) {\n    this.on('data', function (data) {\n      destination.push(data);\n    });\n    this.on('done', function (flushSource) {\n      destination.flush(flushSource);\n    });\n    this.on('partialdone', function (flushSource) {\n      destination.partialFlush(flushSource);\n    });\n    this.on('endedtimeline', function (flushSource) {\n      destination.endTimeline(flushSource);\n    });\n    this.on('reset', function (flushSource) {\n      destination.reset(flushSource);\n    });\n    return destination;\n  }; // Default stream functions that are expected to be overridden to perform\n  // actual work. These are provided by the prototype as a sort of no-op\n  // implementation so that we don't have to check for their existence in the\n  // `pipe` function above.\n\n\n  Stream.prototype.push = function (data) {\n    this.trigger('data', data);\n  };\n\n  Stream.prototype.flush = function (flushSource) {\n    this.trigger('done', flushSource);\n  };\n\n  Stream.prototype.partialFlush = function (flushSource) {\n    this.trigger('partialdone', flushSource);\n  };\n\n  Stream.prototype.endTimeline = function (flushSource) {\n    this.trigger('endedtimeline', flushSource);\n  };\n\n  Stream.prototype.reset = function (flushSource) {\n    this.trigger('reset', flushSource);\n  };\n\n  var stream = Stream;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  var ONE_SECOND_IN_TS$5 = 90000,\n      // 90kHz clock\n  secondsToVideoTs,\n      secondsToAudioTs,\n      videoTsToSeconds,\n      audioTsToSeconds,\n      audioTsToVideoTs,\n      videoTsToAudioTs,\n      metadataTsToSeconds;\n\n  secondsToVideoTs = function secondsToVideoTs(seconds) {\n    return seconds * ONE_SECOND_IN_TS$5;\n  };\n\n  secondsToAudioTs = function secondsToAudioTs(seconds, sampleRate) {\n    return seconds * sampleRate;\n  };\n\n  videoTsToSeconds = function videoTsToSeconds(timestamp) {\n    return timestamp / ONE_SECOND_IN_TS$5;\n  };\n\n  audioTsToSeconds = function audioTsToSeconds(timestamp, sampleRate) {\n    return timestamp / sampleRate;\n  };\n\n  audioTsToVideoTs = function audioTsToVideoTs(timestamp, sampleRate) {\n    return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n  };\n\n  videoTsToAudioTs = function videoTsToAudioTs(timestamp, sampleRate) {\n    return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n  };\n  /**\n   * Adjust ID3 tag or caption timing information by the timeline pts values\n   * (if keepOriginalTimestamps is false) and convert to seconds\n   */\n\n\n  metadataTsToSeconds = function metadataTsToSeconds(timestamp, timelineStartPts, keepOriginalTimestamps) {\n    return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);\n  };\n\n  var clock = {\n    ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$5,\n    secondsToVideoTs: secondsToVideoTs,\n    secondsToAudioTs: secondsToAudioTs,\n    videoTsToSeconds: videoTsToSeconds,\n    audioTsToSeconds: audioTsToSeconds,\n    audioTsToVideoTs: audioTsToVideoTs,\n    videoTsToAudioTs: videoTsToAudioTs,\n    metadataTsToSeconds: metadataTsToSeconds\n  };\n\n  var ONE_SECOND_IN_TS$4 = clock.ONE_SECOND_IN_TS;\n\n  var _AdtsStream;\n\n  var ADTS_SAMPLING_FREQUENCIES$1 = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  /*\n   * Accepts a ElementaryStream and emits data events with parsed\n   * AAC Audio Frames of the individual packets. Input audio in ADTS\n   * format is unpacked and re-emitted as AAC frames.\n   *\n   * @see http://wiki.multimedia.cx/index.php?title=ADTS\n   * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n   */\n\n  _AdtsStream = function AdtsStream(handlePartialSegments) {\n    var buffer,\n        frameNum = 0;\n\n    _AdtsStream.prototype.init.call(this);\n\n    this.skipWarn_ = function (start, end) {\n      this.trigger('log', {\n        level: 'warn',\n        message: \"adts skiping bytes \" + start + \" to \" + end + \" in frame \" + frameNum + \" outside syncword\"\n      });\n    };\n\n    this.push = function (packet) {\n      var i = 0,\n          frameLength,\n          protectionSkipBytes,\n          oldBuffer,\n          sampleCount,\n          adtsFrameDuration;\n\n      if (!handlePartialSegments) {\n        frameNum = 0;\n      }\n\n      if (packet.type !== 'audio') {\n        // ignore non-audio data\n        return;\n      } // Prepend any data in the buffer to the input data so that we can parse\n      // aac frames the cross a PES packet boundary\n\n\n      if (buffer && buffer.length) {\n        oldBuffer = buffer;\n        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n        buffer.set(oldBuffer);\n        buffer.set(packet.data, oldBuffer.byteLength);\n      } else {\n        buffer = packet.data;\n      } // unpack any ADTS frames which have been fully received\n      // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n\n\n      var skip; // We use i + 7 here because we want to be able to parse the entire header.\n      // If we don't have enough bytes to do that, then we definitely won't have a full frame.\n\n      while (i + 7 < buffer.length) {\n        // Look for the start of an ADTS header..\n        if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n          if (typeof skip !== 'number') {\n            skip = i;\n          } // If a valid header was not found,  jump one forward and attempt to\n          // find a valid ADTS header starting at the next byte\n\n\n          i++;\n          continue;\n        }\n\n        if (typeof skip === 'number') {\n          this.skipWarn_(skip, i);\n          skip = null;\n        } // The protection skip bit tells us if we have 2 bytes of CRC data at the\n        // end of the ADTS header\n\n\n        protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2; // Frame length is a 13 bit integer starting 16 bits from the\n        // end of the sync sequence\n        // NOTE: frame length includes the size of the header\n\n        frameLength = (buffer[i + 3] & 0x03) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 0xe0) >> 5;\n        sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$4 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2]; // If we don't have enough data to actually finish this ADTS frame,\n        // then we have to wait for more data\n\n        if (buffer.byteLength - i < frameLength) {\n          break;\n        } // Otherwise, deliver the complete AAC frame\n\n\n        this.trigger('data', {\n          pts: packet.pts + frameNum * adtsFrameDuration,\n          dts: packet.dts + frameNum * adtsFrameDuration,\n          sampleCount: sampleCount,\n          audioobjecttype: (buffer[i + 2] >>> 6 & 0x03) + 1,\n          channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 0xc0) >>> 6,\n          samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 0x3c) >>> 2],\n          samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n          // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n          samplesize: 16,\n          // data is the frame without it's header\n          data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n        });\n        frameNum++;\n        i += frameLength;\n      }\n\n      if (typeof skip === 'number') {\n        this.skipWarn_(skip, i);\n        skip = null;\n      } // remove processed bytes from the buffer.\n\n\n      buffer = buffer.subarray(i);\n    };\n\n    this.flush = function () {\n      frameNum = 0;\n      this.trigger('done');\n    };\n\n    this.reset = function () {\n      buffer = void 0;\n      this.trigger('reset');\n    };\n\n    this.endTimeline = function () {\n      buffer = void 0;\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _AdtsStream.prototype = new stream();\n  var adts = _AdtsStream;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var ExpGolomb;\n  /**\n   * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n   * scheme used by h264.\n   */\n\n  ExpGolomb = function ExpGolomb(workingData) {\n    var // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n        // the current word being examined\n    workingWord = 0,\n        // :uint\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n    // ():uint\n\n    this.length = function () {\n      return 8 * workingBytesAvailable;\n    }; // ():uint\n\n\n    this.bitsAvailable = function () {\n      return 8 * workingBytesAvailable + workingBitsAvailable;\n    }; // ():void\n\n\n    this.loadWord = function () {\n      var position = workingData.byteLength - workingBytesAvailable,\n          workingBytes = new Uint8Array(4),\n          availableBytes = Math.min(4, workingBytesAvailable);\n\n      if (availableBytes === 0) {\n        throw new Error('no bytes available');\n      }\n\n      workingBytes.set(workingData.subarray(position, position + availableBytes));\n      workingWord = new DataView(workingBytes.buffer).getUint32(0); // track the amount of workingData that has been processed\n\n      workingBitsAvailable = availableBytes * 8;\n      workingBytesAvailable -= availableBytes;\n    }; // (count:int):void\n\n\n    this.skipBits = function (count) {\n      var skipBytes; // :int\n\n      if (workingBitsAvailable > count) {\n        workingWord <<= count;\n        workingBitsAvailable -= count;\n      } else {\n        count -= workingBitsAvailable;\n        skipBytes = Math.floor(count / 8);\n        count -= skipBytes * 8;\n        workingBytesAvailable -= skipBytes;\n        this.loadWord();\n        workingWord <<= count;\n        workingBitsAvailable -= count;\n      }\n    }; // (size:int):uint\n\n\n    this.readBits = function (size) {\n      var bits = Math.min(workingBitsAvailable, size),\n          // :uint\n      valu = workingWord >>> 32 - bits; // :uint\n      // if size > 31, handle error\n\n      workingBitsAvailable -= bits;\n\n      if (workingBitsAvailable > 0) {\n        workingWord <<= bits;\n      } else if (workingBytesAvailable > 0) {\n        this.loadWord();\n      }\n\n      bits = size - bits;\n\n      if (bits > 0) {\n        return valu << bits | this.readBits(bits);\n      }\n\n      return valu;\n    }; // ():uint\n\n\n    this.skipLeadingZeros = function () {\n      var leadingZeroCount; // :uint\n\n      for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n        if ((workingWord & 0x80000000 >>> leadingZeroCount) !== 0) {\n          // the first bit of working word is 1\n          workingWord <<= leadingZeroCount;\n          workingBitsAvailable -= leadingZeroCount;\n          return leadingZeroCount;\n        }\n      } // we exhausted workingWord and still have not found a 1\n\n\n      this.loadWord();\n      return leadingZeroCount + this.skipLeadingZeros();\n    }; // ():void\n\n\n    this.skipUnsignedExpGolomb = function () {\n      this.skipBits(1 + this.skipLeadingZeros());\n    }; // ():void\n\n\n    this.skipExpGolomb = function () {\n      this.skipBits(1 + this.skipLeadingZeros());\n    }; // ():uint\n\n\n    this.readUnsignedExpGolomb = function () {\n      var clz = this.skipLeadingZeros(); // :uint\n\n      return this.readBits(clz + 1) - 1;\n    }; // ():int\n\n\n    this.readExpGolomb = function () {\n      var valu = this.readUnsignedExpGolomb(); // :int\n\n      if (0x01 & valu) {\n        // the number is odd if the low order bit is set\n        return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n      }\n\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }; // Some convenience functions\n    // :Boolean\n\n\n    this.readBoolean = function () {\n      return this.readBits(1) === 1;\n    }; // ():int\n\n\n    this.readUnsignedByte = function () {\n      return this.readBits(8);\n    };\n\n    this.loadWord();\n  };\n\n  var expGolomb = ExpGolomb;\n\n  var _H264Stream, _NalByteStream;\n\n  var PROFILES_WITH_OPTIONAL_SPS_DATA;\n  /**\n   * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n   */\n\n  _NalByteStream = function NalByteStream() {\n    var syncPoint = 0,\n        i,\n        buffer;\n\n    _NalByteStream.prototype.init.call(this);\n    /*\n     * Scans a byte stream and triggers a data event with the NAL units found.\n     * @param {Object} data Event received from H264Stream\n     * @param {Uint8Array} data.data The h264 byte stream to be scanned\n     *\n     * @see H264Stream.push\n     */\n\n\n    this.push = function (data) {\n      var swapBuffer;\n\n      if (!buffer) {\n        buffer = data.data;\n      } else {\n        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n        swapBuffer.set(buffer);\n        swapBuffer.set(data.data, buffer.byteLength);\n        buffer = swapBuffer;\n      }\n\n      var len = buffer.byteLength; // Rec. ITU-T H.264, Annex B\n      // scan for NAL unit boundaries\n      // a match looks like this:\n      // 0 0 1 .. NAL .. 0 0 1\n      // ^ sync point        ^ i\n      // or this:\n      // 0 0 1 .. NAL .. 0 0 0\n      // ^ sync point        ^ i\n      // advance the sync point to a NAL start, if necessary\n\n      for (; syncPoint < len - 3; syncPoint++) {\n        if (buffer[syncPoint + 2] === 1) {\n          // the sync point is properly aligned\n          i = syncPoint + 5;\n          break;\n        }\n      }\n\n      while (i < len) {\n        // look at the current byte to determine if we've hit the end of\n        // a NAL unit boundary\n        switch (buffer[i]) {\n          case 0:\n            // skip past non-sync sequences\n            if (buffer[i - 1] !== 0) {\n              i += 2;\n              break;\n            } else if (buffer[i - 2] !== 0) {\n              i++;\n              break;\n            } // deliver the NAL unit if it isn't empty\n\n\n            if (syncPoint + 3 !== i - 2) {\n              this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n            } // drop trailing zeroes\n\n\n            do {\n              i++;\n            } while (buffer[i] !== 1 && i < len);\n\n            syncPoint = i - 2;\n            i += 3;\n            break;\n\n          case 1:\n            // skip past non-sync sequences\n            if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {\n              i += 3;\n              break;\n            } // deliver the NAL unit\n\n\n            this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n            syncPoint = i - 2;\n            i += 3;\n            break;\n\n          default:\n            // the current byte isn't a one or zero, so it cannot be part\n            // of a sync sequence\n            i += 3;\n            break;\n        }\n      } // filter out the NAL units that were delivered\n\n\n      buffer = buffer.subarray(syncPoint);\n      i -= syncPoint;\n      syncPoint = 0;\n    };\n\n    this.reset = function () {\n      buffer = null;\n      syncPoint = 0;\n      this.trigger('reset');\n    };\n\n    this.flush = function () {\n      // deliver the last buffered NAL unit\n      if (buffer && buffer.byteLength > 3) {\n        this.trigger('data', buffer.subarray(syncPoint + 3));\n      } // reset the stream state\n\n\n      buffer = null;\n      syncPoint = 0;\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _NalByteStream.prototype = new stream(); // values of profile_idc that indicate additional fields are included in the SPS\n  // see Recommendation ITU-T H.264 (4/2013),\n  // 7.3.2.1.1 Sequence parameter set data syntax\n\n  PROFILES_WITH_OPTIONAL_SPS_DATA = {\n    100: true,\n    110: true,\n    122: true,\n    244: true,\n    44: true,\n    83: true,\n    86: true,\n    118: true,\n    128: true,\n    // TODO: the three profiles below don't\n    // appear to have sps data in the specificiation anymore?\n    138: true,\n    139: true,\n    134: true\n  };\n  /**\n   * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n   * events.\n   */\n\n  _H264Stream = function H264Stream() {\n    var nalByteStream = new _NalByteStream(),\n        self,\n        trackId,\n        currentPts,\n        currentDts,\n        discardEmulationPreventionBytes,\n        readSequenceParameterSet,\n        skipScalingList;\n\n    _H264Stream.prototype.init.call(this);\n\n    self = this;\n    /*\n     * Pushes a packet from a stream onto the NalByteStream\n     *\n     * @param {Object} packet - A packet received from a stream\n     * @param {Uint8Array} packet.data - The raw bytes of the packet\n     * @param {Number} packet.dts - Decode timestamp of the packet\n     * @param {Number} packet.pts - Presentation timestamp of the packet\n     * @param {Number} packet.trackId - The id of the h264 track this packet came from\n     * @param {('video'|'audio')} packet.type - The type of packet\n     *\n     */\n\n    this.push = function (packet) {\n      if (packet.type !== 'video') {\n        return;\n      }\n\n      trackId = packet.trackId;\n      currentPts = packet.pts;\n      currentDts = packet.dts;\n      nalByteStream.push(packet);\n    };\n    /*\n     * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n     * for the NALUs to the next stream component.\n     * Also, preprocess caption and sequence parameter NALUs.\n     *\n     * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n     * @see NalByteStream.push\n     */\n\n\n    nalByteStream.on('data', function (data) {\n      var event = {\n        trackId: trackId,\n        pts: currentPts,\n        dts: currentDts,\n        data: data,\n        nalUnitTypeCode: data[0] & 0x1f\n      };\n\n      switch (event.nalUnitTypeCode) {\n        case 0x05:\n          event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n          break;\n\n        case 0x06:\n          event.nalUnitType = 'sei_rbsp';\n          event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n          break;\n\n        case 0x07:\n          event.nalUnitType = 'seq_parameter_set_rbsp';\n          event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n          event.config = readSequenceParameterSet(event.escapedRBSP);\n          break;\n\n        case 0x08:\n          event.nalUnitType = 'pic_parameter_set_rbsp';\n          break;\n\n        case 0x09:\n          event.nalUnitType = 'access_unit_delimiter_rbsp';\n          break;\n      } // This triggers data on the H264Stream\n\n\n      self.trigger('data', event);\n    });\n    nalByteStream.on('done', function () {\n      self.trigger('done');\n    });\n    nalByteStream.on('partialdone', function () {\n      self.trigger('partialdone');\n    });\n    nalByteStream.on('reset', function () {\n      self.trigger('reset');\n    });\n    nalByteStream.on('endedtimeline', function () {\n      self.trigger('endedtimeline');\n    });\n\n    this.flush = function () {\n      nalByteStream.flush();\n    };\n\n    this.partialFlush = function () {\n      nalByteStream.partialFlush();\n    };\n\n    this.reset = function () {\n      nalByteStream.reset();\n    };\n\n    this.endTimeline = function () {\n      nalByteStream.endTimeline();\n    };\n    /**\n     * Advance the ExpGolomb decoder past a scaling list. The scaling\n     * list is optionally transmitted as part of a sequence parameter\n     * set and is not relevant to transmuxing.\n     * @param count {number} the number of entries in this scaling list\n     * @param expGolombDecoder {object} an ExpGolomb pointed to the\n     * start of a scaling list\n     * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n     */\n\n\n    skipScalingList = function skipScalingList(count, expGolombDecoder) {\n      var lastScale = 8,\n          nextScale = 8,\n          j,\n          deltaScale;\n\n      for (j = 0; j < count; j++) {\n        if (nextScale !== 0) {\n          deltaScale = expGolombDecoder.readExpGolomb();\n          nextScale = (lastScale + deltaScale + 256) % 256;\n        }\n\n        lastScale = nextScale === 0 ? lastScale : nextScale;\n      }\n    };\n    /**\n     * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n     * Sequence Payload\"\n     * @param data {Uint8Array} the bytes of a RBSP from a NAL\n     * unit\n     * @return {Uint8Array} the RBSP without any Emulation\n     * Prevention Bytes\n     */\n\n\n    discardEmulationPreventionBytes = function discardEmulationPreventionBytes(data) {\n      var length = data.byteLength,\n          emulationPreventionBytesPositions = [],\n          i = 1,\n          newLength,\n          newData; // Find all `Emulation Prevention Bytes`\n\n      while (i < length - 2) {\n        if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n          emulationPreventionBytesPositions.push(i + 2);\n          i += 2;\n        } else {\n          i++;\n        }\n      } // If no Emulation Prevention Bytes were found just return the original\n      // array\n\n\n      if (emulationPreventionBytesPositions.length === 0) {\n        return data;\n      } // Create a new array to hold the NAL unit data\n\n\n      newLength = length - emulationPreventionBytesPositions.length;\n      newData = new Uint8Array(newLength);\n      var sourceIndex = 0;\n\n      for (i = 0; i < newLength; sourceIndex++, i++) {\n        if (sourceIndex === emulationPreventionBytesPositions[0]) {\n          // Skip this byte\n          sourceIndex++; // Remove this position index\n\n          emulationPreventionBytesPositions.shift();\n        }\n\n        newData[i] = data[sourceIndex];\n      }\n\n      return newData;\n    };\n    /**\n     * Read a sequence parameter set and return some interesting video\n     * properties. A sequence parameter set is the H264 metadata that\n     * describes the properties of upcoming video frames.\n     * @param data {Uint8Array} the bytes of a sequence parameter set\n     * @return {object} an object with configuration parsed from the\n     * sequence parameter set, including the dimensions of the\n     * associated video frames.\n     */\n\n\n    readSequenceParameterSet = function readSequenceParameterSet(data) {\n      var frameCropLeftOffset = 0,\n          frameCropRightOffset = 0,\n          frameCropTopOffset = 0,\n          frameCropBottomOffset = 0,\n          expGolombDecoder,\n          profileIdc,\n          levelIdc,\n          profileCompatibility,\n          chromaFormatIdc,\n          picOrderCntType,\n          numRefFramesInPicOrderCntCycle,\n          picWidthInMbsMinus1,\n          picHeightInMapUnitsMinus1,\n          frameMbsOnlyFlag,\n          scalingListCount,\n          sarRatio = [1, 1],\n          aspectRatioIdc,\n          i;\n      expGolombDecoder = new expGolomb(data);\n      profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n\n      profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n\n      levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n      // some profiles have more optional data we don't need\n\n      if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n\n        if (chromaFormatIdc === 3) {\n          expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n        }\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n\n        expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n\n        expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n\n        if (expGolombDecoder.readBoolean()) {\n          // seq_scaling_matrix_present_flag\n          scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n\n          for (i = 0; i < scalingListCount; i++) {\n            if (expGolombDecoder.readBoolean()) {\n              // seq_scaling_list_present_flag[ i ]\n              if (i < 6) {\n                skipScalingList(16, expGolombDecoder);\n              } else {\n                skipScalingList(64, expGolombDecoder);\n              }\n            }\n          }\n        }\n      }\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n\n      picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n      if (picOrderCntType === 0) {\n        expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n      } else if (picOrderCntType === 1) {\n        expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n\n        expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n\n        expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n\n        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n\n        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n          expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n        }\n      }\n\n      expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n\n      expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n      picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n      picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n      frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n\n      if (frameMbsOnlyFlag === 0) {\n        expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n      }\n\n      expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n\n      if (expGolombDecoder.readBoolean()) {\n        // frame_cropping_flag\n        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n      }\n\n      if (expGolombDecoder.readBoolean()) {\n        // vui_parameters_present_flag\n        if (expGolombDecoder.readBoolean()) {\n          // aspect_ratio_info_present_flag\n          aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n\n          switch (aspectRatioIdc) {\n            case 1:\n              sarRatio = [1, 1];\n              break;\n\n            case 2:\n              sarRatio = [12, 11];\n              break;\n\n            case 3:\n              sarRatio = [10, 11];\n              break;\n\n            case 4:\n              sarRatio = [16, 11];\n              break;\n\n            case 5:\n              sarRatio = [40, 33];\n              break;\n\n            case 6:\n              sarRatio = [24, 11];\n              break;\n\n            case 7:\n              sarRatio = [20, 11];\n              break;\n\n            case 8:\n              sarRatio = [32, 11];\n              break;\n\n            case 9:\n              sarRatio = [80, 33];\n              break;\n\n            case 10:\n              sarRatio = [18, 11];\n              break;\n\n            case 11:\n              sarRatio = [15, 11];\n              break;\n\n            case 12:\n              sarRatio = [64, 33];\n              break;\n\n            case 13:\n              sarRatio = [160, 99];\n              break;\n\n            case 14:\n              sarRatio = [4, 3];\n              break;\n\n            case 15:\n              sarRatio = [3, 2];\n              break;\n\n            case 16:\n              sarRatio = [2, 1];\n              break;\n\n            case 255:\n              {\n                sarRatio = [expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte()];\n                break;\n              }\n          }\n\n          if (sarRatio) {\n            sarRatio[0] / sarRatio[1];\n          }\n        }\n      }\n\n      return {\n        profileIdc: profileIdc,\n        levelIdc: levelIdc,\n        profileCompatibility: profileCompatibility,\n        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,\n        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,\n        // sar is sample aspect ratio\n        sarRatio: sarRatio\n      };\n    };\n  };\n\n  _H264Stream.prototype = new stream();\n  var h264 = {\n    H264Stream: _H264Stream,\n    NalByteStream: _NalByteStream\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var codecs = {\n    Adts: adts,\n    h264: h264\n  };\n\n  var MAX_UINT32$1 = Math.pow(2, 32);\n\n  var getUint64$4 = function getUint64(uint8) {\n    var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);\n    var value;\n\n    if (dv.getBigUint64) {\n      value = dv.getBigUint64(0);\n\n      if (value < Number.MAX_SAFE_INTEGER) {\n        return Number(value);\n      }\n\n      return value;\n    }\n\n    return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);\n  };\n\n  var numbers = {\n    getUint64: getUint64$4,\n    MAX_UINT32: MAX_UINT32$1\n  };\n\n  var MAX_UINT32 = numbers.MAX_UINT32;\n  var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS; // pre-calculate constants\n\n  (function () {\n    var i;\n    types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      // codingname\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      smhd: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      styp: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: []\n    }; // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n    // don't throw an error\n\n    if (typeof Uint8Array === 'undefined') {\n      return;\n    }\n\n    for (i in types) {\n      if (types.hasOwnProperty(i)) {\n        types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n\n    MAJOR_BRAND = new Uint8Array(['i'.charCodeAt(0), 's'.charCodeAt(0), 'o'.charCodeAt(0), 'm'.charCodeAt(0)]);\n    AVC1_BRAND = new Uint8Array(['a'.charCodeAt(0), 'v'.charCodeAt(0), 'c'.charCodeAt(0), '1'.charCodeAt(0)]);\n    MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n    VIDEO_HDLR = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    AUDIO_HDLR = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    HDLR_TYPES = {\n      video: VIDEO_HDLR,\n      audio: AUDIO_HDLR\n    };\n    DREF = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    SMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance, 0 means centered\n    0x00, 0x00 // reserved\n    ]);\n    STCO = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    STSC = STCO;\n    STSZ = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    STTS = STCO;\n    VMHD = new Uint8Array([0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n  })();\n\n  box = function box(type) {\n    var payload = [],\n        size = 0,\n        i,\n        result,\n        view;\n\n    for (i = 1; i < arguments.length; i++) {\n      payload.push(arguments[i]);\n    }\n\n    i = payload.length; // calculate the total size we need to allocate\n\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n\n    result = new Uint8Array(size + 8);\n    view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n    view.setUint32(0, result.byteLength);\n    result.set(type, 4); // copy the payload into the result\n\n    for (i = 0, size = 8; i < payload.length; i++) {\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n\n    return result;\n  };\n\n  dinf = function dinf() {\n    return box(types.dinf, box(types.dref, DREF));\n  };\n\n  esds = function esds(track) {\n    return box(types.esds, new Uint8Array([0x00, // version\n    0x00, 0x00, 0x00, // flags\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15, // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 0x06, 0x01, 0x02 // GASpecificConfig\n    ]));\n  };\n\n  ftyp = function ftyp() {\n    return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n  };\n\n  hdlr = function hdlr(type) {\n    return box(types.hdlr, HDLR_TYPES[type]);\n  };\n\n  mdat = function mdat(data) {\n    return box(types.mdat, data);\n  };\n\n  mdhd = function mdhd(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n    track.duration >>> 24 & 0xFF, track.duration >>> 16 & 0xFF, track.duration >>> 8 & 0xFF, track.duration & 0xFF, // duration\n    0x55, 0xc4, // 'und' language (undetermined)\n    0x00, 0x00]); // Use the sample rate from the track metadata, when it is\n    // defined. The sample rate can be parsed out of an ADTS header, for\n    // instance.\n\n    if (track.samplerate) {\n      result[12] = track.samplerate >>> 24 & 0xFF;\n      result[13] = track.samplerate >>> 16 & 0xFF;\n      result[14] = track.samplerate >>> 8 & 0xFF;\n      result[15] = track.samplerate & 0xFF;\n    }\n\n    return box(types.mdhd, result);\n  };\n\n  mdia = function mdia(track) {\n    return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n  };\n\n  mfhd = function mfhd(sequenceNumber) {\n    return box(types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24, (sequenceNumber & 0xFF0000) >> 16, (sequenceNumber & 0xFF00) >> 8, sequenceNumber & 0xFF // sequence_number\n    ]));\n  };\n\n  minf = function minf(track) {\n    return box(types.minf, track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));\n  };\n\n  moof = function moof(sequenceNumber, tracks) {\n    var trackFragments = [],\n        i = tracks.length; // build traf boxes for each track fragment\n\n    while (i--) {\n      trackFragments[i] = traf(tracks[i]);\n    }\n\n    return box.apply(null, [types.moof, mfhd(sequenceNumber)].concat(trackFragments));\n  };\n  /**\n   * Returns a movie box.\n   * @param tracks {array} the tracks associated with this movie\n   * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n   */\n\n\n  moov = function moov(tracks) {\n    var i = tracks.length,\n        boxes = [];\n\n    while (i--) {\n      boxes[i] = trak(tracks[i]);\n    }\n\n    return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n  };\n\n  mvex = function mvex(tracks) {\n    var i = tracks.length,\n        boxes = [];\n\n    while (i--) {\n      boxes[i] = trex(tracks[i]);\n    }\n\n    return box.apply(null, [types.mvex].concat(boxes));\n  };\n\n  mvhd = function mvhd(duration) {\n    var bytes = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // creation_time\n    0x00, 0x00, 0x00, 0x02, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n    (duration & 0xFF000000) >> 24, (duration & 0xFF0000) >> 16, (duration & 0xFF00) >> 8, duration & 0xFF, // duration\n    0x00, 0x01, 0x00, 0x00, // 1.0 rate\n    0x01, 0x00, // 1.0 volume\n    0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return box(types.mvhd, bytes);\n  };\n\n  sdtp = function sdtp(track) {\n    var samples = track.samples || [],\n        bytes = new Uint8Array(4 + samples.length),\n        flags,\n        i; // leave the full box header (4 bytes) all zero\n    // write the sample table\n\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n\n    return box(types.sdtp, bytes);\n  };\n\n  stbl = function stbl(track) {\n    return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));\n  };\n\n  (function () {\n    var videoSample, audioSample;\n\n    stsd = function stsd(track) {\n      return box(types.stsd, new Uint8Array([0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01]), track.type === 'video' ? videoSample(track) : audioSample(track));\n    };\n\n    videoSample = function videoSample(track) {\n      var sps = track.sps || [],\n          pps = track.pps || [],\n          sequenceParameterSets = [],\n          pictureParameterSets = [],\n          i,\n          avc1Box; // assemble the SPSs\n\n      for (i = 0; i < sps.length; i++) {\n        sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n        sequenceParameterSets.push(sps[i].byteLength & 0xFF); // sequenceParameterSetLength\n\n        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n      } // assemble the PPSs\n\n\n      for (i = 0; i < pps.length; i++) {\n        pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n        pictureParameterSets.push(pps[i].byteLength & 0xFF);\n        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n      }\n\n      avc1Box = [types.avc1, new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8, track.width & 0xff, // width\n      (track.height & 0xff00) >> 8, track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13, 0x76, 0x69, 0x64, 0x65, 0x6f, 0x6a, 0x73, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x2d, 0x68, 0x6c, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n      ]), box(types.avcC, new Uint8Array([0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n      ].concat([sps.length], // numOfSequenceParameterSets\n      sequenceParameterSets, // \"SPS\"\n      [pps.length], // numOfPictureParameterSets\n      pictureParameterSets // \"PPS\"\n      ))), box(types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n      0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n      0x00, 0x2d, 0xc6, 0xc0 // avgBitrate\n      ]))];\n\n      if (track.sarRatio) {\n        var hSpacing = track.sarRatio[0],\n            vSpacing = track.sarRatio[1];\n        avc1Box.push(box(types.pasp, new Uint8Array([(hSpacing & 0xFF000000) >> 24, (hSpacing & 0xFF0000) >> 16, (hSpacing & 0xFF00) >> 8, hSpacing & 0xFF, (vSpacing & 0xFF000000) >> 24, (vSpacing & 0xFF0000) >> 16, (vSpacing & 0xFF00) >> 8, vSpacing & 0xFF])));\n      }\n\n      return box.apply(null, avc1Box);\n    };\n\n    audioSample = function audioSample(track) {\n      return box(types.mp4a, new Uint8Array([// SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8, track.channelcount & 0xff, // channelcount\n      (track.samplesize & 0xff00) >> 8, track.samplesize & 0xff, // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      (track.samplerate & 0xff00) >> 8, track.samplerate & 0xff, 0x00, 0x00 // samplerate, 16.16\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n      ]), esds(track));\n    };\n  })();\n\n  tkhd = function tkhd(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24, (track.duration & 0xFF0000) >> 16, (track.duration & 0xFF00) >> 8, track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8, track.width & 0xFF, 0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8, track.height & 0xFF, 0x00, 0x00 // height\n    ]);\n    return box(types.tkhd, result);\n  };\n  /**\n   * Generate a track fragment (traf) box. A traf box collects metadata\n   * about tracks in a movie fragment (moof) box.\n   */\n\n\n  traf = function traf(track) {\n    var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n    trackFragmentHeader = box(types.tfhd, new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00 // default_sample_flags\n    ]));\n    upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);\n    lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);\n    trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    upperWordBaseMediaDecodeTime >>> 24 & 0xFF, upperWordBaseMediaDecodeTime >>> 16 & 0xFF, upperWordBaseMediaDecodeTime >>> 8 & 0xFF, upperWordBaseMediaDecodeTime & 0xFF, lowerWordBaseMediaDecodeTime >>> 24 & 0xFF, lowerWordBaseMediaDecodeTime >>> 16 & 0xFF, lowerWordBaseMediaDecodeTime >>> 8 & 0xFF, lowerWordBaseMediaDecodeTime & 0xFF])); // the data offset specifies the number of bytes from the start of\n    // the containing moof to the first payload byte of the associated\n    // mdat\n\n    dataOffset = 32 + // tfhd\n    20 + // tfdt\n    8 + // traf header\n    16 + // mfhd\n    8 + // moof header\n    8; // mdat header\n    // audio tracks require less metadata\n\n    if (track.type === 'audio') {\n      trackFragmentRun = trun$1(track, dataOffset);\n      return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);\n    } // video tracks should contain an independent and disposable samples\n    // box (sdtp)\n    // generate one and adjust offsets to match\n\n\n    sampleDependencyTable = sdtp(track);\n    trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);\n    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);\n  };\n  /**\n   * Generate a track box.\n   * @param track {object} a track definition\n   * @return {Uint8Array} the track box\n   */\n\n\n  trak = function trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return box(types.trak, tkhd(track), mdia(track));\n  };\n\n  trex = function trex(track) {\n    var result = new Uint8Array([0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24, (track.id & 0xFF0000) >> 16, (track.id & 0xFF00) >> 8, track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]); // the last two bytes of default_sample_flags is the sample\n    // degradation priority, a hint about the importance of this sample\n    // relative to others. Lower the degradation priority for all sample\n    // types other than video.\n\n    if (track.type !== 'video') {\n      result[result.length - 1] = 0x00;\n    }\n\n    return box(types.trex, result);\n  };\n\n  (function () {\n    var audioTrun, videoTrun, trunHeader; // This method assumes all samples are uniform. That is, if a\n    // duration is present for the first sample, it will be present for\n    // all subsequent samples.\n    // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n\n    trunHeader = function trunHeader(samples, offset) {\n      var durationPresent = 0,\n          sizePresent = 0,\n          flagsPresent = 0,\n          compositionTimeOffset = 0; // trun flag constants\n\n      if (samples.length) {\n        if (samples[0].duration !== undefined) {\n          durationPresent = 0x1;\n        }\n\n        if (samples[0].size !== undefined) {\n          sizePresent = 0x2;\n        }\n\n        if (samples[0].flags !== undefined) {\n          flagsPresent = 0x4;\n        }\n\n        if (samples[0].compositionTimeOffset !== undefined) {\n          compositionTimeOffset = 0x8;\n        }\n      }\n\n      return [0x00, // version 0\n      0x00, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 0x01, // flags\n      (samples.length & 0xFF000000) >>> 24, (samples.length & 0xFF0000) >>> 16, (samples.length & 0xFF00) >>> 8, samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24, (offset & 0xFF0000) >>> 16, (offset & 0xFF00) >>> 8, offset & 0xFF // data_offset\n      ];\n    };\n\n    videoTrun = function videoTrun(track, offset) {\n      var bytesOffest, bytes, header, samples, sample, i;\n      samples = track.samples || [];\n      offset += 8 + 12 + 16 * samples.length;\n      header = trunHeader(samples, offset);\n      bytes = new Uint8Array(header.length + samples.length * 16);\n      bytes.set(header);\n      bytesOffest = header.length;\n\n      for (i = 0; i < samples.length; i++) {\n        sample = samples[i];\n        bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n        bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n\n        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;\n        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;\n        bytes[bytesOffest++] = sample.flags.degradationPriority & 0xF0 << 8;\n        bytes[bytesOffest++] = sample.flags.degradationPriority & 0x0F; // sample_flags\n\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.compositionTimeOffset & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.compositionTimeOffset & 0xFF; // sample_composition_time_offset\n      }\n\n      return box(types.trun, bytes);\n    };\n\n    audioTrun = function audioTrun(track, offset) {\n      var bytes, bytesOffest, header, samples, sample, i;\n      samples = track.samples || [];\n      offset += 8 + 12 + 8 * samples.length;\n      header = trunHeader(samples, offset);\n      bytes = new Uint8Array(header.length + samples.length * 8);\n      bytes.set(header);\n      bytesOffest = header.length;\n\n      for (i = 0; i < samples.length; i++) {\n        sample = samples[i];\n        bytes[bytesOffest++] = (sample.duration & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.duration & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.duration & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.duration & 0xFF; // sample_duration\n\n        bytes[bytesOffest++] = (sample.size & 0xFF000000) >>> 24;\n        bytes[bytesOffest++] = (sample.size & 0xFF0000) >>> 16;\n        bytes[bytesOffest++] = (sample.size & 0xFF00) >>> 8;\n        bytes[bytesOffest++] = sample.size & 0xFF; // sample_size\n      }\n\n      return box(types.trun, bytes);\n    };\n\n    trun$1 = function trun(track, offset) {\n      if (track.type === 'audio') {\n        return audioTrun(track, offset);\n      }\n\n      return videoTrun(track, offset);\n    };\n  })();\n\n  var mp4Generator = {\n    ftyp: ftyp,\n    mdat: mdat,\n    moof: moof,\n    moov: moov,\n    initSegment: function initSegment(tracks) {\n      var fileType = ftyp(),\n          movie = moov(tracks),\n          result;\n      result = new Uint8Array(fileType.byteLength + movie.byteLength);\n      result.set(fileType);\n      result.set(movie, fileType.byteLength);\n      return result;\n    }\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  var toUnsigned$3 = function toUnsigned(value) {\n    return value >>> 0;\n  };\n\n  var toHexString$1 = function toHexString(value) {\n    return ('00' + value.toString(16)).slice(-2);\n  };\n\n  var bin = {\n    toUnsigned: toUnsigned$3,\n    toHexString: toHexString$1\n  };\n\n  var parseType$2 = function parseType(buffer) {\n    var result = '';\n    result += String.fromCharCode(buffer[0]);\n    result += String.fromCharCode(buffer[1]);\n    result += String.fromCharCode(buffer[2]);\n    result += String.fromCharCode(buffer[3]);\n    return result;\n  };\n\n  var parseType_1 = parseType$2;\n\n  var toUnsigned$2 = bin.toUnsigned;\n\n  var findBox = function findBox(data, path) {\n    var results = [],\n        i,\n        size,\n        type,\n        end,\n        subresults;\n\n    if (!path.length) {\n      // short-circuit the search for empty paths\n      return null;\n    }\n\n    for (i = 0; i < data.byteLength;) {\n      size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);\n      type = parseType_1(data.subarray(i + 4, i + 8));\n      end = size > 1 ? i + size : data.byteLength;\n\n      if (type === path[0]) {\n        if (path.length === 1) {\n          // this is the end of the path and we've found the box we were\n          // looking for\n          results.push(data.subarray(i + 8, end));\n        } else {\n          // recursively search for the next box along the path\n          subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n\n          if (subresults.length) {\n            results = results.concat(subresults);\n          }\n        }\n      }\n\n      i = end;\n    } // we've finished searching all of data\n\n\n    return results;\n  };\n\n  var findBox_1 = findBox;\n\n  var tfhd = function tfhd(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      trackId: view.getUint32(4)\n    },\n        baseDataOffsetPresent = result.flags[2] & 0x01,\n        sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n        defaultSampleDurationPresent = result.flags[2] & 0x08,\n        defaultSampleSizePresent = result.flags[2] & 0x10,\n        defaultSampleFlagsPresent = result.flags[2] & 0x20,\n        durationIsEmpty = result.flags[0] & 0x010000,\n        defaultBaseIsMoof = result.flags[0] & 0x020000,\n        i;\n    i = 8;\n\n    if (baseDataOffsetPresent) {\n      i += 4; // truncate top 4 bytes\n      // FIXME: should we read the full 64 bits?\n\n      result.baseDataOffset = view.getUint32(12);\n      i += 4;\n    }\n\n    if (sampleDescriptionIndexPresent) {\n      result.sampleDescriptionIndex = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleDurationPresent) {\n      result.defaultSampleDuration = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleSizePresent) {\n      result.defaultSampleSize = view.getUint32(i);\n      i += 4;\n    }\n\n    if (defaultSampleFlagsPresent) {\n      result.defaultSampleFlags = view.getUint32(i);\n    }\n\n    if (durationIsEmpty) {\n      result.durationIsEmpty = true;\n    }\n\n    if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n      result.baseDataOffsetIsMoof = true;\n    }\n\n    return result;\n  };\n\n  var parseTfhd = tfhd;\n\n  var parseSampleFlags = function parseSampleFlags(flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: flags[2] << 8 | flags[3]\n    };\n  };\n\n  var parseSampleFlags_1 = parseSampleFlags;\n\n  var trun = function trun(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      samples: []\n    },\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        // Flag interpretation\n    dataOffsetPresent = result.flags[2] & 0x01,\n        // compare with 2nd byte of 0x1\n    firstSampleFlagsPresent = result.flags[2] & 0x04,\n        // compare with 2nd byte of 0x4\n    sampleDurationPresent = result.flags[1] & 0x01,\n        // compare with 2nd byte of 0x100\n    sampleSizePresent = result.flags[1] & 0x02,\n        // compare with 2nd byte of 0x200\n    sampleFlagsPresent = result.flags[1] & 0x04,\n        // compare with 2nd byte of 0x400\n    sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08,\n        // compare with 2nd byte of 0x800\n    sampleCount = view.getUint32(4),\n        offset = 8,\n        sample;\n\n    if (dataOffsetPresent) {\n      // 32 bit signed integer\n      result.dataOffset = view.getInt32(offset);\n      offset += 4;\n    } // Overrides the flags for the first sample only. The order of\n    // optional values will be: duration, size, compositionTimeOffset\n\n\n    if (firstSampleFlagsPresent && sampleCount) {\n      sample = {\n        flags: parseSampleFlags_1(data.subarray(offset, offset + 4))\n      };\n      offset += 4;\n\n      if (sampleDurationPresent) {\n        sample.duration = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleSizePresent) {\n        sample.size = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleCompositionTimeOffsetPresent) {\n        if (result.version === 1) {\n          sample.compositionTimeOffset = view.getInt32(offset);\n        } else {\n          sample.compositionTimeOffset = view.getUint32(offset);\n        }\n\n        offset += 4;\n      }\n\n      result.samples.push(sample);\n      sampleCount--;\n    }\n\n    while (sampleCount--) {\n      sample = {};\n\n      if (sampleDurationPresent) {\n        sample.duration = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleSizePresent) {\n        sample.size = view.getUint32(offset);\n        offset += 4;\n      }\n\n      if (sampleFlagsPresent) {\n        sample.flags = parseSampleFlags_1(data.subarray(offset, offset + 4));\n        offset += 4;\n      }\n\n      if (sampleCompositionTimeOffsetPresent) {\n        if (result.version === 1) {\n          sample.compositionTimeOffset = view.getInt32(offset);\n        } else {\n          sample.compositionTimeOffset = view.getUint32(offset);\n        }\n\n        offset += 4;\n      }\n\n      result.samples.push(sample);\n    }\n\n    return result;\n  };\n\n  var parseTrun = trun;\n\n  var toUnsigned$1 = bin.toUnsigned;\n  var getUint64$3 = numbers.getUint64;\n\n  var tfdt = function tfdt(data) {\n    var result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4))\n    };\n\n    if (result.version === 1) {\n      result.baseMediaDecodeTime = getUint64$3(data.subarray(4));\n    } else {\n      result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);\n    }\n\n    return result;\n  };\n\n  var parseTfdt = tfdt;\n\n  var toUnsigned = bin.toUnsigned;\n  var toHexString = bin.toHexString;\n  var getUint64$2 = numbers.getUint64;\n  var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader;\n  /**\n   * Parses an MP4 initialization segment and extracts the timescale\n   * values for any declared tracks. Timescale values indicate the\n   * number of clock ticks per second to assume for time-based values\n   * elsewhere in the MP4.\n   *\n   * To determine the start time of an MP4, you need two pieces of\n   * information: the timescale unit and the earliest base media decode\n   * time. Multiple timescales can be specified within an MP4 but the\n   * base media decode time is always expressed in the timescale from\n   * the media header box for the track:\n   * ```\n   * moov > trak > mdia > mdhd.timescale\n   * ```\n   * @param init {Uint8Array} the bytes of the init segment\n   * @return {object} a hash of track ids to timescale values or null if\n   * the init segment is malformed.\n   */\n\n  timescale = function timescale(init) {\n    var result = {},\n        traks = findBox_1(init, ['moov', 'trak']); // mdhd timescale\n\n    return traks.reduce(function (result, trak) {\n      var tkhd, version, index, id, mdhd;\n      tkhd = findBox_1(trak, ['tkhd'])[0];\n\n      if (!tkhd) {\n        return null;\n      }\n\n      version = tkhd[0];\n      index = version === 0 ? 12 : 20;\n      id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);\n      mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];\n\n      if (!mdhd) {\n        return null;\n      }\n\n      version = mdhd[0];\n      index = version === 0 ? 12 : 20;\n      result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n      return result;\n    }, result);\n  };\n  /**\n   * Determine the base media decode start time, in seconds, for an MP4\n   * fragment. If multiple fragments are specified, the earliest time is\n   * returned.\n   *\n   * The base media decode time can be parsed from track fragment\n   * metadata:\n   * ```\n   * moof > traf > tfdt.baseMediaDecodeTime\n   * ```\n   * It requires the timescale value from the mdhd to interpret.\n   *\n   * @param timescale {object} a hash of track ids to timescale values.\n   * @return {number} the earliest base media decode start time for the\n   * fragment, in seconds\n   */\n\n\n  startTime = function startTime(timescale, fragment) {\n    var trafs; // we need info from two childrend of each track fragment box\n\n    trafs = findBox_1(fragment, ['moof', 'traf']); // determine the start times for each track\n\n    var lowestTime = trafs.reduce(function (acc, traf) {\n      var tfhd = findBox_1(traf, ['tfhd'])[0]; // get the track id from the tfhd\n\n      var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]); // assume a 90kHz clock if no timescale was specified\n\n      var scale = timescale[id] || 90e3; // get the base media decode time from the tfdt\n\n      var tfdt = findBox_1(traf, ['tfdt'])[0];\n      var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);\n      var baseTime; // version 1 is 64 bit\n\n      if (tfdt[0] === 1) {\n        baseTime = getUint64$2(tfdt.subarray(4, 12));\n      } else {\n        baseTime = dv.getUint32(4);\n      } // convert base time to seconds if it is a valid number.\n\n\n      var seconds;\n\n      if (typeof baseTime === 'bigint') {\n        seconds = baseTime / window__default['default'].BigInt(scale);\n      } else if (typeof baseTime === 'number' && !isNaN(baseTime)) {\n        seconds = baseTime / scale;\n      }\n\n      if (seconds < Number.MAX_SAFE_INTEGER) {\n        seconds = Number(seconds);\n      }\n\n      if (seconds < acc) {\n        acc = seconds;\n      }\n\n      return acc;\n    }, Infinity);\n    return typeof lowestTime === 'bigint' || isFinite(lowestTime) ? lowestTime : 0;\n  };\n  /**\n   * Determine the composition start, in seconds, for an MP4\n   * fragment.\n   *\n   * The composition start time of a fragment can be calculated using the base\n   * media decode time, composition time offset, and timescale, as follows:\n   *\n   * compositionStartTime = (baseMediaDecodeTime + compositionTimeOffset) / timescale\n   *\n   * All of the aforementioned information is contained within a media fragment's\n   * `traf` box, except for timescale info, which comes from the initialization\n   * segment, so a track id (also contained within a `traf`) is also necessary to\n   * associate it with a timescale\n   *\n   *\n   * @param timescales {object} - a hash of track ids to timescale values.\n   * @param fragment {Unit8Array} - the bytes of a media segment\n   * @return {number} the composition start time for the fragment, in seconds\n   **/\n\n\n  compositionStartTime = function compositionStartTime(timescales, fragment) {\n    var trafBoxes = findBox_1(fragment, ['moof', 'traf']);\n    var baseMediaDecodeTime = 0;\n    var compositionTimeOffset = 0;\n    var trackId;\n\n    if (trafBoxes && trafBoxes.length) {\n      // The spec states that track run samples contained within a `traf` box are contiguous, but\n      // it does not explicitly state whether the `traf` boxes themselves are contiguous.\n      // We will assume that they are, so we only need the first to calculate start time.\n      var tfhd = findBox_1(trafBoxes[0], ['tfhd'])[0];\n      var trun = findBox_1(trafBoxes[0], ['trun'])[0];\n      var tfdt = findBox_1(trafBoxes[0], ['tfdt'])[0];\n\n      if (tfhd) {\n        var parsedTfhd = parseTfhd(tfhd);\n        trackId = parsedTfhd.trackId;\n      }\n\n      if (tfdt) {\n        var parsedTfdt = parseTfdt(tfdt);\n        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;\n      }\n\n      if (trun) {\n        var parsedTrun = parseTrun(trun);\n\n        if (parsedTrun.samples && parsedTrun.samples.length) {\n          compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;\n        }\n      }\n    } // Get timescale for this specific track. Assume a 90kHz clock if no timescale was\n    // specified.\n\n\n    var timescale = timescales[trackId] || 90e3; // return the composition start time, in seconds\n\n    if (typeof baseMediaDecodeTime === 'bigint') {\n      compositionTimeOffset = window__default['default'].BigInt(compositionTimeOffset);\n      timescale = window__default['default'].BigInt(timescale);\n    }\n\n    var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;\n\n    if (typeof result === 'bigint' && result < Number.MAX_SAFE_INTEGER) {\n      result = Number(result);\n    }\n\n    return result;\n  };\n  /**\n    * Find the trackIds of the video tracks in this source.\n    * Found by parsing the Handler Reference and Track Header Boxes:\n    *   moov > trak > mdia > hdlr\n    *   moov > trak > tkhd\n    *\n    * @param {Uint8Array} init - The bytes of the init segment for this source\n    * @return {Number[]} A list of trackIds\n    *\n    * @see ISO-BMFF-12/2015, Section 8.4.3\n   **/\n\n\n  getVideoTrackIds = function getVideoTrackIds(init) {\n    var traks = findBox_1(init, ['moov', 'trak']);\n    var videoTrackIds = [];\n    traks.forEach(function (trak) {\n      var hdlrs = findBox_1(trak, ['mdia', 'hdlr']);\n      var tkhds = findBox_1(trak, ['tkhd']);\n      hdlrs.forEach(function (hdlr, index) {\n        var handlerType = parseType_1(hdlr.subarray(8, 12));\n        var tkhd = tkhds[index];\n        var view;\n        var version;\n        var trackId;\n\n        if (handlerType === 'vide') {\n          view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n          version = view.getUint8(0);\n          trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);\n          videoTrackIds.push(trackId);\n        }\n      });\n    });\n    return videoTrackIds;\n  };\n\n  getTimescaleFromMediaHeader = function getTimescaleFromMediaHeader(mdhd) {\n    // mdhd is a FullBox, meaning it will have its own version as the first byte\n    var version = mdhd[0];\n    var index = version === 0 ? 12 : 20;\n    return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);\n  };\n  /**\n   * Get all the video, audio, and hint tracks from a non fragmented\n   * mp4 segment\n   */\n\n\n  getTracks = function getTracks(init) {\n    var traks = findBox_1(init, ['moov', 'trak']);\n    var tracks = [];\n    traks.forEach(function (trak) {\n      var track = {};\n      var tkhd = findBox_1(trak, ['tkhd'])[0];\n      var view, tkhdVersion; // id\n\n      if (tkhd) {\n        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n        tkhdVersion = view.getUint8(0);\n        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);\n      }\n\n      var hdlr = findBox_1(trak, ['mdia', 'hdlr'])[0]; // type\n\n      if (hdlr) {\n        var type = parseType_1(hdlr.subarray(8, 12));\n\n        if (type === 'vide') {\n          track.type = 'video';\n        } else if (type === 'soun') {\n          track.type = 'audio';\n        } else {\n          track.type = type;\n        }\n      } // codec\n\n\n      var stsd = findBox_1(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      if (stsd) {\n        var sampleDescriptions = stsd.subarray(8); // gives the codec type string\n\n        track.codec = parseType_1(sampleDescriptions.subarray(4, 8));\n        var codecBox = findBox_1(sampleDescriptions, [track.codec])[0];\n        var codecConfig, codecConfigType;\n\n        if (codecBox) {\n          // https://tools.ietf.org/html/rfc6381#section-3.3\n          if (/^[asm]vc[1-9]$/i.test(track.codec)) {\n            // we don't need anything but the \"config\" parameter of the\n            // avc1 codecBox\n            codecConfig = codecBox.subarray(78);\n            codecConfigType = parseType_1(codecConfig.subarray(4, 8));\n\n            if (codecConfigType === 'avcC' && codecConfig.length > 11) {\n              track.codec += '.'; // left padded with zeroes for single digit hex\n              // profile idc\n\n              track.codec += toHexString(codecConfig[9]); // the byte containing the constraint_set flags\n\n              track.codec += toHexString(codecConfig[10]); // level idc\n\n              track.codec += toHexString(codecConfig[11]);\n            } else {\n              // TODO: show a warning that we couldn't parse the codec\n              // and are using the default\n              track.codec = 'avc1.4d400d';\n            }\n          } else if (/^mp4[a,v]$/i.test(track.codec)) {\n            // we do not need anything but the streamDescriptor of the mp4a codecBox\n            codecConfig = codecBox.subarray(28);\n            codecConfigType = parseType_1(codecConfig.subarray(4, 8));\n\n            if (codecConfigType === 'esds' && codecConfig.length > 20 && codecConfig[19] !== 0) {\n              track.codec += '.' + toHexString(codecConfig[19]); // this value is only a single digit\n\n              track.codec += '.' + toHexString(codecConfig[20] >>> 2 & 0x3f).replace(/^0/, '');\n            } else {\n              // TODO: show a warning that we couldn't parse the codec\n              // and are using the default\n              track.codec = 'mp4a.40.2';\n            }\n          } else {\n            // flac, opus, etc\n            track.codec = track.codec.toLowerCase();\n          }\n        }\n      }\n\n      var mdhd = findBox_1(trak, ['mdia', 'mdhd'])[0];\n\n      if (mdhd) {\n        track.timescale = getTimescaleFromMediaHeader(mdhd);\n      }\n\n      tracks.push(track);\n    });\n    return tracks;\n  };\n\n  var probe$2 = {\n    // export mp4 inspector's findBox and parseType for backwards compatibility\n    findBox: findBox_1,\n    parseType: parseType_1,\n    timescale: timescale,\n    startTime: startTime,\n    compositionStartTime: compositionStartTime,\n    videoTrackIds: getVideoTrackIds,\n    tracks: getTracks,\n    getTimescaleFromMediaHeader: getTimescaleFromMediaHeader\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  // Convert an array of nal units into an array of frames with each frame being\n  // composed of the nal units that make up that frame\n  // Also keep track of cummulative data about the frame from the nal units such\n  // as the frame duration, starting pts, etc.\n  var groupNalsIntoFrames = function groupNalsIntoFrames(nalUnits) {\n    var i,\n        currentNal,\n        currentFrame = [],\n        frames = []; // TODO added for LHLS, make sure this is OK\n\n    frames.byteLength = 0;\n    frames.nalCount = 0;\n    frames.duration = 0;\n    currentFrame.byteLength = 0;\n\n    for (i = 0; i < nalUnits.length; i++) {\n      currentNal = nalUnits[i]; // Split on 'aud'-type nal units\n\n      if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        // Since the very first nal unit is expected to be an AUD\n        // only push to the frames array when currentFrame is not empty\n        if (currentFrame.length) {\n          currentFrame.duration = currentNal.dts - currentFrame.dts; // TODO added for LHLS, make sure this is OK\n\n          frames.byteLength += currentFrame.byteLength;\n          frames.nalCount += currentFrame.length;\n          frames.duration += currentFrame.duration;\n          frames.push(currentFrame);\n        }\n\n        currentFrame = [currentNal];\n        currentFrame.byteLength = currentNal.data.byteLength;\n        currentFrame.pts = currentNal.pts;\n        currentFrame.dts = currentNal.dts;\n      } else {\n        // Specifically flag key frames for ease of use later\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          currentFrame.keyFrame = true;\n        }\n\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        currentFrame.byteLength += currentNal.data.byteLength;\n        currentFrame.push(currentNal);\n      }\n    } // For the last frame, use the duration of the previous frame if we\n    // have nothing better to go on\n\n\n    if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) {\n      currentFrame.duration = frames[frames.length - 1].duration;\n    } // Push the final frame\n    // TODO added for LHLS, make sure this is OK\n\n\n    frames.byteLength += currentFrame.byteLength;\n    frames.nalCount += currentFrame.length;\n    frames.duration += currentFrame.duration;\n    frames.push(currentFrame);\n    return frames;\n  }; // Convert an array of frames into an array of Gop with each Gop being composed\n  // of the frames that make up that Gop\n  // Also keep track of cummulative data about the Gop from the frames such as the\n  // Gop duration, starting pts, etc.\n\n\n  var groupFramesIntoGops = function groupFramesIntoGops(frames) {\n    var i,\n        currentFrame,\n        currentGop = [],\n        gops = []; // We must pre-set some of the values on the Gop since we\n    // keep running totals of these values\n\n    currentGop.byteLength = 0;\n    currentGop.nalCount = 0;\n    currentGop.duration = 0;\n    currentGop.pts = frames[0].pts;\n    currentGop.dts = frames[0].dts; // store some metadata about all the Gops\n\n    gops.byteLength = 0;\n    gops.nalCount = 0;\n    gops.duration = 0;\n    gops.pts = frames[0].pts;\n    gops.dts = frames[0].dts;\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n\n      if (currentFrame.keyFrame) {\n        // Since the very first frame is expected to be an keyframe\n        // only push to the gops array when currentGop is not empty\n        if (currentGop.length) {\n          gops.push(currentGop);\n          gops.byteLength += currentGop.byteLength;\n          gops.nalCount += currentGop.nalCount;\n          gops.duration += currentGop.duration;\n        }\n\n        currentGop = [currentFrame];\n        currentGop.nalCount = currentFrame.length;\n        currentGop.byteLength = currentFrame.byteLength;\n        currentGop.pts = currentFrame.pts;\n        currentGop.dts = currentFrame.dts;\n        currentGop.duration = currentFrame.duration;\n      } else {\n        currentGop.duration += currentFrame.duration;\n        currentGop.nalCount += currentFrame.length;\n        currentGop.byteLength += currentFrame.byteLength;\n        currentGop.push(currentFrame);\n      }\n    }\n\n    if (gops.length && currentGop.duration <= 0) {\n      currentGop.duration = gops[gops.length - 1].duration;\n    }\n\n    gops.byteLength += currentGop.byteLength;\n    gops.nalCount += currentGop.nalCount;\n    gops.duration += currentGop.duration; // push the final Gop\n\n    gops.push(currentGop);\n    return gops;\n  };\n  /*\n   * Search for the first keyframe in the GOPs and throw away all frames\n   * until that keyframe. Then extend the duration of the pulled keyframe\n   * and pull the PTS and DTS of the keyframe so that it covers the time\n   * range of the frames that were disposed.\n   *\n   * @param {Array} gops video GOPs\n   * @returns {Array} modified video GOPs\n   */\n\n\n  var extendFirstKeyFrame = function extendFirstKeyFrame(gops) {\n    var currentGop;\n\n    if (!gops[0][0].keyFrame && gops.length > 1) {\n      // Remove the first GOP\n      currentGop = gops.shift();\n      gops.byteLength -= currentGop.byteLength;\n      gops.nalCount -= currentGop.nalCount; // Extend the first frame of what is now the\n      // first gop to cover the time period of the\n      // frames we just removed\n\n      gops[0][0].dts = currentGop.dts;\n      gops[0][0].pts = currentGop.pts;\n      gops[0][0].duration += currentGop.duration;\n    }\n\n    return gops;\n  };\n  /**\n   * Default sample object\n   * see ISO/IEC 14496-12:2012, section 8.6.4.3\n   */\n\n\n  var createDefaultSample = function createDefaultSample() {\n    return {\n      size: 0,\n      flags: {\n        isLeading: 0,\n        dependsOn: 1,\n        isDependedOn: 0,\n        hasRedundancy: 0,\n        degradationPriority: 0,\n        isNonSyncSample: 1\n      }\n    };\n  };\n  /*\n   * Collates information from a video frame into an object for eventual\n   * entry into an MP4 sample table.\n   *\n   * @param {Object} frame the video frame\n   * @param {Number} dataOffset the byte offset to position the sample\n   * @return {Object} object containing sample table info for a frame\n   */\n\n\n  var sampleForFrame = function sampleForFrame(frame, dataOffset) {\n    var sample = createDefaultSample();\n    sample.dataOffset = dataOffset;\n    sample.compositionTimeOffset = frame.pts - frame.dts;\n    sample.duration = frame.duration;\n    sample.size = 4 * frame.length; // Space for nal unit size\n\n    sample.size += frame.byteLength;\n\n    if (frame.keyFrame) {\n      sample.flags.dependsOn = 2;\n      sample.flags.isNonSyncSample = 0;\n    }\n\n    return sample;\n  }; // generate the track's sample table from an array of gops\n\n\n  var generateSampleTable$1 = function generateSampleTable(gops, baseDataOffset) {\n    var h,\n        i,\n        sample,\n        currentGop,\n        currentFrame,\n        dataOffset = baseDataOffset || 0,\n        samples = [];\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h];\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i];\n        sample = sampleForFrame(currentFrame, dataOffset);\n        dataOffset += sample.size;\n        samples.push(sample);\n      }\n    }\n\n    return samples;\n  }; // generate the track's raw mdat data from an array of gops\n\n\n  var concatenateNalData = function concatenateNalData(gops) {\n    var h,\n        i,\n        j,\n        currentGop,\n        currentFrame,\n        currentNal,\n        dataOffset = 0,\n        nalsByteLength = gops.byteLength,\n        numberOfNals = gops.nalCount,\n        totalByteLength = nalsByteLength + 4 * numberOfNals,\n        data = new Uint8Array(totalByteLength),\n        view = new DataView(data.buffer); // For each Gop..\n\n    for (h = 0; h < gops.length; h++) {\n      currentGop = gops[h]; // For each Frame..\n\n      for (i = 0; i < currentGop.length; i++) {\n        currentFrame = currentGop[i]; // For each NAL..\n\n        for (j = 0; j < currentFrame.length; j++) {\n          currentNal = currentFrame[j];\n          view.setUint32(dataOffset, currentNal.data.byteLength);\n          dataOffset += 4;\n          data.set(currentNal.data, dataOffset);\n          dataOffset += currentNal.data.byteLength;\n        }\n      }\n    }\n\n    return data;\n  }; // generate the track's sample table from a frame\n\n\n  var generateSampleTableForFrame = function generateSampleTableForFrame(frame, baseDataOffset) {\n    var sample,\n        dataOffset = baseDataOffset || 0,\n        samples = [];\n    sample = sampleForFrame(frame, dataOffset);\n    samples.push(sample);\n    return samples;\n  }; // generate the track's raw mdat data from a frame\n\n\n  var concatenateNalDataForFrame = function concatenateNalDataForFrame(frame) {\n    var i,\n        currentNal,\n        dataOffset = 0,\n        nalsByteLength = frame.byteLength,\n        numberOfNals = frame.length,\n        totalByteLength = nalsByteLength + 4 * numberOfNals,\n        data = new Uint8Array(totalByteLength),\n        view = new DataView(data.buffer); // For each NAL..\n\n    for (i = 0; i < frame.length; i++) {\n      currentNal = frame[i];\n      view.setUint32(dataOffset, currentNal.data.byteLength);\n      dataOffset += 4;\n      data.set(currentNal.data, dataOffset);\n      dataOffset += currentNal.data.byteLength;\n    }\n\n    return data;\n  };\n\n  var frameUtils = {\n    groupNalsIntoFrames: groupNalsIntoFrames,\n    groupFramesIntoGops: groupFramesIntoGops,\n    extendFirstKeyFrame: extendFirstKeyFrame,\n    generateSampleTable: generateSampleTable$1,\n    concatenateNalData: concatenateNalData,\n    generateSampleTableForFrame: generateSampleTableForFrame,\n    concatenateNalDataForFrame: concatenateNalDataForFrame\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n  var highPrefix = [33, 16, 5, 32, 164, 27];\n  var lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\n\n  var zeroFill = function zeroFill(count) {\n    var a = [];\n\n    while (count--) {\n      a.push(0);\n    }\n\n    return a;\n  };\n\n  var makeTable = function makeTable(metaTable) {\n    return Object.keys(metaTable).reduce(function (obj, key) {\n      obj[key] = new Uint8Array(metaTable[key].reduce(function (arr, part) {\n        return arr.concat(part);\n      }, []));\n      return obj;\n    }, {});\n  };\n\n  var silence;\n\n  var silence_1 = function silence_1() {\n    if (!silence) {\n      // Frames-of-silence to use for filling in missing AAC frames\n      var coneOfSilence = {\n        96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n        88200: [highPrefix, [231], zeroFill(170), [56]],\n        64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n        48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n        44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n        32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n        24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n        16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n        12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n        11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n        8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n      };\n      silence = makeTable(coneOfSilence);\n    }\n\n    return silence;\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  /**\n   * Sum the `byteLength` properties of the data in each AAC frame\n   */\n\n  var sumFrameByteLengths = function sumFrameByteLengths(array) {\n    var i,\n        currentObj,\n        sum = 0; // sum the byteLength's all each nal unit in the frame\n\n    for (i = 0; i < array.length; i++) {\n      currentObj = array[i];\n      sum += currentObj.data.byteLength;\n    }\n\n    return sum;\n  }; // Possibly pad (prefix) the audio track with silence if appending this track\n  // would lead to the introduction of a gap in the audio buffer\n\n\n  var prefixWithSilence = function prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {\n    var baseMediaDecodeTimeTs,\n        frameDuration = 0,\n        audioGapDuration = 0,\n        audioFillFrameCount = 0,\n        audioFillDuration = 0,\n        silentFrame,\n        i,\n        firstFrame;\n\n    if (!frames.length) {\n      return;\n    }\n\n    baseMediaDecodeTimeTs = clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate); // determine frame clock duration based on sample rate, round up to avoid overfills\n\n    frameDuration = Math.ceil(clock.ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n    if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n      // insert the shortest possible amount (audio gap or audio to video gap)\n      audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime); // number of full frames in the audio gap\n\n      audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n      audioFillDuration = audioFillFrameCount * frameDuration;\n    } // don't attempt to fill gaps smaller than a single frame or larger\n    // than a half second\n\n\n    if (audioFillFrameCount < 1 || audioFillDuration > clock.ONE_SECOND_IN_TS / 2) {\n      return;\n    }\n\n    silentFrame = silence_1()[track.samplerate];\n\n    if (!silentFrame) {\n      // we don't have a silent frame pregenerated for the sample rate, so use a frame\n      // from the content instead\n      silentFrame = frames[0].data;\n    }\n\n    for (i = 0; i < audioFillFrameCount; i++) {\n      firstFrame = frames[0];\n      frames.splice(0, 0, {\n        data: silentFrame,\n        dts: firstFrame.dts - frameDuration,\n        pts: firstFrame.pts - frameDuration\n      });\n    }\n\n    track.baseMediaDecodeTime -= Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n    return audioFillDuration;\n  }; // If the audio segment extends before the earliest allowed dts\n  // value, remove AAC frames until starts at or after the earliest\n  // allowed DTS so that we don't end up with a negative baseMedia-\n  // DecodeTime for the audio track\n\n\n  var trimAdtsFramesByEarliestDts = function trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts) {\n    if (track.minSegmentDts >= earliestAllowedDts) {\n      return adtsFrames;\n    } // We will need to recalculate the earliest segment Dts\n\n\n    track.minSegmentDts = Infinity;\n    return adtsFrames.filter(function (currentFrame) {\n      // If this is an allowed frame, keep it and record it's Dts\n      if (currentFrame.dts >= earliestAllowedDts) {\n        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n        track.minSegmentPts = track.minSegmentDts;\n        return true;\n      } // Otherwise, discard it\n\n\n      return false;\n    });\n  }; // generate the track's raw mdat data from an array of frames\n\n\n  var generateSampleTable = function generateSampleTable(frames) {\n    var i,\n        currentFrame,\n        samples = [];\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      samples.push({\n        size: currentFrame.data.byteLength,\n        duration: 1024 // For AAC audio, all samples contain 1024 samples\n\n      });\n    }\n\n    return samples;\n  }; // generate the track's sample table from an array of frames\n\n\n  var concatenateFrameData = function concatenateFrameData(frames) {\n    var i,\n        currentFrame,\n        dataOffset = 0,\n        data = new Uint8Array(sumFrameByteLengths(frames));\n\n    for (i = 0; i < frames.length; i++) {\n      currentFrame = frames[i];\n      data.set(currentFrame.data, dataOffset);\n      dataOffset += currentFrame.data.byteLength;\n    }\n\n    return data;\n  };\n\n  var audioFrameUtils = {\n    prefixWithSilence: prefixWithSilence,\n    trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n    generateSampleTable: generateSampleTable,\n    concatenateFrameData: concatenateFrameData\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var ONE_SECOND_IN_TS$3 = clock.ONE_SECOND_IN_TS;\n  /**\n   * Store information about the start and end of the track and the\n   * duration for each frame/sample we process in order to calculate\n   * the baseMediaDecodeTime\n   */\n\n  var collectDtsInfo = function collectDtsInfo(track, data) {\n    if (typeof data.pts === 'number') {\n      if (track.timelineStartInfo.pts === undefined) {\n        track.timelineStartInfo.pts = data.pts;\n      }\n\n      if (track.minSegmentPts === undefined) {\n        track.minSegmentPts = data.pts;\n      } else {\n        track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n      }\n\n      if (track.maxSegmentPts === undefined) {\n        track.maxSegmentPts = data.pts;\n      } else {\n        track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n      }\n    }\n\n    if (typeof data.dts === 'number') {\n      if (track.timelineStartInfo.dts === undefined) {\n        track.timelineStartInfo.dts = data.dts;\n      }\n\n      if (track.minSegmentDts === undefined) {\n        track.minSegmentDts = data.dts;\n      } else {\n        track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n      }\n\n      if (track.maxSegmentDts === undefined) {\n        track.maxSegmentDts = data.dts;\n      } else {\n        track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n      }\n    }\n  };\n  /**\n   * Clear values used to calculate the baseMediaDecodeTime between\n   * tracks\n   */\n\n\n  var clearDtsInfo = function clearDtsInfo(track) {\n    delete track.minSegmentDts;\n    delete track.maxSegmentDts;\n    delete track.minSegmentPts;\n    delete track.maxSegmentPts;\n  };\n  /**\n   * Calculate the track's baseMediaDecodeTime based on the earliest\n   * DTS the transmuxer has ever seen and the minimum DTS for the\n   * current track\n   * @param track {object} track metadata configuration\n   * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n\n  var calculateTrackBaseMediaDecodeTime = function calculateTrackBaseMediaDecodeTime(track, keepOriginalTimestamps) {\n    var baseMediaDecodeTime,\n        scale,\n        minSegmentDts = track.minSegmentDts; // Optionally adjust the time so the first segment starts at zero.\n\n    if (!keepOriginalTimestamps) {\n      minSegmentDts -= track.timelineStartInfo.dts;\n    } // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n    // we want the start of the first segment to be placed\n\n\n    baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime; // Add to that the distance this segment is from the very first\n\n    baseMediaDecodeTime += minSegmentDts; // baseMediaDecodeTime must not become negative\n\n    baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n    if (track.type === 'audio') {\n      // Audio has a different clock equal to the sampling_rate so we need to\n      // scale the PTS values into the clock rate of the track\n      scale = track.samplerate / ONE_SECOND_IN_TS$3;\n      baseMediaDecodeTime *= scale;\n      baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n    }\n\n    return baseMediaDecodeTime;\n  };\n\n  var trackDecodeInfo = {\n    clearDtsInfo: clearDtsInfo,\n    calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n    collectDtsInfo: collectDtsInfo\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * Reads in-band caption information from a video elementary\n   * stream. Captions must follow the CEA-708 standard for injection\n   * into an MPEG-2 transport streams.\n   * @see https://en.wikipedia.org/wiki/CEA-708\n   * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n   */\n  // payload type field to indicate how they are to be\n  // interpreted. CEAS-708 caption content is always transmitted with\n  // payload type 0x04.\n\n  var USER_DATA_REGISTERED_ITU_T_T35 = 4,\n      RBSP_TRAILING_BITS = 128;\n  /**\n    * Parse a supplemental enhancement information (SEI) NAL unit.\n    * Stops parsing once a message of type ITU T T35 has been found.\n    *\n    * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n    * @return {object} the parsed SEI payload\n    * @see Rec. ITU-T H.264, 7.3.2.3.1\n    */\n\n  var parseSei = function parseSei(bytes) {\n    var i = 0,\n        result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n        payloadType = 0,\n        payloadSize = 0; // go through the sei_rbsp parsing each each individual sei_message\n\n    while (i < bytes.byteLength) {\n      // stop once we have hit the end of the sei_rbsp\n      if (bytes[i] === RBSP_TRAILING_BITS) {\n        break;\n      } // Parse payload type\n\n\n      while (bytes[i] === 0xFF) {\n        payloadType += 255;\n        i++;\n      }\n\n      payloadType += bytes[i++]; // Parse payload size\n\n      while (bytes[i] === 0xFF) {\n        payloadSize += 255;\n        i++;\n      }\n\n      payloadSize += bytes[i++]; // this sei_message is a 608/708 caption so save it and break\n      // there can only ever be one caption message in a frame's sei\n\n      if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);\n\n        if (userIdentifier === 'GA94') {\n          result.payloadType = payloadType;\n          result.payloadSize = payloadSize;\n          result.payload = bytes.subarray(i, i + payloadSize);\n          break;\n        } else {\n          result.payload = void 0;\n        }\n      } // skip the payload and parse the next message\n\n\n      i += payloadSize;\n      payloadType = 0;\n      payloadSize = 0;\n    }\n\n    return result;\n  }; // see ANSI/SCTE 128-1 (2013), section 8.1\n\n\n  var parseUserData = function parseUserData(sei) {\n    // itu_t_t35_contry_code must be 181 (United States) for\n    // captions\n    if (sei.payload[0] !== 181) {\n      return null;\n    } // itu_t_t35_provider_code should be 49 (ATSC) for captions\n\n\n    if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) {\n      return null;\n    } // the user_identifier should be \"GA94\" to indicate ATSC1 data\n\n\n    if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== 'GA94') {\n      return null;\n    } // finally, user_data_type_code should be 0x03 for caption data\n\n\n    if (sei.payload[7] !== 0x03) {\n      return null;\n    } // return the user_data_type_structure and strip the trailing\n    // marker bits\n\n\n    return sei.payload.subarray(8, sei.payload.length - 1);\n  }; // see CEA-708-D, section 4.4\n\n\n  var parseCaptionPackets = function parseCaptionPackets(pts, userData) {\n    var results = [],\n        i,\n        count,\n        offset,\n        data; // if this is just filler, return immediately\n\n    if (!(userData[0] & 0x40)) {\n      return results;\n    } // parse out the cc_data_1 and cc_data_2 fields\n\n\n    count = userData[0] & 0x1f;\n\n    for (i = 0; i < count; i++) {\n      offset = i * 3;\n      data = {\n        type: userData[offset + 2] & 0x03,\n        pts: pts\n      }; // capture cc data when cc_valid is 1\n\n      if (userData[offset + 2] & 0x04) {\n        data.ccData = userData[offset + 3] << 8 | userData[offset + 4];\n        results.push(data);\n      }\n    }\n\n    return results;\n  };\n\n  var discardEmulationPreventionBytes$1 = function discardEmulationPreventionBytes(data) {\n    var length = data.byteLength,\n        emulationPreventionBytesPositions = [],\n        i = 1,\n        newLength,\n        newData; // Find all `Emulation Prevention Bytes`\n\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    } // If no Emulation Prevention Bytes were found just return the original\n    // array\n\n\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    } // Create a new array to hold the NAL unit data\n\n\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++; // Remove this position index\n\n        emulationPreventionBytesPositions.shift();\n      }\n\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  }; // exports\n\n\n  var captionPacketParser = {\n    parseSei: parseSei,\n    parseUserData: parseUserData,\n    parseCaptionPackets: parseCaptionPackets,\n    discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,\n    USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n  };\n\n  // Link To Transport\n  // -----------------\n\n\n  var CaptionStream$1 = function CaptionStream(options) {\n    options = options || {};\n    CaptionStream.prototype.init.call(this); // parse708captions flag, default to true\n\n    this.parse708captions_ = typeof options.parse708captions === 'boolean' ? options.parse708captions : true;\n    this.captionPackets_ = [];\n    this.ccStreams_ = [new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n    ];\n\n    if (this.parse708captions_) {\n      this.cc708Stream_ = new Cea708Stream({\n        captionServices: options.captionServices\n      }); // eslint-disable-line no-use-before-define\n    }\n\n    this.reset(); // forward data and done events from CCs to this CaptionStream\n\n    this.ccStreams_.forEach(function (cc) {\n      cc.on('data', this.trigger.bind(this, 'data'));\n      cc.on('partialdone', this.trigger.bind(this, 'partialdone'));\n      cc.on('done', this.trigger.bind(this, 'done'));\n    }, this);\n\n    if (this.parse708captions_) {\n      this.cc708Stream_.on('data', this.trigger.bind(this, 'data'));\n      this.cc708Stream_.on('partialdone', this.trigger.bind(this, 'partialdone'));\n      this.cc708Stream_.on('done', this.trigger.bind(this, 'done'));\n    }\n  };\n\n  CaptionStream$1.prototype = new stream();\n\n  CaptionStream$1.prototype.push = function (event) {\n    var sei, userData, newCaptionPackets; // only examine SEI NALs\n\n    if (event.nalUnitType !== 'sei_rbsp') {\n      return;\n    } // parse the sei\n\n\n    sei = captionPacketParser.parseSei(event.escapedRBSP); // no payload data, skip\n\n    if (!sei.payload) {\n      return;\n    } // ignore everything but user_data_registered_itu_t_t35\n\n\n    if (sei.payloadType !== captionPacketParser.USER_DATA_REGISTERED_ITU_T_T35) {\n      return;\n    } // parse out the user data payload\n\n\n    userData = captionPacketParser.parseUserData(sei); // ignore unrecognized userData\n\n    if (!userData) {\n      return;\n    } // Sometimes, the same segment # will be downloaded twice. To stop the\n    // caption data from being processed twice, we track the latest dts we've\n    // received and ignore everything with a dts before that. However, since\n    // data for a specific dts can be split across packets on either side of\n    // a segment boundary, we need to make sure we *don't* ignore the packets\n    // from the *next* segment that have dts === this.latestDts_. By constantly\n    // tracking the number of packets received with dts === this.latestDts_, we\n    // know how many should be ignored once we start receiving duplicates.\n\n\n    if (event.dts < this.latestDts_) {\n      // We've started getting older data, so set the flag.\n      this.ignoreNextEqualDts_ = true;\n      return;\n    } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {\n      this.numSameDts_--;\n\n      if (!this.numSameDts_) {\n        // We've received the last duplicate packet, time to start processing again\n        this.ignoreNextEqualDts_ = false;\n      }\n\n      return;\n    } // parse out CC data packets and save them for later\n\n\n    newCaptionPackets = captionPacketParser.parseCaptionPackets(event.pts, userData);\n    this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n\n    if (this.latestDts_ !== event.dts) {\n      this.numSameDts_ = 0;\n    }\n\n    this.numSameDts_++;\n    this.latestDts_ = event.dts;\n  };\n\n  CaptionStream$1.prototype.flushCCStreams = function (flushType) {\n    this.ccStreams_.forEach(function (cc) {\n      return flushType === 'flush' ? cc.flush() : cc.partialFlush();\n    }, this);\n  };\n\n  CaptionStream$1.prototype.flushStream = function (flushType) {\n    // make sure we actually parsed captions before proceeding\n    if (!this.captionPackets_.length) {\n      this.flushCCStreams(flushType);\n      return;\n    } // In Chrome, the Array#sort function is not stable so add a\n    // presortIndex that we can use to ensure we get a stable-sort\n\n\n    this.captionPackets_.forEach(function (elem, idx) {\n      elem.presortIndex = idx;\n    }); // sort caption byte-pairs based on their PTS values\n\n    this.captionPackets_.sort(function (a, b) {\n      if (a.pts === b.pts) {\n        return a.presortIndex - b.presortIndex;\n      }\n\n      return a.pts - b.pts;\n    });\n    this.captionPackets_.forEach(function (packet) {\n      if (packet.type < 2) {\n        // Dispatch packet to the right Cea608Stream\n        this.dispatchCea608Packet(packet);\n      } else {\n        // Dispatch packet to the Cea708Stream\n        this.dispatchCea708Packet(packet);\n      }\n    }, this);\n    this.captionPackets_.length = 0;\n    this.flushCCStreams(flushType);\n  };\n\n  CaptionStream$1.prototype.flush = function () {\n    return this.flushStream('flush');\n  }; // Only called if handling partial data\n\n\n  CaptionStream$1.prototype.partialFlush = function () {\n    return this.flushStream('partialFlush');\n  };\n\n  CaptionStream$1.prototype.reset = function () {\n    this.latestDts_ = null;\n    this.ignoreNextEqualDts_ = false;\n    this.numSameDts_ = 0;\n    this.activeCea608Channel_ = [null, null];\n    this.ccStreams_.forEach(function (ccStream) {\n      ccStream.reset();\n    });\n  }; // From the CEA-608 spec:\n\n  /*\n   * When XDS sub-packets are interleaved with other services, the end of each sub-packet shall be followed\n   * by a control pair to change to a different service. When any of the control codes from 0x10 to 0x1F is\n   * used to begin a control code pair, it indicates the return to captioning or Text data. The control code pair\n   * and subsequent data should then be processed according to the FCC rules. It may be necessary for the\n   * line 21 data encoder to automatically insert a control code pair (i.e. RCL, RU2, RU3, RU4, RDC, or RTD)\n   * to switch to captioning or Text.\n  */\n  // With that in mind, we ignore any data between an XDS control code and a\n  // subsequent closed-captioning control code.\n\n\n  CaptionStream$1.prototype.dispatchCea608Packet = function (packet) {\n    // NOTE: packet.type is the CEA608 field\n    if (this.setsTextOrXDSActive(packet)) {\n      this.activeCea608Channel_[packet.type] = null;\n    } else if (this.setsChannel1Active(packet)) {\n      this.activeCea608Channel_[packet.type] = 0;\n    } else if (this.setsChannel2Active(packet)) {\n      this.activeCea608Channel_[packet.type] = 1;\n    }\n\n    if (this.activeCea608Channel_[packet.type] === null) {\n      // If we haven't received anything to set the active channel, or the\n      // packets are Text/XDS data, discard the data; we don't want jumbled\n      // captions\n      return;\n    }\n\n    this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n  };\n\n  CaptionStream$1.prototype.setsChannel1Active = function (packet) {\n    return (packet.ccData & 0x7800) === 0x1000;\n  };\n\n  CaptionStream$1.prototype.setsChannel2Active = function (packet) {\n    return (packet.ccData & 0x7800) === 0x1800;\n  };\n\n  CaptionStream$1.prototype.setsTextOrXDSActive = function (packet) {\n    return (packet.ccData & 0x7100) === 0x0100 || (packet.ccData & 0x78fe) === 0x102a || (packet.ccData & 0x78fe) === 0x182a;\n  };\n\n  CaptionStream$1.prototype.dispatchCea708Packet = function (packet) {\n    if (this.parse708captions_) {\n      this.cc708Stream_.push(packet);\n    }\n  }; // ----------------------\n  // Session to Application\n  // ----------------------\n  // This hash maps special and extended character codes to their\n  // proper Unicode equivalent. The first one-byte key is just a\n  // non-standard character code. The two-byte keys that follow are\n  // the extended CEA708 character codes, along with the preceding\n  // 0x10 extended character byte to distinguish these codes from\n  // non-extended character codes. Every CEA708 character code that\n  // is not in this object maps directly to a standard unicode\n  // character code.\n  // The transparent space and non-breaking transparent space are\n  // technically not fully supported since there is no code to\n  // make them transparent, so they have normal non-transparent\n  // stand-ins.\n  // The special closed caption (CC) character isn't a standard\n  // unicode character, so a fairly similar unicode character was\n  // chosen in it's place.\n\n\n  var CHARACTER_TRANSLATION_708 = {\n    0x7f: 0x266a,\n    // \n    0x1020: 0x20,\n    // Transparent Space\n    0x1021: 0xa0,\n    // Nob-breaking Transparent Space\n    0x1025: 0x2026,\n    // \n    0x102a: 0x0160,\n    // \n    0x102c: 0x0152,\n    // \n    0x1030: 0x2588,\n    // \n    0x1031: 0x2018,\n    // \n    0x1032: 0x2019,\n    // \n    0x1033: 0x201c,\n    // \n    0x1034: 0x201d,\n    // \n    0x1035: 0x2022,\n    // \n    0x1039: 0x2122,\n    // \n    0x103a: 0x0161,\n    // \n    0x103c: 0x0153,\n    // \n    0x103d: 0x2120,\n    // \n    0x103f: 0x0178,\n    // \n    0x1076: 0x215b,\n    // \n    0x1077: 0x215c,\n    // \n    0x1078: 0x215d,\n    // \n    0x1079: 0x215e,\n    // \n    0x107a: 0x23d0,\n    // \n    0x107b: 0x23a4,\n    // \n    0x107c: 0x23a3,\n    // \n    0x107d: 0x23af,\n    // \n    0x107e: 0x23a6,\n    // \n    0x107f: 0x23a1,\n    // \n    0x10a0: 0x3138 //  (CC char)\n\n  };\n\n  var get708CharFromCode = function get708CharFromCode(code) {\n    var newCode = CHARACTER_TRANSLATION_708[code] || code;\n\n    if (code & 0x1000 && code === newCode) {\n      // Invalid extended code\n      return '';\n    }\n\n    return String.fromCharCode(newCode);\n  };\n\n  var within708TextBlock = function within708TextBlock(b) {\n    return 0x20 <= b && b <= 0x7f || 0xa0 <= b && b <= 0xff;\n  };\n\n  var Cea708Window = function Cea708Window(windowNum) {\n    this.windowNum = windowNum;\n    this.reset();\n  };\n\n  Cea708Window.prototype.reset = function () {\n    this.clearText();\n    this.pendingNewLine = false;\n    this.winAttr = {};\n    this.penAttr = {};\n    this.penLoc = {};\n    this.penColor = {}; // These default values are arbitrary,\n    // defineWindow will usually override them\n\n    this.visible = 0;\n    this.rowLock = 0;\n    this.columnLock = 0;\n    this.priority = 0;\n    this.relativePositioning = 0;\n    this.anchorVertical = 0;\n    this.anchorHorizontal = 0;\n    this.anchorPoint = 0;\n    this.rowCount = 1;\n    this.virtualRowCount = this.rowCount + 1;\n    this.columnCount = 41;\n    this.windowStyle = 0;\n    this.penStyle = 0;\n  };\n\n  Cea708Window.prototype.getText = function () {\n    return this.rows.join('\\n');\n  };\n\n  Cea708Window.prototype.clearText = function () {\n    this.rows = [''];\n    this.rowIdx = 0;\n  };\n\n  Cea708Window.prototype.newLine = function (pts) {\n    if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === 'function') {\n      this.beforeRowOverflow(pts);\n    }\n\n    if (this.rows.length > 0) {\n      this.rows.push('');\n      this.rowIdx++;\n    } // Show all virtual rows since there's no visible scrolling\n\n\n    while (this.rows.length > this.virtualRowCount) {\n      this.rows.shift();\n      this.rowIdx--;\n    }\n  };\n\n  Cea708Window.prototype.isEmpty = function () {\n    if (this.rows.length === 0) {\n      return true;\n    } else if (this.rows.length === 1) {\n      return this.rows[0] === '';\n    }\n\n    return false;\n  };\n\n  Cea708Window.prototype.addText = function (text) {\n    this.rows[this.rowIdx] += text;\n  };\n\n  Cea708Window.prototype.backspace = function () {\n    if (!this.isEmpty()) {\n      var row = this.rows[this.rowIdx];\n      this.rows[this.rowIdx] = row.substr(0, row.length - 1);\n    }\n  };\n\n  var Cea708Service = function Cea708Service(serviceNum, encoding, stream) {\n    this.serviceNum = serviceNum;\n    this.text = '';\n    this.currentWindow = new Cea708Window(-1);\n    this.windows = [];\n    this.stream = stream; // Try to setup a TextDecoder if an `encoding` value was provided\n\n    if (typeof encoding === 'string') {\n      this.createTextDecoder(encoding);\n    }\n  };\n  /**\n   * Initialize service windows\n   * Must be run before service use\n   *\n   * @param  {Integer}  pts               PTS value\n   * @param  {Function} beforeRowOverflow Function to execute before row overflow of a window\n   */\n\n\n  Cea708Service.prototype.init = function (pts, beforeRowOverflow) {\n    this.startPts = pts;\n\n    for (var win = 0; win < 8; win++) {\n      this.windows[win] = new Cea708Window(win);\n\n      if (typeof beforeRowOverflow === 'function') {\n        this.windows[win].beforeRowOverflow = beforeRowOverflow;\n      }\n    }\n  };\n  /**\n   * Set current window of service to be affected by commands\n   *\n   * @param  {Integer} windowNum Window number\n   */\n\n\n  Cea708Service.prototype.setCurrentWindow = function (windowNum) {\n    this.currentWindow = this.windows[windowNum];\n  };\n  /**\n   * Try to create a TextDecoder if it is natively supported\n   */\n\n\n  Cea708Service.prototype.createTextDecoder = function (encoding) {\n    if (typeof TextDecoder === 'undefined') {\n      this.stream.trigger('log', {\n        level: 'warn',\n        message: 'The `encoding` option is unsupported without TextDecoder support'\n      });\n    } else {\n      try {\n        this.textDecoder_ = new TextDecoder(encoding);\n      } catch (error) {\n        this.stream.trigger('log', {\n          level: 'warn',\n          message: 'TextDecoder could not be created with ' + encoding + ' encoding. ' + error\n        });\n      }\n    }\n  };\n\n  var Cea708Stream = function Cea708Stream(options) {\n    options = options || {};\n    Cea708Stream.prototype.init.call(this);\n    var self = this;\n    var captionServices = options.captionServices || {};\n    var captionServiceEncodings = {};\n    var serviceProps; // Get service encodings from captionServices option block\n\n    Object.keys(captionServices).forEach(function (serviceName) {\n      serviceProps = captionServices[serviceName];\n\n      if (/^SERVICE/.test(serviceName)) {\n        captionServiceEncodings[serviceName] = serviceProps.encoding;\n      }\n    });\n    this.serviceEncodings = captionServiceEncodings;\n    this.current708Packet = null;\n    this.services = {};\n\n    this.push = function (packet) {\n      if (packet.type === 3) {\n        // 708 packet start\n        self.new708Packet();\n        self.add708Bytes(packet);\n      } else {\n        if (self.current708Packet === null) {\n          // This should only happen at the start of a file if there's no packet start.\n          self.new708Packet();\n        }\n\n        self.add708Bytes(packet);\n      }\n    };\n  };\n\n  Cea708Stream.prototype = new stream();\n  /**\n   * Push current 708 packet, create new 708 packet.\n   */\n\n  Cea708Stream.prototype.new708Packet = function () {\n    if (this.current708Packet !== null) {\n      this.push708Packet();\n    }\n\n    this.current708Packet = {\n      data: [],\n      ptsVals: []\n    };\n  };\n  /**\n   * Add pts and both bytes from packet into current 708 packet.\n   */\n\n\n  Cea708Stream.prototype.add708Bytes = function (packet) {\n    var data = packet.ccData;\n    var byte0 = data >>> 8;\n    var byte1 = data & 0xff; // I would just keep a list of packets instead of bytes, but it isn't clear in the spec\n    // that service blocks will always line up with byte pairs.\n\n    this.current708Packet.ptsVals.push(packet.pts);\n    this.current708Packet.data.push(byte0);\n    this.current708Packet.data.push(byte1);\n  };\n  /**\n   * Parse completed 708 packet into service blocks and push each service block.\n   */\n\n\n  Cea708Stream.prototype.push708Packet = function () {\n    var packet708 = this.current708Packet;\n    var packetData = packet708.data;\n    var serviceNum = null;\n    var blockSize = null;\n    var i = 0;\n    var b = packetData[i++];\n    packet708.seq = b >> 6;\n    packet708.sizeCode = b & 0x3f; // 0b00111111;\n\n    for (; i < packetData.length; i++) {\n      b = packetData[i++];\n      serviceNum = b >> 5;\n      blockSize = b & 0x1f; // 0b00011111\n\n      if (serviceNum === 7 && blockSize > 0) {\n        // Extended service num\n        b = packetData[i++];\n        serviceNum = b;\n      }\n\n      this.pushServiceBlock(serviceNum, i, blockSize);\n\n      if (blockSize > 0) {\n        i += blockSize - 1;\n      }\n    }\n  };\n  /**\n   * Parse service block, execute commands, read text.\n   *\n   * Note: While many of these commands serve important purposes,\n   * many others just parse out the parameters or attributes, but\n   * nothing is done with them because this is not a full and complete\n   * implementation of the entire 708 spec.\n   *\n   * @param  {Integer} serviceNum Service number\n   * @param  {Integer} start      Start index of the 708 packet data\n   * @param  {Integer} size       Block size\n   */\n\n\n  Cea708Stream.prototype.pushServiceBlock = function (serviceNum, start, size) {\n    var b;\n    var i = start;\n    var packetData = this.current708Packet.data;\n    var service = this.services[serviceNum];\n\n    if (!service) {\n      service = this.initService(serviceNum, i);\n    }\n\n    for (; i < start + size && i < packetData.length; i++) {\n      b = packetData[i];\n\n      if (within708TextBlock(b)) {\n        i = this.handleText(i, service);\n      } else if (b === 0x18) {\n        i = this.multiByteCharacter(i, service);\n      } else if (b === 0x10) {\n        i = this.extendedCommands(i, service);\n      } else if (0x80 <= b && b <= 0x87) {\n        i = this.setCurrentWindow(i, service);\n      } else if (0x98 <= b && b <= 0x9f) {\n        i = this.defineWindow(i, service);\n      } else if (b === 0x88) {\n        i = this.clearWindows(i, service);\n      } else if (b === 0x8c) {\n        i = this.deleteWindows(i, service);\n      } else if (b === 0x89) {\n        i = this.displayWindows(i, service);\n      } else if (b === 0x8a) {\n        i = this.hideWindows(i, service);\n      } else if (b === 0x8b) {\n        i = this.toggleWindows(i, service);\n      } else if (b === 0x97) {\n        i = this.setWindowAttributes(i, service);\n      } else if (b === 0x90) {\n        i = this.setPenAttributes(i, service);\n      } else if (b === 0x91) {\n        i = this.setPenColor(i, service);\n      } else if (b === 0x92) {\n        i = this.setPenLocation(i, service);\n      } else if (b === 0x8f) {\n        service = this.reset(i, service);\n      } else if (b === 0x08) {\n        // BS: Backspace\n        service.currentWindow.backspace();\n      } else if (b === 0x0c) {\n        // FF: Form feed\n        service.currentWindow.clearText();\n      } else if (b === 0x0d) {\n        // CR: Carriage return\n        service.currentWindow.pendingNewLine = true;\n      } else if (b === 0x0e) {\n        // HCR: Horizontal carriage return\n        service.currentWindow.clearText();\n      } else if (b === 0x8d) {\n        // DLY: Delay, nothing to do\n        i++;\n      } else ;\n    }\n  };\n  /**\n   * Execute an extended command\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.extendedCommands = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n\n    if (within708TextBlock(b)) {\n      i = this.handleText(i, service, {\n        isExtended: true\n      });\n    }\n\n    return i;\n  };\n  /**\n   * Get PTS value of a given byte index\n   *\n   * @param  {Integer} byteIndex  Index of the byte\n   * @return {Integer}            PTS\n   */\n\n\n  Cea708Stream.prototype.getPts = function (byteIndex) {\n    // There's 1 pts value per 2 bytes\n    return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];\n  };\n  /**\n   * Initializes a service\n   *\n   * @param  {Integer} serviceNum Service number\n   * @return {Service}            Initialized service object\n   */\n\n\n  Cea708Stream.prototype.initService = function (serviceNum, i) {\n    var serviceName = 'SERVICE' + serviceNum;\n    var self = this;\n    var serviceName;\n    var encoding;\n\n    if (serviceName in this.serviceEncodings) {\n      encoding = this.serviceEncodings[serviceName];\n    }\n\n    this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);\n    this.services[serviceNum].init(this.getPts(i), function (pts) {\n      self.flushDisplayed(pts, self.services[serviceNum]);\n    });\n    return this.services[serviceNum];\n  };\n  /**\n   * Execute text writing to current window\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.handleText = function (i, service, options) {\n    var isExtended = options && options.isExtended;\n    var isMultiByte = options && options.isMultiByte;\n    var packetData = this.current708Packet.data;\n    var extended = isExtended ? 0x1000 : 0x0000;\n    var currentByte = packetData[i];\n    var nextByte = packetData[i + 1];\n    var win = service.currentWindow;\n    var char;\n    var charCodeArray; // Use the TextDecoder if one was created for this service\n\n    if (service.textDecoder_ && !isExtended) {\n      if (isMultiByte) {\n        charCodeArray = [currentByte, nextByte];\n        i++;\n      } else {\n        charCodeArray = [currentByte];\n      }\n\n      char = service.textDecoder_.decode(new Uint8Array(charCodeArray));\n    } else {\n      char = get708CharFromCode(extended | currentByte);\n    }\n\n    if (win.pendingNewLine && !win.isEmpty()) {\n      win.newLine(this.getPts(i));\n    }\n\n    win.pendingNewLine = false;\n    win.addText(char);\n    return i;\n  };\n  /**\n   * Handle decoding of multibyte character\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.multiByteCharacter = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var firstByte = packetData[i + 1];\n    var secondByte = packetData[i + 2];\n\n    if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) {\n      i = this.handleText(++i, service, {\n        isMultiByte: true\n      });\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the CW# command.\n   *\n   * Set the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setCurrentWindow = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var windowNum = b & 0x07;\n    service.setCurrentWindow(windowNum);\n    return i;\n  };\n  /**\n   * Parse and execute the DF# command.\n   *\n   * Define a window and set it as the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.defineWindow = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var windowNum = b & 0x07;\n    service.setCurrentWindow(windowNum);\n    var win = service.currentWindow;\n    b = packetData[++i];\n    win.visible = (b & 0x20) >> 5; // v\n\n    win.rowLock = (b & 0x10) >> 4; // rl\n\n    win.columnLock = (b & 0x08) >> 3; // cl\n\n    win.priority = b & 0x07; // p\n\n    b = packetData[++i];\n    win.relativePositioning = (b & 0x80) >> 7; // rp\n\n    win.anchorVertical = b & 0x7f; // av\n\n    b = packetData[++i];\n    win.anchorHorizontal = b; // ah\n\n    b = packetData[++i];\n    win.anchorPoint = (b & 0xf0) >> 4; // ap\n\n    win.rowCount = b & 0x0f; // rc\n\n    b = packetData[++i];\n    win.columnCount = b & 0x3f; // cc\n\n    b = packetData[++i];\n    win.windowStyle = (b & 0x38) >> 3; // ws\n\n    win.penStyle = b & 0x07; // ps\n    // The spec says there are (rowCount+1) \"virtual rows\"\n\n    win.virtualRowCount = win.rowCount + 1;\n    return i;\n  };\n  /**\n   * Parse and execute the SWA command.\n   *\n   * Set attributes of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setWindowAttributes = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var winAttr = service.currentWindow.winAttr;\n    b = packetData[++i];\n    winAttr.fillOpacity = (b & 0xc0) >> 6; // fo\n\n    winAttr.fillRed = (b & 0x30) >> 4; // fr\n\n    winAttr.fillGreen = (b & 0x0c) >> 2; // fg\n\n    winAttr.fillBlue = b & 0x03; // fb\n\n    b = packetData[++i];\n    winAttr.borderType = (b & 0xc0) >> 6; // bt\n\n    winAttr.borderRed = (b & 0x30) >> 4; // br\n\n    winAttr.borderGreen = (b & 0x0c) >> 2; // bg\n\n    winAttr.borderBlue = b & 0x03; // bb\n\n    b = packetData[++i];\n    winAttr.borderType += (b & 0x80) >> 5; // bt\n\n    winAttr.wordWrap = (b & 0x40) >> 6; // ww\n\n    winAttr.printDirection = (b & 0x30) >> 4; // pd\n\n    winAttr.scrollDirection = (b & 0x0c) >> 2; // sd\n\n    winAttr.justify = b & 0x03; // j\n\n    b = packetData[++i];\n    winAttr.effectSpeed = (b & 0xf0) >> 4; // es\n\n    winAttr.effectDirection = (b & 0x0c) >> 2; // ed\n\n    winAttr.displayEffect = b & 0x03; // de\n\n    return i;\n  };\n  /**\n   * Gather text from all displayed windows and push a caption to output.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   */\n\n\n  Cea708Stream.prototype.flushDisplayed = function (pts, service) {\n    var displayedText = []; // TODO: Positioning not supported, displaying multiple windows will not necessarily\n    // display text in the correct order, but sample files so far have not shown any issue.\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (service.windows[winId].visible && !service.windows[winId].isEmpty()) {\n        displayedText.push(service.windows[winId].getText());\n      }\n    }\n\n    service.endPts = pts;\n    service.text = displayedText.join('\\n\\n');\n    this.pushCaption(service);\n    service.startPts = pts;\n  };\n  /**\n   * Push a caption to output if the caption contains text.\n   *\n   * @param  {Service} service  The service object to be affected\n   */\n\n\n  Cea708Stream.prototype.pushCaption = function (service) {\n    if (service.text !== '') {\n      this.trigger('data', {\n        startPts: service.startPts,\n        endPts: service.endPts,\n        text: service.text,\n        stream: 'cc708_' + service.serviceNum\n      });\n      service.text = '';\n      service.startPts = service.endPts;\n    }\n  };\n  /**\n   * Parse and execute the DSW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.displayWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible = 1;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the HDW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.hideWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible = 0;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the TGW command.\n   *\n   * Set visible property of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.toggleWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].visible ^= 1;\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the CLW command.\n   *\n   * Clear text of windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.clearWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].clearText();\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the DLW command.\n   *\n   * Re-initialize windows based on the parsed bitmask.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.deleteWindows = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[++i];\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n\n    for (var winId = 0; winId < 8; winId++) {\n      if (b & 0x01 << winId) {\n        service.windows[winId].reset();\n      }\n    }\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPA command.\n   *\n   * Set pen attributes of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenAttributes = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penAttr = service.currentWindow.penAttr;\n    b = packetData[++i];\n    penAttr.textTag = (b & 0xf0) >> 4; // tt\n\n    penAttr.offset = (b & 0x0c) >> 2; // o\n\n    penAttr.penSize = b & 0x03; // s\n\n    b = packetData[++i];\n    penAttr.italics = (b & 0x80) >> 7; // i\n\n    penAttr.underline = (b & 0x40) >> 6; // u\n\n    penAttr.edgeType = (b & 0x38) >> 3; // et\n\n    penAttr.fontStyle = b & 0x07; // fs\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPC command.\n   *\n   * Set pen color of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenColor = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penColor = service.currentWindow.penColor;\n    b = packetData[++i];\n    penColor.fgOpacity = (b & 0xc0) >> 6; // fo\n\n    penColor.fgRed = (b & 0x30) >> 4; // fr\n\n    penColor.fgGreen = (b & 0x0c) >> 2; // fg\n\n    penColor.fgBlue = b & 0x03; // fb\n\n    b = packetData[++i];\n    penColor.bgOpacity = (b & 0xc0) >> 6; // bo\n\n    penColor.bgRed = (b & 0x30) >> 4; // br\n\n    penColor.bgGreen = (b & 0x0c) >> 2; // bg\n\n    penColor.bgBlue = b & 0x03; // bb\n\n    b = packetData[++i];\n    penColor.edgeRed = (b & 0x30) >> 4; // er\n\n    penColor.edgeGreen = (b & 0x0c) >> 2; // eg\n\n    penColor.edgeBlue = b & 0x03; // eb\n\n    return i;\n  };\n  /**\n   * Parse and execute the SPL command.\n   *\n   * Set pen location of the current window.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Integer}          New index after parsing\n   */\n\n\n  Cea708Stream.prototype.setPenLocation = function (i, service) {\n    var packetData = this.current708Packet.data;\n    var b = packetData[i];\n    var penLoc = service.currentWindow.penLoc; // Positioning isn't really supported at the moment, so this essentially just inserts a linebreak\n\n    service.currentWindow.pendingNewLine = true;\n    b = packetData[++i];\n    penLoc.row = b & 0x0f; // r\n\n    b = packetData[++i];\n    penLoc.column = b & 0x3f; // c\n\n    return i;\n  };\n  /**\n   * Execute the RST command.\n   *\n   * Reset service to a clean slate. Re-initialize.\n   *\n   * @param  {Integer} i        Current index in the 708 packet\n   * @param  {Service} service  The service object to be affected\n   * @return {Service}          Re-initialized service\n   */\n\n\n  Cea708Stream.prototype.reset = function (i, service) {\n    var pts = this.getPts(i);\n    this.flushDisplayed(pts, service);\n    return this.initService(service.serviceNum, i);\n  }; // This hash maps non-ASCII, special, and extended character codes to their\n  // proper Unicode equivalent. The first keys that are only a single byte\n  // are the non-standard ASCII characters, which simply map the CEA608 byte\n  // to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n  // character codes, but have their MSB bitmasked with 0x03 so that a lookup\n  // can be performed regardless of the field and data channel on which the\n  // character code was received.\n\n\n  var CHARACTER_TRANSLATION = {\n    0x2a: 0xe1,\n    // \n    0x5c: 0xe9,\n    // \n    0x5e: 0xed,\n    // \n    0x5f: 0xf3,\n    // \n    0x60: 0xfa,\n    // \n    0x7b: 0xe7,\n    // \n    0x7c: 0xf7,\n    // \n    0x7d: 0xd1,\n    // \n    0x7e: 0xf1,\n    // \n    0x7f: 0x2588,\n    // \n    0x0130: 0xae,\n    // \n    0x0131: 0xb0,\n    // \n    0x0132: 0xbd,\n    // \n    0x0133: 0xbf,\n    // \n    0x0134: 0x2122,\n    // \n    0x0135: 0xa2,\n    // \n    0x0136: 0xa3,\n    // \n    0x0137: 0x266a,\n    // \n    0x0138: 0xe0,\n    // \n    0x0139: 0xa0,\n    //\n    0x013a: 0xe8,\n    // \n    0x013b: 0xe2,\n    // \n    0x013c: 0xea,\n    // \n    0x013d: 0xee,\n    // \n    0x013e: 0xf4,\n    // \n    0x013f: 0xfb,\n    // \n    0x0220: 0xc1,\n    // \n    0x0221: 0xc9,\n    // \n    0x0222: 0xd3,\n    // \n    0x0223: 0xda,\n    // \n    0x0224: 0xdc,\n    // \n    0x0225: 0xfc,\n    // \n    0x0226: 0x2018,\n    // \n    0x0227: 0xa1,\n    // \n    0x0228: 0x2a,\n    // *\n    0x0229: 0x27,\n    // '\n    0x022a: 0x2014,\n    // \n    0x022b: 0xa9,\n    // \n    0x022c: 0x2120,\n    // \n    0x022d: 0x2022,\n    // \n    0x022e: 0x201c,\n    // \n    0x022f: 0x201d,\n    // \n    0x0230: 0xc0,\n    // \n    0x0231: 0xc2,\n    // \n    0x0232: 0xc7,\n    // \n    0x0233: 0xc8,\n    // \n    0x0234: 0xca,\n    // \n    0x0235: 0xcb,\n    // \n    0x0236: 0xeb,\n    // \n    0x0237: 0xce,\n    // \n    0x0238: 0xcf,\n    // \n    0x0239: 0xef,\n    // \n    0x023a: 0xd4,\n    // \n    0x023b: 0xd9,\n    // \n    0x023c: 0xf9,\n    // \n    0x023d: 0xdb,\n    // \n    0x023e: 0xab,\n    // \n    0x023f: 0xbb,\n    // \n    0x0320: 0xc3,\n    // \n    0x0321: 0xe3,\n    // \n    0x0322: 0xcd,\n    // \n    0x0323: 0xcc,\n    // \n    0x0324: 0xec,\n    // \n    0x0325: 0xd2,\n    // \n    0x0326: 0xf2,\n    // \n    0x0327: 0xd5,\n    // \n    0x0328: 0xf5,\n    // \n    0x0329: 0x7b,\n    // {\n    0x032a: 0x7d,\n    // }\n    0x032b: 0x5c,\n    // \\\n    0x032c: 0x5e,\n    // ^\n    0x032d: 0x5f,\n    // _\n    0x032e: 0x7c,\n    // |\n    0x032f: 0x7e,\n    // ~\n    0x0330: 0xc4,\n    // \n    0x0331: 0xe4,\n    // \n    0x0332: 0xd6,\n    // \n    0x0333: 0xf6,\n    // \n    0x0334: 0xdf,\n    // \n    0x0335: 0xa5,\n    // \n    0x0336: 0xa4,\n    // \n    0x0337: 0x2502,\n    // \n    0x0338: 0xc5,\n    // \n    0x0339: 0xe5,\n    // \n    0x033a: 0xd8,\n    // \n    0x033b: 0xf8,\n    // \n    0x033c: 0x250c,\n    // \n    0x033d: 0x2510,\n    // \n    0x033e: 0x2514,\n    // \n    0x033f: 0x2518 // \n\n  };\n\n  var getCharFromCode = function getCharFromCode(code) {\n    if (code === null) {\n      return '';\n    }\n\n    code = CHARACTER_TRANSLATION[code] || code;\n    return String.fromCharCode(code);\n  }; // the index of the last row in a CEA-608 display buffer\n\n\n  var BOTTOM_ROW = 14; // This array is used for mapping PACs -> row #, since there's no way of\n  // getting it through bit logic.\n\n  var ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620, 0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420]; // CEA-608 captions are rendered onto a 34x15 matrix of character\n  // cells. The \"bottom\" row is the last element in the outer array.\n\n  var createDisplayBuffer = function createDisplayBuffer() {\n    var result = [],\n        i = BOTTOM_ROW + 1;\n\n    while (i--) {\n      result.push('');\n    }\n\n    return result;\n  };\n\n  var Cea608Stream = function Cea608Stream(field, dataChannel) {\n    Cea608Stream.prototype.init.call(this);\n    this.field_ = field || 0;\n    this.dataChannel_ = dataChannel || 0;\n    this.name_ = 'CC' + ((this.field_ << 1 | this.dataChannel_) + 1);\n    this.setConstants();\n    this.reset();\n\n    this.push = function (packet) {\n      var data, swap, char0, char1, text; // remove the parity bits\n\n      data = packet.ccData & 0x7f7f; // ignore duplicate control codes; the spec demands they're sent twice\n\n      if (data === this.lastControlCode_) {\n        this.lastControlCode_ = null;\n        return;\n      } // Store control codes\n\n\n      if ((data & 0xf000) === 0x1000) {\n        this.lastControlCode_ = data;\n      } else if (data !== this.PADDING_) {\n        this.lastControlCode_ = null;\n      }\n\n      char0 = data >>> 8;\n      char1 = data & 0xff;\n\n      if (data === this.PADDING_) {\n        return;\n      } else if (data === this.RESUME_CAPTION_LOADING_) {\n        this.mode_ = 'popOn';\n      } else if (data === this.END_OF_CAPTION_) {\n        // If an EOC is received while in paint-on mode, the displayed caption\n        // text should be swapped to non-displayed memory as if it was a pop-on\n        // caption. Because of that, we should explicitly switch back to pop-on\n        // mode\n        this.mode_ = 'popOn';\n        this.clearFormatting(packet.pts); // if a caption was being displayed, it's gone now\n\n        this.flushDisplayed(packet.pts); // flip memory\n\n        swap = this.displayed_;\n        this.displayed_ = this.nonDisplayed_;\n        this.nonDisplayed_ = swap; // start measuring the time to display the caption\n\n        this.startPts_ = packet.pts;\n      } else if (data === this.ROLL_UP_2_ROWS_) {\n        this.rollUpRows_ = 2;\n        this.setRollUp(packet.pts);\n      } else if (data === this.ROLL_UP_3_ROWS_) {\n        this.rollUpRows_ = 3;\n        this.setRollUp(packet.pts);\n      } else if (data === this.ROLL_UP_4_ROWS_) {\n        this.rollUpRows_ = 4;\n        this.setRollUp(packet.pts);\n      } else if (data === this.CARRIAGE_RETURN_) {\n        this.clearFormatting(packet.pts);\n        this.flushDisplayed(packet.pts);\n        this.shiftRowsUp_();\n        this.startPts_ = packet.pts;\n      } else if (data === this.BACKSPACE_) {\n        if (this.mode_ === 'popOn') {\n          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n        } else {\n          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n        }\n      } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n        this.flushDisplayed(packet.pts);\n        this.displayed_ = createDisplayBuffer();\n      } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n        this.nonDisplayed_ = createDisplayBuffer();\n      } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n        if (this.mode_ !== 'paintOn') {\n          // NOTE: This should be removed when proper caption positioning is\n          // implemented\n          this.flushDisplayed(packet.pts);\n          this.displayed_ = createDisplayBuffer();\n        }\n\n        this.mode_ = 'paintOn';\n        this.startPts_ = packet.pts; // Append special characters to caption text\n      } else if (this.isSpecialCharacter(char0, char1)) {\n        // Bitmask char0 so that we can apply character transformations\n        // regardless of field and data channel.\n        // Then byte-shift to the left and OR with char1 so we can pass the\n        // entire character code to `getCharFromCode`.\n        char0 = (char0 & 0x03) << 8;\n        text = getCharFromCode(char0 | char1);\n        this[this.mode_](packet.pts, text);\n        this.column_++; // Append extended characters to caption text\n      } else if (this.isExtCharacter(char0, char1)) {\n        // Extended characters always follow their \"non-extended\" equivalents.\n        // IE if a \"\" is desired, you'll always receive \"e\"; non-compliant\n        // decoders are supposed to drop the \"\", while compliant decoders\n        // backspace the \"e\" and insert \"\".\n        // Delete the previous character\n        if (this.mode_ === 'popOn') {\n          this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n        } else {\n          this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n        } // Bitmask char0 so that we can apply character transformations\n        // regardless of field and data channel.\n        // Then byte-shift to the left and OR with char1 so we can pass the\n        // entire character code to `getCharFromCode`.\n\n\n        char0 = (char0 & 0x03) << 8;\n        text = getCharFromCode(char0 | char1);\n        this[this.mode_](packet.pts, text);\n        this.column_++; // Process mid-row codes\n      } else if (this.isMidRowCode(char0, char1)) {\n        // Attributes are not additive, so clear all formatting\n        this.clearFormatting(packet.pts); // According to the standard, mid-row codes\n        // should be replaced with spaces, so add one now\n\n        this[this.mode_](packet.pts, ' ');\n        this.column_++;\n\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n\n        if ((char1 & 0x1) === 0x1) {\n          this.addFormatting(packet.pts, ['u']);\n        } // Detect offset control codes and adjust cursor\n\n      } else if (this.isOffsetControlCode(char0, char1)) {\n        // Cursor position is set by indent PAC (see below) in 4-column\n        // increments, with an additional offset code of 1-3 to reach any\n        // of the 32 columns specified by CEA-608. So all we need to do\n        // here is increment the column cursor by the given offset.\n        this.column_ += char1 & 0x03; // Detect PACs (Preamble Address Codes)\n      } else if (this.isPAC(char0, char1)) {\n        // There's no logic for PAC -> row mapping, so we have to just\n        // find the row code in an array and use its index :(\n        var row = ROWS.indexOf(data & 0x1f20); // Configure the caption window if we're in roll-up mode\n\n        if (this.mode_ === 'rollUp') {\n          // This implies that the base row is incorrectly set.\n          // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n          // of roll-up rows set.\n          if (row - this.rollUpRows_ + 1 < 0) {\n            row = this.rollUpRows_ - 1;\n          }\n\n          this.setRollUp(packet.pts, row);\n        }\n\n        if (row !== this.row_) {\n          // formatting is only persistent for current row\n          this.clearFormatting(packet.pts);\n          this.row_ = row;\n        } // All PACs can apply underline, so detect and apply\n        // (All odd-numbered second bytes set underline)\n\n\n        if (char1 & 0x1 && this.formatting_.indexOf('u') === -1) {\n          this.addFormatting(packet.pts, ['u']);\n        }\n\n        if ((data & 0x10) === 0x10) {\n          // We've got an indent level code. Each successive even number\n          // increments the column cursor by 4, so we can get the desired\n          // column position by bit-shifting to the right (to get n/2)\n          // and multiplying by 4.\n          this.column_ = ((data & 0xe) >> 1) * 4;\n        }\n\n        if (this.isColorPAC(char1)) {\n          // it's a color code, though we only support white, which\n          // can be either normal or italicized. white italics can be\n          // either 0x4e or 0x6e depending on the row, so we just\n          // bitwise-and with 0xe to see if italics should be turned on\n          if ((char1 & 0xe) === 0xe) {\n            this.addFormatting(packet.pts, ['i']);\n          }\n        } // We have a normal character in char0, and possibly one in char1\n\n      } else if (this.isNormalChar(char0)) {\n        if (char1 === 0x00) {\n          char1 = null;\n        }\n\n        text = getCharFromCode(char0);\n        text += getCharFromCode(char1);\n        this[this.mode_](packet.pts, text);\n        this.column_ += text.length;\n      } // finish data processing\n\n    };\n  };\n\n  Cea608Stream.prototype = new stream(); // Trigger a cue point that captures the current state of the\n  // display buffer\n\n  Cea608Stream.prototype.flushDisplayed = function (pts) {\n    var content = this.displayed_ // remove spaces from the start and end of the string\n    .map(function (row, index) {\n      try {\n        return row.trim();\n      } catch (e) {\n        // Ordinarily, this shouldn't happen. However, caption\n        // parsing errors should not throw exceptions and\n        // break playback.\n        this.trigger('log', {\n          level: 'warn',\n          message: 'Skipping a malformed 608 caption at index ' + index + '.'\n        });\n        return '';\n      }\n    }, this) // combine all text rows to display in one cue\n    .join('\\n') // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n    if (content.length) {\n      this.trigger('data', {\n        startPts: this.startPts_,\n        endPts: pts,\n        text: content,\n        stream: this.name_\n      });\n    }\n  };\n  /**\n   * Zero out the data, used for startup and on seek\n   */\n\n\n  Cea608Stream.prototype.reset = function () {\n    this.mode_ = 'popOn'; // When in roll-up mode, the index of the last row that will\n    // actually display captions. If a caption is shifted to a row\n    // with a lower index than this, it is cleared from the display\n    // buffer\n\n    this.topRow_ = 0;\n    this.startPts_ = 0;\n    this.displayed_ = createDisplayBuffer();\n    this.nonDisplayed_ = createDisplayBuffer();\n    this.lastControlCode_ = null; // Track row and column for proper line-breaking and spacing\n\n    this.column_ = 0;\n    this.row_ = BOTTOM_ROW;\n    this.rollUpRows_ = 2; // This variable holds currently-applied formatting\n\n    this.formatting_ = [];\n  };\n  /**\n   * Sets up control code and related constants for this instance\n   */\n\n\n  Cea608Stream.prototype.setConstants = function () {\n    // The following attributes have these uses:\n    // ext_ :    char0 for mid-row codes, and the base for extended\n    //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n    //           extended codes)\n    // control_: char0 for control codes, except byte-shifted to the\n    //           left so that we can do this.control_ | CONTROL_CODE\n    // offset_:  char0 for tab offset codes\n    //\n    // It's also worth noting that control codes, and _only_ control codes,\n    // differ between field 1 and field2. Field 2 control codes are always\n    // their field 1 value plus 1. That's why there's the \"| field\" on the\n    // control value.\n    if (this.dataChannel_ === 0) {\n      this.BASE_ = 0x10;\n      this.EXT_ = 0x11;\n      this.CONTROL_ = (0x14 | this.field_) << 8;\n      this.OFFSET_ = 0x17;\n    } else if (this.dataChannel_ === 1) {\n      this.BASE_ = 0x18;\n      this.EXT_ = 0x19;\n      this.CONTROL_ = (0x1c | this.field_) << 8;\n      this.OFFSET_ = 0x1f;\n    } // Constants for the LSByte command codes recognized by Cea608Stream. This\n    // list is not exhaustive. For a more comprehensive listing and semantics see\n    // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n    // Padding\n\n\n    this.PADDING_ = 0x0000; // Pop-on Mode\n\n    this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 0x20;\n    this.END_OF_CAPTION_ = this.CONTROL_ | 0x2f; // Roll-up Mode\n\n    this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 0x25;\n    this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 0x26;\n    this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 0x27;\n    this.CARRIAGE_RETURN_ = this.CONTROL_ | 0x2d; // paint-on mode\n\n    this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 0x29; // Erasure\n\n    this.BACKSPACE_ = this.CONTROL_ | 0x21;\n    this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2c;\n    this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n  };\n  /**\n   * Detects if the 2-byte packet data is a special character\n   *\n   * Special characters have a second byte in the range 0x30 to 0x3f,\n   * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n   * data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an special character\n   */\n\n\n  Cea608Stream.prototype.isSpecialCharacter = function (char0, char1) {\n    return char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f;\n  };\n  /**\n   * Detects if the 2-byte packet data is an extended character\n   *\n   * Extended characters have a second byte in the range 0x20 to 0x3f,\n   * with the first byte being 0x12 or 0x13 (for data channel 1) or\n   * 0x1a or 0x1b (for data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an extended character\n   */\n\n\n  Cea608Stream.prototype.isExtCharacter = function (char0, char1) {\n    return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 0x20 && char1 <= 0x3f;\n  };\n  /**\n   * Detects if the 2-byte packet is a mid-row code\n   *\n   * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n   * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n   * channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are a mid-row code\n   */\n\n\n  Cea608Stream.prototype.isMidRowCode = function (char0, char1) {\n    return char0 === this.EXT_ && char1 >= 0x20 && char1 <= 0x2f;\n  };\n  /**\n   * Detects if the 2-byte packet is an offset control code\n   *\n   * Offset control codes have a second byte in the range 0x21 to 0x23,\n   * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n   * data channel 2).\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are an offset control code\n   */\n\n\n  Cea608Stream.prototype.isOffsetControlCode = function (char0, char1) {\n    return char0 === this.OFFSET_ && char1 >= 0x21 && char1 <= 0x23;\n  };\n  /**\n   * Detects if the 2-byte packet is a Preamble Address Code\n   *\n   * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n   * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n   * range 0x40 to 0x7f.\n   *\n   * @param  {Integer} char0 The first byte\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the 2 bytes are a PAC\n   */\n\n\n  Cea608Stream.prototype.isPAC = function (char0, char1) {\n    return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 0x40 && char1 <= 0x7f;\n  };\n  /**\n   * Detects if a packet's second byte is in the range of a PAC color code\n   *\n   * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n   * 0x60 to 0x6f.\n   *\n   * @param  {Integer} char1 The second byte\n   * @return {Boolean}       Whether the byte is a color PAC\n   */\n\n\n  Cea608Stream.prototype.isColorPAC = function (char1) {\n    return char1 >= 0x40 && char1 <= 0x4f || char1 >= 0x60 && char1 <= 0x7f;\n  };\n  /**\n   * Detects if a single byte is in the range of a normal character\n   *\n   * Normal text bytes are in the range 0x20 to 0x7f.\n   *\n   * @param  {Integer} char  The byte\n   * @return {Boolean}       Whether the byte is a normal character\n   */\n\n\n  Cea608Stream.prototype.isNormalChar = function (char) {\n    return char >= 0x20 && char <= 0x7f;\n  };\n  /**\n   * Configures roll-up\n   *\n   * @param  {Integer} pts         Current PTS\n   * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n   *                               a new position\n   */\n\n\n  Cea608Stream.prototype.setRollUp = function (pts, newBaseRow) {\n    // Reset the base row to the bottom row when switching modes\n    if (this.mode_ !== 'rollUp') {\n      this.row_ = BOTTOM_ROW;\n      this.mode_ = 'rollUp'; // Spec says to wipe memories when switching to roll-up\n\n      this.flushDisplayed(pts);\n      this.nonDisplayed_ = createDisplayBuffer();\n      this.displayed_ = createDisplayBuffer();\n    }\n\n    if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n      // move currently displayed captions (up or down) to the new base row\n      for (var i = 0; i < this.rollUpRows_; i++) {\n        this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n        this.displayed_[this.row_ - i] = '';\n      }\n    }\n\n    if (newBaseRow === undefined) {\n      newBaseRow = this.row_;\n    }\n\n    this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n  }; // Adds the opening HTML tag for the passed character to the caption text,\n  // and keeps track of it for later closing\n\n\n  Cea608Stream.prototype.addFormatting = function (pts, format) {\n    this.formatting_ = this.formatting_.concat(format);\n    var text = format.reduce(function (text, format) {\n      return text + '<' + format + '>';\n    }, '');\n    this[this.mode_](pts, text);\n  }; // Adds HTML closing tags for current formatting to caption text and\n  // clears remembered formatting\n\n\n  Cea608Stream.prototype.clearFormatting = function (pts) {\n    if (!this.formatting_.length) {\n      return;\n    }\n\n    var text = this.formatting_.reverse().reduce(function (text, format) {\n      return text + '</' + format + '>';\n    }, '');\n    this.formatting_ = [];\n    this[this.mode_](pts, text);\n  }; // Mode Implementations\n\n\n  Cea608Stream.prototype.popOn = function (pts, text) {\n    var baseRow = this.nonDisplayed_[this.row_]; // buffer characters\n\n    baseRow += text;\n    this.nonDisplayed_[this.row_] = baseRow;\n  };\n\n  Cea608Stream.prototype.rollUp = function (pts, text) {\n    var baseRow = this.displayed_[this.row_];\n    baseRow += text;\n    this.displayed_[this.row_] = baseRow;\n  };\n\n  Cea608Stream.prototype.shiftRowsUp_ = function () {\n    var i; // clear out inactive rows\n\n    for (i = 0; i < this.topRow_; i++) {\n      this.displayed_[i] = '';\n    }\n\n    for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n      this.displayed_[i] = '';\n    } // shift displayed rows up\n\n\n    for (i = this.topRow_; i < this.row_; i++) {\n      this.displayed_[i] = this.displayed_[i + 1];\n    } // clear out the bottom row\n\n\n    this.displayed_[this.row_] = '';\n  };\n\n  Cea608Stream.prototype.paintOn = function (pts, text) {\n    var baseRow = this.displayed_[this.row_];\n    baseRow += text;\n    this.displayed_[this.row_] = baseRow;\n  }; // exports\n\n\n  var captionStream = {\n    CaptionStream: CaptionStream$1,\n    Cea608Stream: Cea608Stream,\n    Cea708Stream: Cea708Stream\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var streamTypes = {\n    H264_STREAM_TYPE: 0x1B,\n    ADTS_STREAM_TYPE: 0x0F,\n    METADATA_STREAM_TYPE: 0x15\n  };\n\n  var MAX_TS = 8589934592;\n  var RO_THRESH = 4294967296;\n  var TYPE_SHARED = 'shared';\n\n  var handleRollover$1 = function handleRollover(value, reference) {\n    var direction = 1;\n\n    if (value > reference) {\n      // If the current timestamp value is greater than our reference timestamp and we detect a\n      // timestamp rollover, this means the roll over is happening in the opposite direction.\n      // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n      // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n      // rollover point. In loading this segment, the timestamp values will be very large,\n      // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n      // the time stamp to be `value - 2^33`.\n      direction = -1;\n    } // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n    // cause an incorrect adjustment.\n\n\n    while (Math.abs(reference - value) > RO_THRESH) {\n      value += direction * MAX_TS;\n    }\n\n    return value;\n  };\n\n  var TimestampRolloverStream$1 = function TimestampRolloverStream(type) {\n    var lastDTS, referenceDTS;\n    TimestampRolloverStream.prototype.init.call(this); // The \"shared\" type is used in cases where a stream will contain muxed\n    // video and audio. We could use `undefined` here, but having a string\n    // makes debugging a little clearer.\n\n    this.type_ = type || TYPE_SHARED;\n\n    this.push = function (data) {\n      // Any \"shared\" rollover streams will accept _all_ data. Otherwise,\n      // streams will only accept data that matches their type.\n      if (this.type_ !== TYPE_SHARED && data.type !== this.type_) {\n        return;\n      }\n\n      if (referenceDTS === undefined) {\n        referenceDTS = data.dts;\n      }\n\n      data.dts = handleRollover$1(data.dts, referenceDTS);\n      data.pts = handleRollover$1(data.pts, referenceDTS);\n      lastDTS = data.dts;\n      this.trigger('data', data);\n    };\n\n    this.flush = function () {\n      referenceDTS = lastDTS;\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n\n    this.discontinuity = function () {\n      referenceDTS = void 0;\n      lastDTS = void 0;\n    };\n\n    this.reset = function () {\n      this.discontinuity();\n      this.trigger('reset');\n    };\n  };\n\n  TimestampRolloverStream$1.prototype = new stream();\n  var timestampRolloverStream = {\n    TimestampRolloverStream: TimestampRolloverStream$1,\n    handleRollover: handleRollover$1\n  };\n\n  // IE11 doesn't support indexOf for TypedArrays.\n  // Once IE11 support is dropped, this function should be removed.\n  var typedArrayIndexOf$1 = function typedArrayIndexOf(typedArray, element, fromIndex) {\n    if (!typedArray) {\n      return -1;\n    }\n\n    var currentIndex = fromIndex;\n\n    for (; currentIndex < typedArray.length; currentIndex++) {\n      if (typedArray[currentIndex] === element) {\n        return currentIndex;\n      }\n    }\n\n    return -1;\n  };\n\n  var typedArray = {\n    typedArrayIndexOf: typedArrayIndexOf$1\n  };\n\n  var typedArrayIndexOf = typedArray.typedArrayIndexOf,\n      // Frames that allow different types of text encoding contain a text\n  // encoding description byte [ID3v2.4.0 section 4.]\n  textEncodingDescriptionByte = {\n    Iso88591: 0x00,\n    // ISO-8859-1, terminated with \\0.\n    Utf16: 0x01,\n    // UTF-16 encoded Unicode BOM, terminated with \\0\\0\n    Utf16be: 0x02,\n    // UTF-16BE encoded Unicode, without BOM, terminated with \\0\\0\n    Utf8: 0x03 // UTF-8 encoded Unicode, terminated with \\0\n\n  },\n      // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n  percentEncode$1 = function percentEncode(bytes, start, end) {\n    var i,\n        result = '';\n\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n\n    return result;\n  },\n      // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function parseUtf8(bytes, start, end) {\n    return decodeURIComponent(percentEncode$1(bytes, start, end));\n  },\n      // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591$1 = function parseIso88591(bytes, start, end) {\n    return unescape(percentEncode$1(bytes, start, end)); // jshint ignore:line\n  },\n      parseSyncSafeInteger$1 = function parseSyncSafeInteger(data) {\n    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n  },\n      frameParsers = {\n    'APIC': function APIC(frame) {\n      var i = 1,\n          mimeTypeEndIndex,\n          descriptionEndIndex,\n          LINK_MIME_TYPE = '-->';\n\n      if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n        // ignore frames with unrecognized character encodings\n        return;\n      } // parsing fields [ID3v2.4.0 section 4.14.]\n\n\n      mimeTypeEndIndex = typedArrayIndexOf(frame.data, 0, i);\n\n      if (mimeTypeEndIndex < 0) {\n        // malformed frame\n        return;\n      } // parsing Mime type field (terminated with \\0)\n\n\n      frame.mimeType = parseIso88591$1(frame.data, i, mimeTypeEndIndex);\n      i = mimeTypeEndIndex + 1; // parsing 1-byte Picture Type field\n\n      frame.pictureType = frame.data[i];\n      i++;\n      descriptionEndIndex = typedArrayIndexOf(frame.data, 0, i);\n\n      if (descriptionEndIndex < 0) {\n        // malformed frame\n        return;\n      } // parsing Description field (terminated with \\0)\n\n\n      frame.description = parseUtf8(frame.data, i, descriptionEndIndex);\n      i = descriptionEndIndex + 1;\n\n      if (frame.mimeType === LINK_MIME_TYPE) {\n        // parsing Picture Data field as URL (always represented as ISO-8859-1 [ID3v2.4.0 section 4.])\n        frame.url = parseIso88591$1(frame.data, i, frame.data.length);\n      } else {\n        // parsing Picture Data field as binary data\n        frame.pictureData = frame.data.subarray(i, frame.data.length);\n      }\n    },\n    'T*': function T(frame) {\n      if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n        // ignore frames with unrecognized character encodings\n        return;\n      } // parse text field, do not include null terminator in the frame value\n      // frames that allow different types of encoding contain terminated text [ID3v2.4.0 section 4.]\n\n\n      frame.value = parseUtf8(frame.data, 1, frame.data.length).replace(/\\0*$/, ''); // text information frames supports multiple strings, stored as a terminator separated list [ID3v2.4.0 section 4.2.]\n\n      frame.values = frame.value.split('\\0');\n    },\n    'TXXX': function TXXX(frame) {\n      var descriptionEndIndex;\n\n      if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);\n\n      if (descriptionEndIndex === -1) {\n        return;\n      } // parse the text fields\n\n\n      frame.description = parseUtf8(frame.data, 1, descriptionEndIndex); // do not include the null terminator in the tag value\n      // frames that allow different types of encoding contain terminated text\n      // [ID3v2.4.0 section 4.]\n\n      frame.value = parseUtf8(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\\0*$/, '');\n      frame.data = frame.value;\n    },\n    'W*': function W(frame) {\n      // parse URL field; URL fields are always represented as ISO-8859-1 [ID3v2.4.0 section 4.]\n      // if the value is followed by a string termination all the following information should be ignored [ID3v2.4.0 section 4.3]\n      frame.url = parseIso88591$1(frame.data, 0, frame.data.length).replace(/\\0.*$/, '');\n    },\n    'WXXX': function WXXX(frame) {\n      var descriptionEndIndex;\n\n      if (frame.data[0] !== textEncodingDescriptionByte.Utf8) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);\n\n      if (descriptionEndIndex === -1) {\n        return;\n      } // parse the description and URL fields\n\n\n      frame.description = parseUtf8(frame.data, 1, descriptionEndIndex); // URL fields are always represented as ISO-8859-1 [ID3v2.4.0 section 4.]\n      // if the value is followed by a string termination all the following information\n      // should be ignored [ID3v2.4.0 section 4.3]\n\n      frame.url = parseIso88591$1(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\\0.*$/, '');\n    },\n    'PRIV': function PRIV(frame) {\n      var i;\n\n      for (i = 0; i < frame.data.length; i++) {\n        if (frame.data[i] === 0) {\n          // parse the description and URL fields\n          frame.owner = parseIso88591$1(frame.data, 0, i);\n          break;\n        }\n      }\n\n      frame.privateData = frame.data.subarray(i + 1);\n      frame.data = frame.privateData;\n    }\n  },\n      _MetadataStream;\n\n  _MetadataStream = function MetadataStream(options) {\n    var settings = {\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n        // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n        // tag data that is not complete enough to be parsed\n    buffer = [],\n        // the total number of bytes currently in the buffer\n    bufferSize = 0,\n        i;\n\n    _MetadataStream.prototype.init.call(this); // calculate the text track in-band metadata track dispatch type\n    // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n\n\n    this.dispatchType = streamTypes.METADATA_STREAM_TYPE.toString(16);\n\n    if (settings.descriptor) {\n      for (i = 0; i < settings.descriptor.length; i++) {\n        this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n      }\n    }\n\n    this.push = function (chunk) {\n      var tag, frameStart, frameSize, frame, i, frameHeader;\n\n      if (chunk.type !== 'timed-metadata') {\n        return;\n      } // if data_alignment_indicator is set in the PES header,\n      // we must have the start of a new ID3 tag. Assume anything\n      // remaining in the buffer was malformed and throw it out\n\n\n      if (chunk.dataAlignmentIndicator) {\n        bufferSize = 0;\n        buffer.length = 0;\n      } // ignore events that don't look like ID3 data\n\n\n      if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== 'I'.charCodeAt(0) || chunk.data[1] !== 'D'.charCodeAt(0) || chunk.data[2] !== '3'.charCodeAt(0))) {\n        this.trigger('log', {\n          level: 'warn',\n          message: 'Skipping unrecognized metadata packet'\n        });\n        return;\n      } // add this chunk to the data we've collected so far\n\n\n      buffer.push(chunk);\n      bufferSize += chunk.data.byteLength; // grab the size of the entire frame from the ID3 header\n\n      if (buffer.length === 1) {\n        // the frame size is transmitted as a 28-bit integer in the\n        // last four bytes of the ID3 header.\n        // The most significant bit of each byte is dropped and the\n        // results concatenated to recover the actual value.\n        tagSize = parseSyncSafeInteger$1(chunk.data.subarray(6, 10)); // ID3 reports the tag size excluding the header but it's more\n        // convenient for our comparisons to include it\n\n        tagSize += 10;\n      } // if the entire frame has not arrived, wait for more data\n\n\n      if (bufferSize < tagSize) {\n        return;\n      } // collect the entire frame so it can be parsed\n\n\n      tag = {\n        data: new Uint8Array(tagSize),\n        frames: [],\n        pts: buffer[0].pts,\n        dts: buffer[0].dts\n      };\n\n      for (i = 0; i < tagSize;) {\n        tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n        i += buffer[0].data.byteLength;\n        bufferSize -= buffer[0].data.byteLength;\n        buffer.shift();\n      } // find the start of the first frame and the end of the tag\n\n\n      frameStart = 10;\n\n      if (tag.data[5] & 0x40) {\n        // advance the frame start past the extended header\n        frameStart += 4; // header size field\n\n        frameStart += parseSyncSafeInteger$1(tag.data.subarray(10, 14)); // clip any padding off the end\n\n        tagSize -= parseSyncSafeInteger$1(tag.data.subarray(16, 20));\n      } // parse one or more ID3 frames\n      // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n      do {\n        // determine the number of bytes in this frame\n        frameSize = parseSyncSafeInteger$1(tag.data.subarray(frameStart + 4, frameStart + 8));\n\n        if (frameSize < 1) {\n          this.trigger('log', {\n            level: 'warn',\n            message: 'Malformed ID3 frame encountered. Skipping remaining metadata parsing.'\n          }); // If the frame is malformed, don't parse any further frames but allow previous valid parsed frames\n          // to be sent along.\n\n          break;\n        }\n\n        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);\n        frame = {\n          id: frameHeader,\n          data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n        };\n        frame.key = frame.id; // parse frame values\n\n        if (frameParsers[frame.id]) {\n          // use frame specific parser\n          frameParsers[frame.id](frame);\n        } else if (frame.id[0] === 'T') {\n          // use text frame generic parser\n          frameParsers['T*'](frame);\n        } else if (frame.id[0] === 'W') {\n          // use URL link frame generic parser\n          frameParsers['W*'](frame);\n        } // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n\n\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var d = frame.data,\n              size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size; // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n\n          this.trigger('timestamp', frame);\n        }\n\n        tag.frames.push(frame);\n        frameStart += 10; // advance past the frame header\n\n        frameStart += frameSize; // advance past the frame body\n      } while (frameStart < tagSize);\n\n      this.trigger('data', tag);\n    };\n  };\n\n  _MetadataStream.prototype = new stream();\n  var metadataStream = _MetadataStream;\n\n  var TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream; // object types\n\n  var _TransportPacketStream, _TransportParseStream, _ElementaryStream; // constants\n\n\n  var MP2T_PACKET_LENGTH$1 = 188,\n      // bytes\n  SYNC_BYTE$1 = 0x47;\n  /**\n   * Splits an incoming stream of binary data into MPEG-2 Transport\n   * Stream packets.\n   */\n\n  _TransportPacketStream = function TransportPacketStream() {\n    var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1),\n        bytesInBuffer = 0;\n\n    _TransportPacketStream.prototype.init.call(this); // Deliver new bytes to the stream.\n\n    /**\n     * Split a stream of data into M2TS packets\n    **/\n\n\n    this.push = function (bytes) {\n      var startIndex = 0,\n          endIndex = MP2T_PACKET_LENGTH$1,\n          everything; // If there are bytes remaining from the last segment, prepend them to the\n      // bytes that were pushed in\n\n      if (bytesInBuffer) {\n        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n        everything.set(buffer.subarray(0, bytesInBuffer));\n        everything.set(bytes, bytesInBuffer);\n        bytesInBuffer = 0;\n      } else {\n        everything = bytes;\n      } // While we have enough data for a packet\n\n\n      while (endIndex < everything.byteLength) {\n        // Look for a pair of start and end sync bytes in the data..\n        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {\n          // We found a packet so emit it and jump one whole packet forward in\n          // the stream\n          this.trigger('data', everything.subarray(startIndex, endIndex));\n          startIndex += MP2T_PACKET_LENGTH$1;\n          endIndex += MP2T_PACKET_LENGTH$1;\n          continue;\n        } // If we get here, we have somehow become de-synchronized and we need to step\n        // forward one byte at a time until we find a pair of sync bytes that denote\n        // a packet\n\n\n        startIndex++;\n        endIndex++;\n      } // If there was some data left over at the end of the segment that couldn't\n      // possibly be a whole packet, keep it because it might be the start of a packet\n      // that continues in the next segment\n\n\n      if (startIndex < everything.byteLength) {\n        buffer.set(everything.subarray(startIndex), 0);\n        bytesInBuffer = everything.byteLength - startIndex;\n      }\n    };\n    /**\n     * Passes identified M2TS packets to the TransportParseStream to be parsed\n    **/\n\n\n    this.flush = function () {\n      // If the buffer contains a whole packet when we are being flushed, emit it\n      // and empty the buffer. Otherwise hold onto the data because it may be\n      // important for decoding the next segment\n      if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {\n        this.trigger('data', buffer);\n        bytesInBuffer = 0;\n      }\n\n      this.trigger('done');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline');\n    };\n\n    this.reset = function () {\n      bytesInBuffer = 0;\n      this.trigger('reset');\n    };\n  };\n\n  _TransportPacketStream.prototype = new stream();\n  /**\n   * Accepts an MP2T TransportPacketStream and emits data events with parsed\n   * forms of the individual transport stream packets.\n   */\n\n  _TransportParseStream = function TransportParseStream() {\n    var parsePsi, parsePat, parsePmt, self;\n\n    _TransportParseStream.prototype.init.call(this);\n\n    self = this;\n    this.packetsWaitingForPmt = [];\n    this.programMapTable = undefined;\n\n    parsePsi = function parsePsi(payload, psi) {\n      var offset = 0; // PSI packets may be split into multiple sections and those\n      // sections may be split into multiple packets. If a PSI\n      // section starts in this packet, the payload_unit_start_indicator\n      // will be true and the first byte of the payload will indicate\n      // the offset from the current position to the start of the\n      // section.\n\n      if (psi.payloadUnitStartIndicator) {\n        offset += payload[offset] + 1;\n      }\n\n      if (psi.type === 'pat') {\n        parsePat(payload.subarray(offset), psi);\n      } else {\n        parsePmt(payload.subarray(offset), psi);\n      }\n    };\n\n    parsePat = function parsePat(payload, pat) {\n      pat.section_number = payload[7]; // eslint-disable-line camelcase\n\n      pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n      // skip the PSI header and parse the first PMT entry\n\n      self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n      pat.pmtPid = self.pmtPid;\n    };\n    /**\n     * Parse out the relevant fields of a Program Map Table (PMT).\n     * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n     * packet. The first byte in this array should be the table_id\n     * field.\n     * @param pmt {object} the object that should be decorated with\n     * fields parsed from the PMT.\n     */\n\n\n    parsePmt = function parsePmt(payload, pmt) {\n      var sectionLength, tableEnd, programInfoLength, offset; // PMTs can be sent ahead of the time when they should actually\n      // take effect. We don't believe this should ever be the case\n      // for HLS but we'll ignore \"forward\" PMT declarations if we see\n      // them. Future PMT declarations have the current_next_indicator\n      // set to zero.\n\n      if (!(payload[5] & 0x01)) {\n        return;\n      } // overwrite any existing program map table\n\n\n      self.programMapTable = {\n        video: null,\n        audio: null,\n        'timed-metadata': {}\n      }; // the mapping table ends at the end of the current section\n\n      sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n      tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n      // long the program info descriptors are\n\n      programInfoLength = (payload[10] & 0x0f) << 8 | payload[11]; // advance the offset to the first entry in the mapping table\n\n      offset = 12 + programInfoLength;\n\n      while (offset < tableEnd) {\n        var streamType = payload[offset];\n        var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2]; // only map a single elementary_pid for audio and video stream types\n        // TODO: should this be done for metadata too? for now maintain behavior of\n        //       multiple metadata streams\n\n        if (streamType === streamTypes.H264_STREAM_TYPE && self.programMapTable.video === null) {\n          self.programMapTable.video = pid;\n        } else if (streamType === streamTypes.ADTS_STREAM_TYPE && self.programMapTable.audio === null) {\n          self.programMapTable.audio = pid;\n        } else if (streamType === streamTypes.METADATA_STREAM_TYPE) {\n          // map pid to stream type for metadata streams\n          self.programMapTable['timed-metadata'][pid] = streamType;\n        } // move to the next table entry\n        // skip past the elementary stream descriptors, if present\n\n\n        offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n      } // record the map on the packet as well\n\n\n      pmt.programMapTable = self.programMapTable;\n    };\n    /**\n     * Deliver a new MP2T packet to the next stream in the pipeline.\n     */\n\n\n    this.push = function (packet) {\n      var result = {},\n          offset = 4;\n      result.payloadUnitStartIndicator = !!(packet[1] & 0x40); // pid is a 13-bit field starting at the last bit of packet[1]\n\n      result.pid = packet[1] & 0x1f;\n      result.pid <<= 8;\n      result.pid |= packet[2]; // if an adaption field is present, its length is specified by the\n      // fifth byte of the TS packet header. The adaptation field is\n      // used to add stuffing to PES packets that don't fill a complete\n      // TS packet, and to specify some forms of timing and control data\n      // that we do not currently use.\n\n      if ((packet[3] & 0x30) >>> 4 > 0x01) {\n        offset += packet[offset] + 1;\n      } // parse the rest of the packet based on the type\n\n\n      if (result.pid === 0) {\n        result.type = 'pat';\n        parsePsi(packet.subarray(offset), result);\n        this.trigger('data', result);\n      } else if (result.pid === this.pmtPid) {\n        result.type = 'pmt';\n        parsePsi(packet.subarray(offset), result);\n        this.trigger('data', result); // if there are any packets waiting for a PMT to be found, process them now\n\n        while (this.packetsWaitingForPmt.length) {\n          this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n        }\n      } else if (this.programMapTable === undefined) {\n        // When we have not seen a PMT yet, defer further processing of\n        // PES packets until one has been parsed\n        this.packetsWaitingForPmt.push([packet, offset, result]);\n      } else {\n        this.processPes_(packet, offset, result);\n      }\n    };\n\n    this.processPes_ = function (packet, offset, result) {\n      // set the appropriate stream type\n      if (result.pid === this.programMapTable.video) {\n        result.streamType = streamTypes.H264_STREAM_TYPE;\n      } else if (result.pid === this.programMapTable.audio) {\n        result.streamType = streamTypes.ADTS_STREAM_TYPE;\n      } else {\n        // if not video or audio, it is timed-metadata or unknown\n        // if unknown, streamType will be undefined\n        result.streamType = this.programMapTable['timed-metadata'][result.pid];\n      }\n\n      result.type = 'pes';\n      result.data = packet.subarray(offset);\n      this.trigger('data', result);\n    };\n  };\n\n  _TransportParseStream.prototype = new stream();\n  _TransportParseStream.STREAM_TYPES = {\n    h264: 0x1b,\n    adts: 0x0f\n  };\n  /**\n   * Reconsistutes program elementary stream (PES) packets from parsed\n   * transport stream packets. That is, if you pipe an\n   * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n   * events will be events which capture the bytes for individual PES\n   * packets plus relevant metadata that has been extracted from the\n   * container.\n   */\n\n  _ElementaryStream = function ElementaryStream() {\n    var self = this,\n        segmentHadPmt = false,\n        // PES packet fragments\n    video = {\n      data: [],\n      size: 0\n    },\n        audio = {\n      data: [],\n      size: 0\n    },\n        timedMetadata = {\n      data: [],\n      size: 0\n    },\n        programMapTable,\n        parsePes = function parsePes(payload, pes) {\n      var ptsDtsFlags;\n      var startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2]; // default to an empty array\n\n      pes.data = new Uint8Array(); // In certain live streams, the start of a TS fragment has ts packets\n      // that are frame data that is continuing from the previous fragment. This\n      // is to check that the pes data is the start of a new pes payload\n\n      if (startPrefix !== 1) {\n        return;\n      } // get the packet length, this will be 0 for video\n\n\n      pes.packetLength = 6 + (payload[4] << 8 | payload[5]); // find out if this packets starts a new keyframe\n\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0; // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n\n      ptsDtsFlags = payload[7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n\n      if (ptsDtsFlags & 0xC0) {\n        // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n        pes.pts = (payload[9] & 0x0E) << 27 | (payload[10] & 0xFF) << 20 | (payload[11] & 0xFE) << 12 | (payload[12] & 0xFF) << 5 | (payload[13] & 0xFE) >>> 3;\n        pes.pts *= 4; // Left shift by 2\n\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n\n        pes.dts = pes.pts;\n\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (payload[14] & 0x0E) << 27 | (payload[15] & 0xFF) << 20 | (payload[16] & 0xFE) << 12 | (payload[17] & 0xFF) << 5 | (payload[18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      } // the data section starts immediately after the PES header.\n      // pes_header_data_length specifies the number of header bytes\n      // that follow the last byte of the field.\n\n\n      pes.data = payload.subarray(9 + payload[8]);\n    },\n\n    /**\n      * Pass completely parsed PES packets to the next stream in the pipeline\n     **/\n    flushStream = function flushStream(stream, type, forceFlush) {\n      var packetData = new Uint8Array(stream.size),\n          event = {\n        type: type\n      },\n          i = 0,\n          offset = 0,\n          packetFlushable = false,\n          fragment; // do nothing if there is not enough buffered data for a complete\n      // PES header\n\n      if (!stream.data.length || stream.size < 9) {\n        return;\n      }\n\n      event.trackId = stream.data[0].pid; // reassemble the packet\n\n      for (i = 0; i < stream.data.length; i++) {\n        fragment = stream.data[i];\n        packetData.set(fragment.data, offset);\n        offset += fragment.data.byteLength;\n      } // parse assembled packet's PES header\n\n\n      parsePes(packetData, event); // non-video PES packets MUST have a non-zero PES_packet_length\n      // check that there is enough stream data to fill the packet\n\n      packetFlushable = type === 'video' || event.packetLength <= stream.size; // flush pending packets if the conditions are right\n\n      if (forceFlush || packetFlushable) {\n        stream.size = 0;\n        stream.data.length = 0;\n      } // only emit packets that are complete. this is to avoid assembling\n      // incomplete PES packets due to poor segmentation\n\n\n      if (packetFlushable) {\n        self.trigger('data', event);\n      }\n    };\n\n    _ElementaryStream.prototype.init.call(this);\n    /**\n     * Identifies M2TS packet types and parses PES packets using metadata\n     * parsed from the PMT\n     **/\n\n\n    this.push = function (data) {\n      ({\n        pat: function pat() {// we have to wait for the PMT to arrive as well before we\n          // have any meaningful metadata\n        },\n        pes: function pes() {\n          var stream, streamType;\n\n          switch (data.streamType) {\n            case streamTypes.H264_STREAM_TYPE:\n              stream = video;\n              streamType = 'video';\n              break;\n\n            case streamTypes.ADTS_STREAM_TYPE:\n              stream = audio;\n              streamType = 'audio';\n              break;\n\n            case streamTypes.METADATA_STREAM_TYPE:\n              stream = timedMetadata;\n              streamType = 'timed-metadata';\n              break;\n\n            default:\n              // ignore unknown stream types\n              return;\n          } // if a new packet is starting, we can flush the completed\n          // packet\n\n\n          if (data.payloadUnitStartIndicator) {\n            flushStream(stream, streamType, true);\n          } // buffer this fragment until we are sure we've received the\n          // complete payload\n\n\n          stream.data.push(data);\n          stream.size += data.data.byteLength;\n        },\n        pmt: function pmt() {\n          var event = {\n            type: 'metadata',\n            tracks: []\n          };\n          programMapTable = data.programMapTable; // translate audio and video streams to tracks\n\n          if (programMapTable.video !== null) {\n            event.tracks.push({\n              timelineStartInfo: {\n                baseMediaDecodeTime: 0\n              },\n              id: +programMapTable.video,\n              codec: 'avc',\n              type: 'video'\n            });\n          }\n\n          if (programMapTable.audio !== null) {\n            event.tracks.push({\n              timelineStartInfo: {\n                baseMediaDecodeTime: 0\n              },\n              id: +programMapTable.audio,\n              codec: 'adts',\n              type: 'audio'\n            });\n          }\n\n          segmentHadPmt = true;\n          self.trigger('data', event);\n        }\n      })[data.type]();\n    };\n\n    this.reset = function () {\n      video.size = 0;\n      video.data.length = 0;\n      audio.size = 0;\n      audio.data.length = 0;\n      this.trigger('reset');\n    };\n    /**\n     * Flush any remaining input. Video PES packets may be of variable\n     * length. Normally, the start of a new video packet can trigger the\n     * finalization of the previous packet. That is not possible if no\n     * more video is forthcoming, however. In that case, some other\n     * mechanism (like the end of the file) has to be employed. When it is\n     * clear that no additional data is forthcoming, calling this method\n     * will flush the buffered packets.\n     */\n\n\n    this.flushStreams_ = function () {\n      // !!THIS ORDER IS IMPORTANT!!\n      // video first then audio\n      flushStream(video, 'video');\n      flushStream(audio, 'audio');\n      flushStream(timedMetadata, 'timed-metadata');\n    };\n\n    this.flush = function () {\n      // if on flush we haven't had a pmt emitted\n      // and we have a pmt to emit. emit the pmt\n      // so that we trigger a trackinfo downstream.\n      if (!segmentHadPmt && programMapTable) {\n        var pmt = {\n          type: 'metadata',\n          tracks: []\n        }; // translate audio and video streams to tracks\n\n        if (programMapTable.video !== null) {\n          pmt.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n\n        if (programMapTable.audio !== null) {\n          pmt.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        self.trigger('data', pmt);\n      }\n\n      segmentHadPmt = false;\n      this.flushStreams_();\n      this.trigger('done');\n    };\n  };\n\n  _ElementaryStream.prototype = new stream();\n  var m2ts$1 = {\n    PAT_PID: 0x0000,\n    MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,\n    TransportPacketStream: _TransportPacketStream,\n    TransportParseStream: _TransportParseStream,\n    ElementaryStream: _ElementaryStream,\n    TimestampRolloverStream: TimestampRolloverStream,\n    CaptionStream: captionStream.CaptionStream,\n    Cea608Stream: captionStream.Cea608Stream,\n    Cea708Stream: captionStream.Cea708Stream,\n    MetadataStream: metadataStream\n  };\n\n  for (var type in streamTypes) {\n    if (streamTypes.hasOwnProperty(type)) {\n      m2ts$1[type] = streamTypes[type];\n    }\n  }\n\n  var m2ts_1 = m2ts$1;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * Utilities to detect basic properties and metadata about Aac data.\n   */\n\n  var ADTS_SAMPLING_FREQUENCIES = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\n  var parseId3TagSize = function parseId3TagSize(header, byteIndex) {\n    var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9],\n        flags = header[byteIndex + 5],\n        footerPresent = (flags & 16) >> 4; // if we get a negative returnSize clamp it to 0\n\n    returnSize = returnSize >= 0 ? returnSize : 0;\n\n    if (footerPresent) {\n      return returnSize + 20;\n    }\n\n    return returnSize + 10;\n  };\n\n  var getId3Offset = function getId3Offset(data, offset) {\n    if (data.length - offset < 10 || data[offset] !== 'I'.charCodeAt(0) || data[offset + 1] !== 'D'.charCodeAt(0) || data[offset + 2] !== '3'.charCodeAt(0)) {\n      return offset;\n    }\n\n    offset += parseId3TagSize(data, offset);\n    return getId3Offset(data, offset);\n  }; // TODO: use vhs-utils\n\n\n  var isLikelyAacData$2 = function isLikelyAacData(data) {\n    var offset = getId3Offset(data, 0);\n    return data.length >= offset + 2 && (data[offset] & 0xFF) === 0xFF && (data[offset + 1] & 0xF0) === 0xF0 && // verify that the 2 layer bits are 0, aka this\n    // is not mp3 data but aac data.\n    (data[offset + 1] & 0x16) === 0x10;\n  };\n\n  var parseSyncSafeInteger = function parseSyncSafeInteger(data) {\n    return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];\n  }; // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n\n\n  var percentEncode = function percentEncode(bytes, start, end) {\n    var i,\n        result = '';\n\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n\n    return result;\n  }; // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n\n\n  var parseIso88591 = function parseIso88591(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  };\n\n  var parseAdtsSize = function parseAdtsSize(header, byteIndex) {\n    var lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n        middle = header[byteIndex + 4] << 3,\n        highTwo = header[byteIndex + 3] & 0x3 << 11;\n    return highTwo | middle | lowThree;\n  };\n\n  var parseType$1 = function parseType(header, byteIndex) {\n    if (header[byteIndex] === 'I'.charCodeAt(0) && header[byteIndex + 1] === 'D'.charCodeAt(0) && header[byteIndex + 2] === '3'.charCodeAt(0)) {\n      return 'timed-metadata';\n    } else if (header[byteIndex] & 0xff === 0xff && (header[byteIndex + 1] & 0xf0) === 0xf0) {\n      return 'audio';\n    }\n\n    return null;\n  };\n\n  var parseSampleRate = function parseSampleRate(packet) {\n    var i = 0;\n\n    while (i + 5 < packet.length) {\n      if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n        // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n        i++;\n        continue;\n      }\n\n      return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n    }\n\n    return null;\n  };\n\n  var parseAacTimestamp = function parseAacTimestamp(packet) {\n    var frameStart, frameSize, frame, frameHeader; // find the start of the first frame and the end of the tag\n\n    frameStart = 10;\n\n    if (packet[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n\n      frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n    } // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n\n\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n\n      if (frameSize < 1) {\n        return null;\n      }\n\n      frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);\n\n      if (frameHeader === 'PRIV') {\n        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n        for (var i = 0; i < frame.byteLength; i++) {\n          if (frame[i] === 0) {\n            var owner = parseIso88591(frame, 0, i);\n\n            if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n              var d = frame.subarray(i + 1);\n              var size = (d[3] & 0x01) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;\n              size *= 4;\n              size += d[7] & 0x03;\n              return size;\n            }\n\n            break;\n          }\n        }\n      }\n\n      frameStart += 10; // advance past the frame header\n\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < packet.byteLength);\n\n    return null;\n  };\n\n  var utils = {\n    isLikelyAacData: isLikelyAacData$2,\n    parseId3TagSize: parseId3TagSize,\n    parseAdtsSize: parseAdtsSize,\n    parseType: parseType$1,\n    parseSampleRate: parseSampleRate,\n    parseAacTimestamp: parseAacTimestamp\n  };\n\n  var _AacStream;\n  /**\n   * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n   */\n\n\n  _AacStream = function AacStream() {\n    var everything = new Uint8Array(),\n        timeStamp = 0;\n\n    _AacStream.prototype.init.call(this);\n\n    this.setTimestamp = function (timestamp) {\n      timeStamp = timestamp;\n    };\n\n    this.push = function (bytes) {\n      var frameSize = 0,\n          byteIndex = 0,\n          bytesLeft,\n          chunk,\n          packet,\n          tempLength; // If there are bytes remaining from the last segment, prepend them to the\n      // bytes that were pushed in\n\n      if (everything.length) {\n        tempLength = everything.length;\n        everything = new Uint8Array(bytes.byteLength + tempLength);\n        everything.set(everything.subarray(0, tempLength));\n        everything.set(bytes, tempLength);\n      } else {\n        everything = bytes;\n      }\n\n      while (everything.length - byteIndex >= 3) {\n        if (everything[byteIndex] === 'I'.charCodeAt(0) && everything[byteIndex + 1] === 'D'.charCodeAt(0) && everything[byteIndex + 2] === '3'.charCodeAt(0)) {\n          // Exit early because we don't have enough to parse\n          // the ID3 tag header\n          if (everything.length - byteIndex < 10) {\n            break;\n          } // check framesize\n\n\n          frameSize = utils.parseId3TagSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n          // Add to byteIndex to support multiple ID3 tags in sequence\n\n          if (byteIndex + frameSize > everything.length) {\n            break;\n          }\n\n          chunk = {\n            type: 'timed-metadata',\n            data: everything.subarray(byteIndex, byteIndex + frameSize)\n          };\n          this.trigger('data', chunk);\n          byteIndex += frameSize;\n          continue;\n        } else if ((everything[byteIndex] & 0xff) === 0xff && (everything[byteIndex + 1] & 0xf0) === 0xf0) {\n          // Exit early because we don't have enough to parse\n          // the ADTS frame header\n          if (everything.length - byteIndex < 7) {\n            break;\n          }\n\n          frameSize = utils.parseAdtsSize(everything, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (byteIndex + frameSize > everything.length) {\n            break;\n          }\n\n          packet = {\n            type: 'audio',\n            data: everything.subarray(byteIndex, byteIndex + frameSize),\n            pts: timeStamp,\n            dts: timeStamp\n          };\n          this.trigger('data', packet);\n          byteIndex += frameSize;\n          continue;\n        }\n\n        byteIndex++;\n      }\n\n      bytesLeft = everything.length - byteIndex;\n\n      if (bytesLeft > 0) {\n        everything = everything.subarray(byteIndex);\n      } else {\n        everything = new Uint8Array();\n      }\n    };\n\n    this.reset = function () {\n      everything = new Uint8Array();\n      this.trigger('reset');\n    };\n\n    this.endTimeline = function () {\n      everything = new Uint8Array();\n      this.trigger('endedtimeline');\n    };\n  };\n\n  _AacStream.prototype = new stream();\n  var aac = _AacStream;\n\n  // constants\n  var AUDIO_PROPERTIES = ['audioobjecttype', 'channelcount', 'samplerate', 'samplingfrequencyindex', 'samplesize'];\n  var audioProperties = AUDIO_PROPERTIES;\n\n  var VIDEO_PROPERTIES = ['width', 'height', 'profileIdc', 'levelIdc', 'profileCompatibility', 'sarRatio'];\n  var videoProperties = VIDEO_PROPERTIES;\n\n  var H264Stream$1 = h264.H264Stream;\n  var isLikelyAacData$1 = utils.isLikelyAacData;\n  var ONE_SECOND_IN_TS$2 = clock.ONE_SECOND_IN_TS; // object types\n\n  var _VideoSegmentStream$1, _AudioSegmentStream$1, _Transmuxer$1, _CoalesceStream;\n\n  var retriggerForStream = function retriggerForStream(key, event) {\n    event.stream = key;\n    this.trigger('log', event);\n  };\n\n  var addPipelineLogRetriggers = function addPipelineLogRetriggers(transmuxer, pipeline) {\n    var keys = Object.keys(pipeline);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i]; // skip non-stream keys and headOfPipeline\n      // which is just a duplicate\n\n      if (key === 'headOfPipeline' || !pipeline[key].on) {\n        continue;\n      }\n\n      pipeline[key].on('log', retriggerForStream.bind(transmuxer, key));\n    }\n  };\n  /**\n   * Compare two arrays (even typed) for same-ness\n   */\n\n\n  var arrayEquals = function arrayEquals(a, b) {\n    var i;\n\n    if (a.length !== b.length) {\n      return false;\n    } // compare the value of each element in the array\n\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  var generateSegmentTimingInfo = function generateSegmentTimingInfo(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {\n    var ptsOffsetFromDts = startPts - startDts,\n        decodeDuration = endDts - startDts,\n        presentationDuration = endPts - startPts; // The PTS and DTS values are based on the actual stream times from the segment,\n    // however, the player time values will reflect a start from the baseMediaDecodeTime.\n    // In order to provide relevant values for the player times, base timing info on the\n    // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n\n    return {\n      start: {\n        dts: baseMediaDecodeTime,\n        pts: baseMediaDecodeTime + ptsOffsetFromDts\n      },\n      end: {\n        dts: baseMediaDecodeTime + decodeDuration,\n        pts: baseMediaDecodeTime + presentationDuration\n      },\n      prependedContentDuration: prependedContentDuration,\n      baseMediaDecodeTime: baseMediaDecodeTime\n    };\n  };\n  /**\n   * Constructs a single-track, ISO BMFF media segment from AAC data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   * @param track {object} track metadata configuration\n   * @param options {object} transmuxer options object\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n\n  _AudioSegmentStream$1 = function AudioSegmentStream(track, options) {\n    var adtsFrames = [],\n        sequenceNumber,\n        earliestAllowedDts = 0,\n        audioAppendStartTs = 0,\n        videoBaseMediaDecodeTime = Infinity;\n    options = options || {};\n    sequenceNumber = options.firstSequenceNumber || 0;\n\n    _AudioSegmentStream$1.prototype.init.call(this);\n\n    this.push = function (data) {\n      trackDecodeInfo.collectDtsInfo(track, data);\n\n      if (track) {\n        audioProperties.forEach(function (prop) {\n          track[prop] = data[prop];\n        });\n      } // buffer audio data until end() is called\n\n\n      adtsFrames.push(data);\n    };\n\n    this.setEarliestDts = function (earliestDts) {\n      earliestAllowedDts = earliestDts;\n    };\n\n    this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      videoBaseMediaDecodeTime = baseMediaDecodeTime;\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      audioAppendStartTs = timestamp;\n    };\n\n    this.flush = function () {\n      var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed; // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        this.trigger('done', 'AudioSegmentStream');\n        return;\n      }\n\n      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps); // amount of audio filled but the value is in video clock rather than audio clock\n\n      videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n      // samples (that is, adts frames) in the audio data\n\n      track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n      mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\n      adtsFrames = [];\n      moof = mp4Generator.moof(sequenceNumber, [track]);\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // bump the sequence number for next time\n\n      sequenceNumber++;\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      trackDecodeInfo.clearDtsInfo(track);\n      frameDuration = Math.ceil(ONE_SECOND_IN_TS$2 * 1024 / track.samplerate); // TODO this check was added to maintain backwards compatibility (particularly with\n      // tests) on adding the timingInfo event. However, it seems unlikely that there's a\n      // valid use-case where an init segment/data should be triggered without associated\n      // frames. Leaving for now, but should be looked into.\n\n      if (frames.length) {\n        segmentDuration = frames.length * frameDuration;\n        this.trigger('segmentTimingInfo', generateSegmentTimingInfo( // The audio track's baseMediaDecodeTime is in audio clock cycles, but the\n        // frame info is in video clock cycles. Convert to match expectation of\n        // listeners (that all timestamps will be based on video clock cycles).\n        clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), // frame times are already in video clock, as is segment duration\n        frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));\n        this.trigger('timingInfo', {\n          start: frames[0].pts,\n          end: frames[0].pts + segmentDuration\n        });\n      }\n\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.reset = function () {\n      trackDecodeInfo.clearDtsInfo(track);\n      adtsFrames = [];\n      this.trigger('reset');\n    };\n  };\n\n  _AudioSegmentStream$1.prototype = new stream();\n  /**\n   * Constructs a single-track, ISO BMFF media segment from H264 data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   * @param track {object} track metadata configuration\n   * @param options {object} transmuxer options object\n   * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n   *        gopsToAlignWith list when attempting to align gop pts\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at 0.\n   */\n\n  _VideoSegmentStream$1 = function VideoSegmentStream(track, options) {\n    var sequenceNumber,\n        nalUnits = [],\n        gopsToAlignWith = [],\n        config,\n        pps;\n    options = options || {};\n    sequenceNumber = options.firstSequenceNumber || 0;\n\n    _VideoSegmentStream$1.prototype.init.call(this);\n\n    delete track.minPTS;\n    this.gopCache_ = [];\n    /**\n      * Constructs a ISO BMFF segment given H264 nalUnits\n      * @param {Object} nalUnit A data event representing a nalUnit\n      * @param {String} nalUnit.nalUnitType\n      * @param {Object} nalUnit.config Properties for a mp4 track\n      * @param {Uint8Array} nalUnit.data The nalUnit bytes\n      * @see lib/codecs/h264.js\n     **/\n\n    this.push = function (nalUnit) {\n      trackDecodeInfo.collectDtsInfo(track, nalUnit); // record the track config\n\n      if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n        config = nalUnit.config;\n        track.sps = [nalUnit.data];\n        videoProperties.forEach(function (prop) {\n          track[prop] = config[prop];\n        }, this);\n      }\n\n      if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n        pps = nalUnit.data;\n        track.pps = [nalUnit.data];\n      } // buffer video until flush() is called\n\n\n      nalUnits.push(nalUnit);\n    };\n    /**\n      * Pass constructed ISO BMFF track and boxes on to the\n      * next stream in the pipeline\n     **/\n\n\n    this.flush = function () {\n      var frames,\n          gopForFusion,\n          gops,\n          moof,\n          mdat,\n          boxes,\n          prependedContentDuration = 0,\n          firstGop,\n          lastGop; // Throw away nalUnits at the start of the byte stream until\n      // we find the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // Return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      } // Organize the raw nal-units into arrays that represent\n      // higher-level constructs such as frames and gops\n      // (group-of-pictures)\n\n\n      frames = frameUtils.groupNalsIntoFrames(nalUnits);\n      gops = frameUtils.groupFramesIntoGops(frames); // If the first frame of this fragment is not a keyframe we have\n      // a problem since MSE (on Chrome) requires a leading keyframe.\n      //\n      // We have two approaches to repairing this situation:\n      // 1) GOP-FUSION:\n      //    This is where we keep track of the GOPS (group-of-pictures)\n      //    from previous fragments and attempt to find one that we can\n      //    prepend to the current fragment in order to create a valid\n      //    fragment.\n      // 2) KEYFRAME-PULLING:\n      //    Here we search for the first keyframe in the fragment and\n      //    throw away all the frames between the start of the fragment\n      //    and that keyframe. We then extend the duration and pull the\n      //    PTS of the keyframe forward so that it covers the time range\n      //    of the frames that were disposed of.\n      //\n      // #1 is far prefereable over #2 which can cause \"stuttering\" but\n      // requires more things to be just right.\n\n      if (!gops[0][0].keyFrame) {\n        // Search for a gop for fusion from our gopCache\n        gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n        if (gopForFusion) {\n          // in order to provide more accurate timing information about the segment, save\n          // the number of seconds prepended to the original segment due to GOP fusion\n          prependedContentDuration = gopForFusion.duration;\n          gops.unshift(gopForFusion); // Adjust Gops' metadata to account for the inclusion of the\n          // new gop at the beginning\n\n          gops.byteLength += gopForFusion.byteLength;\n          gops.nalCount += gopForFusion.nalCount;\n          gops.pts = gopForFusion.pts;\n          gops.dts = gopForFusion.dts;\n          gops.duration += gopForFusion.duration;\n        } else {\n          // If we didn't find a candidate gop fall back to keyframe-pulling\n          gops = frameUtils.extendFirstKeyFrame(gops);\n        }\n      } // Trim gops to align with gopsToAlignWith\n\n\n      if (gopsToAlignWith.length) {\n        var alignedGops;\n\n        if (options.alignGopsAtEnd) {\n          alignedGops = this.alignGopsAtEnd_(gops);\n        } else {\n          alignedGops = this.alignGopsAtStart_(gops);\n        }\n\n        if (!alignedGops) {\n          // save all the nals in the last GOP into the gop cache\n          this.gopCache_.unshift({\n            gop: gops.pop(),\n            pps: track.pps,\n            sps: track.sps\n          }); // Keep a maximum of 6 GOPs in the cache\n\n          this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n          nalUnits = []; // return early no gops can be aligned with desired gopsToAlignWith\n\n          this.resetStream_();\n          this.trigger('done', 'VideoSegmentStream');\n          return;\n        } // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n        // when recalculated before sending off to CoalesceStream\n\n\n        trackDecodeInfo.clearDtsInfo(track);\n        gops = alignedGops;\n      }\n\n      trackDecodeInfo.collectDtsInfo(track, gops); // First, we have to build the index from byte locations to\n      // samples (that is, frames) in the video data\n\n      track.samples = frameUtils.generateSampleTable(gops); // Concatenate the video data and construct the mdat\n\n      mdat = mp4Generator.mdat(frameUtils.concatenateNalData(gops));\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n      this.trigger('processedGopsInfo', gops.map(function (gop) {\n        return {\n          pts: gop.pts,\n          dts: gop.dts,\n          byteLength: gop.byteLength\n        };\n      }));\n      firstGop = gops[0];\n      lastGop = gops[gops.length - 1];\n      this.trigger('segmentTimingInfo', generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));\n      this.trigger('timingInfo', {\n        start: gops[0].pts,\n        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration\n      }); // save all the nals in the last GOP into the gop cache\n\n      this.gopCache_.unshift({\n        gop: gops.pop(),\n        pps: track.pps,\n        sps: track.sps\n      }); // Keep a maximum of 6 GOPs in the cache\n\n      this.gopCache_.length = Math.min(6, this.gopCache_.length); // Clear nalUnits\n\n      nalUnits = [];\n      this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n      this.trigger('timelineStartInfo', track.timelineStartInfo);\n      moof = mp4Generator.moof(sequenceNumber, [track]); // it would be great to allocate this array up front instead of\n      // throwing away hundreds of media segment fragments\n\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength); // Bump the sequence number for next time\n\n      sequenceNumber++;\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n      this.resetStream_(); // Continue with the flush process now\n\n      this.trigger('done', 'VideoSegmentStream');\n    };\n\n    this.reset = function () {\n      this.resetStream_();\n      nalUnits = [];\n      this.gopCache_.length = 0;\n      gopsToAlignWith.length = 0;\n      this.trigger('reset');\n    };\n\n    this.resetStream_ = function () {\n      trackDecodeInfo.clearDtsInfo(track); // reset config and pps because they may differ across segments\n      // for instance, when we are rendition switching\n\n      config = undefined;\n      pps = undefined;\n    }; // Search for a candidate Gop for gop-fusion from the gop cache and\n    // return it or return null if no good candidate was found\n\n\n    this.getGopForFusion_ = function (nalUnit) {\n      var halfSecond = 45000,\n          // Half-a-second in a 90khz clock\n      allowableOverlap = 10000,\n          // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n          dtsDistance,\n          nearestGopObj,\n          currentGop,\n          currentGopObj,\n          i; // Search for the GOP nearest to the beginning of this nal unit\n\n      for (i = 0; i < this.gopCache_.length; i++) {\n        currentGopObj = this.gopCache_[i];\n        currentGop = currentGopObj.gop; // Reject Gops with different SPS or PPS\n\n        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n          continue;\n        } // Reject Gops that would require a negative baseMediaDecodeTime\n\n\n        if (currentGop.dts < track.timelineStartInfo.dts) {\n          continue;\n        } // The distance between the end of the gop and the start of the nalUnit\n\n\n        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration; // Only consider GOPS that start before the nal unit and end within\n        // a half-second of the nal unit\n\n        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) {\n          // Always use the closest GOP we found if there is more than\n          // one candidate\n          if (!nearestGopObj || nearestDistance > dtsDistance) {\n            nearestGopObj = currentGopObj;\n            nearestDistance = dtsDistance;\n          }\n        }\n      }\n\n      if (nearestGopObj) {\n        return nearestGopObj.gop;\n      }\n\n      return null;\n    }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n    // of gopsToAlignWith starting from the START of the list\n\n\n    this.alignGopsAtStart_ = function (gops) {\n      var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n      byteLength = gops.byteLength;\n      nalCount = gops.nalCount;\n      duration = gops.duration;\n      alignIndex = gopIndex = 0;\n\n      while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n        align = gopsToAlignWith[alignIndex];\n        gop = gops[gopIndex];\n\n        if (align.pts === gop.pts) {\n          break;\n        }\n\n        if (gop.pts > align.pts) {\n          // this current gop starts after the current gop we want to align on, so increment\n          // align index\n          alignIndex++;\n          continue;\n        } // current gop starts before the current gop we want to align on. so increment gop\n        // index\n\n\n        gopIndex++;\n        byteLength -= gop.byteLength;\n        nalCount -= gop.nalCount;\n        duration -= gop.duration;\n      }\n\n      if (gopIndex === 0) {\n        // no gops to trim\n        return gops;\n      }\n\n      if (gopIndex === gops.length) {\n        // all gops trimmed, skip appending all gops\n        return null;\n      }\n\n      alignedGops = gops.slice(gopIndex);\n      alignedGops.byteLength = byteLength;\n      alignedGops.duration = duration;\n      alignedGops.nalCount = nalCount;\n      alignedGops.pts = alignedGops[0].pts;\n      alignedGops.dts = alignedGops[0].dts;\n      return alignedGops;\n    }; // trim gop list to the first gop found that has a matching pts with a gop in the list\n    // of gopsToAlignWith starting from the END of the list\n\n\n    this.alignGopsAtEnd_ = function (gops) {\n      var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n      alignIndex = gopsToAlignWith.length - 1;\n      gopIndex = gops.length - 1;\n      alignEndIndex = null;\n      matchFound = false;\n\n      while (alignIndex >= 0 && gopIndex >= 0) {\n        align = gopsToAlignWith[alignIndex];\n        gop = gops[gopIndex];\n\n        if (align.pts === gop.pts) {\n          matchFound = true;\n          break;\n        }\n\n        if (align.pts > gop.pts) {\n          alignIndex--;\n          continue;\n        }\n\n        if (alignIndex === gopsToAlignWith.length - 1) {\n          // gop.pts is greater than the last alignment candidate. If no match is found\n          // by the end of this loop, we still want to append gops that come after this\n          // point\n          alignEndIndex = gopIndex;\n        }\n\n        gopIndex--;\n      }\n\n      if (!matchFound && alignEndIndex === null) {\n        return null;\n      }\n\n      var trimIndex;\n\n      if (matchFound) {\n        trimIndex = gopIndex;\n      } else {\n        trimIndex = alignEndIndex;\n      }\n\n      if (trimIndex === 0) {\n        return gops;\n      }\n\n      var alignedGops = gops.slice(trimIndex);\n      var metadata = alignedGops.reduce(function (total, gop) {\n        total.byteLength += gop.byteLength;\n        total.duration += gop.duration;\n        total.nalCount += gop.nalCount;\n        return total;\n      }, {\n        byteLength: 0,\n        duration: 0,\n        nalCount: 0\n      });\n      alignedGops.byteLength = metadata.byteLength;\n      alignedGops.duration = metadata.duration;\n      alignedGops.nalCount = metadata.nalCount;\n      alignedGops.pts = alignedGops[0].pts;\n      alignedGops.dts = alignedGops[0].dts;\n      return alignedGops;\n    };\n\n    this.alignGopsWith = function (newGopsToAlignWith) {\n      gopsToAlignWith = newGopsToAlignWith;\n    };\n  };\n\n  _VideoSegmentStream$1.prototype = new stream();\n  /**\n   * A Stream that can combine multiple streams (ie. audio & video)\n   * into a single output segment for MSE. Also supports audio-only\n   * and video-only streams.\n   * @param options {object} transmuxer options object\n   * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n   *        in the source; false to adjust the first segment to start at media timeline start.\n   */\n\n  _CoalesceStream = function CoalesceStream(options, metadataStream) {\n    // Number of Tracks per output segment\n    // If greater than 1, we combine multiple\n    // tracks into a single segment\n    this.numberOfTracks = 0;\n    this.metadataStream = metadataStream;\n    options = options || {};\n\n    if (typeof options.remux !== 'undefined') {\n      this.remuxTracks = !!options.remux;\n    } else {\n      this.remuxTracks = true;\n    }\n\n    if (typeof options.keepOriginalTimestamps === 'boolean') {\n      this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n    } else {\n      this.keepOriginalTimestamps = false;\n    }\n\n    this.pendingTracks = [];\n    this.videoTrack = null;\n    this.pendingBoxes = [];\n    this.pendingCaptions = [];\n    this.pendingMetadata = [];\n    this.pendingBytes = 0;\n    this.emittedTracks = 0;\n\n    _CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n\n    this.push = function (output) {\n      // buffer incoming captions until the associated video segment\n      // finishes\n      if (output.text) {\n        return this.pendingCaptions.push(output);\n      } // buffer incoming id3 tags until the final flush\n\n\n      if (output.frames) {\n        return this.pendingMetadata.push(output);\n      } // Add this track to the list of pending tracks and store\n      // important information required for the construction of\n      // the final segment\n\n\n      this.pendingTracks.push(output.track);\n      this.pendingBytes += output.boxes.byteLength; // TODO: is there an issue for this against chrome?\n      // We unshift audio and push video because\n      // as of Chrome 75 when switching from\n      // one init segment to another if the video\n      // mdat does not appear after the audio mdat\n      // only audio will play for the duration of our transmux.\n\n      if (output.track.type === 'video') {\n        this.videoTrack = output.track;\n        this.pendingBoxes.push(output.boxes);\n      }\n\n      if (output.track.type === 'audio') {\n        this.audioTrack = output.track;\n        this.pendingBoxes.unshift(output.boxes);\n      }\n    };\n  };\n\n  _CoalesceStream.prototype = new stream();\n\n  _CoalesceStream.prototype.flush = function (flushSource) {\n    var offset = 0,\n        event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n        caption,\n        id3,\n        initSegment,\n        timelineStartPts = 0,\n        i;\n\n    if (this.pendingTracks.length < this.numberOfTracks) {\n      if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n        // Return because we haven't received a flush from a data-generating\n        // portion of the segment (meaning that we have only recieved meta-data\n        // or captions.)\n        return;\n      } else if (this.remuxTracks) {\n        // Return until we have enough tracks from the pipeline to remux (if we\n        // are remuxing audio and video into a single MP4)\n        return;\n      } else if (this.pendingTracks.length === 0) {\n        // In the case where we receive a flush without any data having been\n        // received we consider it an emitted track for the purposes of coalescing\n        // `done` events.\n        // We do this for the case where there is an audio and video track in the\n        // segment but no audio data. (seen in several playlists with alternate\n        // audio tracks and no audio present in the main TS segments.)\n        this.emittedTracks++;\n\n        if (this.emittedTracks >= this.numberOfTracks) {\n          this.trigger('done');\n          this.emittedTracks = 0;\n        }\n\n        return;\n      }\n    }\n\n    if (this.videoTrack) {\n      timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n      videoProperties.forEach(function (prop) {\n        event.info[prop] = this.videoTrack[prop];\n      }, this);\n    } else if (this.audioTrack) {\n      timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n      audioProperties.forEach(function (prop) {\n        event.info[prop] = this.audioTrack[prop];\n      }, this);\n    }\n\n    if (this.videoTrack || this.audioTrack) {\n      if (this.pendingTracks.length === 1) {\n        event.type = this.pendingTracks[0].type;\n      } else {\n        event.type = 'combined';\n      }\n\n      this.emittedTracks += this.pendingTracks.length;\n      initSegment = mp4Generator.initSegment(this.pendingTracks); // Create a new typed array to hold the init segment\n\n      event.initSegment = new Uint8Array(initSegment.byteLength); // Create an init segment containing a moov\n      // and track definitions\n\n      event.initSegment.set(initSegment); // Create a new typed array to hold the moof+mdats\n\n      event.data = new Uint8Array(this.pendingBytes); // Append each moof+mdat (one per track) together\n\n      for (i = 0; i < this.pendingBoxes.length; i++) {\n        event.data.set(this.pendingBoxes[i], offset);\n        offset += this.pendingBoxes[i].byteLength;\n      } // Translate caption PTS times into second offsets to match the\n      // video timeline for the segment, and add track info\n\n\n      for (i = 0; i < this.pendingCaptions.length; i++) {\n        caption = this.pendingCaptions[i];\n        caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);\n        caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);\n        event.captionStreams[caption.stream] = true;\n        event.captions.push(caption);\n      } // Translate ID3 frame PTS times into second offsets to match the\n      // video timeline for the segment\n\n\n      for (i = 0; i < this.pendingMetadata.length; i++) {\n        id3 = this.pendingMetadata[i];\n        id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);\n        event.metadata.push(id3);\n      } // We add this to every single emitted segment even though we only need\n      // it for the first\n\n\n      event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n      this.pendingTracks.length = 0;\n      this.videoTrack = null;\n      this.pendingBoxes.length = 0;\n      this.pendingCaptions.length = 0;\n      this.pendingBytes = 0;\n      this.pendingMetadata.length = 0; // Emit the built segment\n      // We include captions and ID3 tags for backwards compatibility,\n      // ideally we should send only video and audio in the data event\n\n      this.trigger('data', event); // Emit each caption to the outside world\n      // Ideally, this would happen immediately on parsing captions,\n      // but we need to ensure that video data is sent back first\n      // so that caption timing can be adjusted to match video timing\n\n      for (i = 0; i < event.captions.length; i++) {\n        caption = event.captions[i];\n        this.trigger('caption', caption);\n      } // Emit each id3 tag to the outside world\n      // Ideally, this would happen immediately on parsing the tag,\n      // but we need to ensure that video data is sent back first\n      // so that ID3 frame timing can be adjusted to match video timing\n\n\n      for (i = 0; i < event.metadata.length; i++) {\n        id3 = event.metadata[i];\n        this.trigger('id3Frame', id3);\n      }\n    } // Only emit `done` if all tracks have been flushed and emitted\n\n\n    if (this.emittedTracks >= this.numberOfTracks) {\n      this.trigger('done');\n      this.emittedTracks = 0;\n    }\n  };\n\n  _CoalesceStream.prototype.setRemux = function (val) {\n    this.remuxTracks = val;\n  };\n  /**\n   * A Stream that expects MP2T binary data as input and produces\n   * corresponding media segments, suitable for use with Media Source\n   * Extension (MSE) implementations that support the ISO BMFF byte\n   * stream format, like Chrome.\n   */\n\n\n  _Transmuxer$1 = function Transmuxer(options) {\n    var self = this,\n        hasFlushed = true,\n        videoTrack,\n        audioTrack;\n\n    _Transmuxer$1.prototype.init.call(this);\n\n    options = options || {};\n    this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n    this.transmuxPipeline_ = {};\n\n    this.setupAacPipeline = function () {\n      var pipeline = {};\n      this.transmuxPipeline_ = pipeline;\n      pipeline.type = 'aac';\n      pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\n\n      pipeline.aacStream = new aac();\n      pipeline.audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n      pipeline.timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n      pipeline.adtsStream = new adts();\n      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n      pipeline.headOfPipeline = pipeline.aacStream;\n      pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);\n      pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);\n      pipeline.metadataStream.on('timestamp', function (frame) {\n        pipeline.aacStream.setTimestamp(frame.timeStamp);\n      });\n      pipeline.aacStream.on('data', function (data) {\n        if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n          return;\n        }\n\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        }; // hook up the audio segment stream to the first track with aac data\n\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new _AudioSegmentStream$1(audioTrack, options);\n        pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n        pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream); // emit pmt info\n\n        self.trigger('trackinfo', {\n          hasAudio: !!audioTrack,\n          hasVideo: !!videoTrack\n        });\n      }); // Re-emit any data coming from the coalesce stream to the outside world\n\n      pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data')); // Let the consumer know we have finished flushing the entire pipeline\n\n      pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      addPipelineLogRetriggers(this, pipeline);\n    };\n\n    this.setupTsPipeline = function () {\n      var pipeline = {};\n      this.transmuxPipeline_ = pipeline;\n      pipeline.type = 'ts';\n      pipeline.metadataStream = new m2ts_1.MetadataStream(); // set up the parsing pipeline\n\n      pipeline.packetStream = new m2ts_1.TransportPacketStream();\n      pipeline.parseStream = new m2ts_1.TransportParseStream();\n      pipeline.elementaryStream = new m2ts_1.ElementaryStream();\n      pipeline.timestampRolloverStream = new m2ts_1.TimestampRolloverStream();\n      pipeline.adtsStream = new adts();\n      pipeline.h264Stream = new H264Stream$1();\n      pipeline.captionStream = new m2ts_1.CaptionStream(options);\n      pipeline.coalesceStream = new _CoalesceStream(options, pipeline.metadataStream);\n      pipeline.headOfPipeline = pipeline.packetStream; // disassemble MPEG2-TS packets into elementary streams\n\n      pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream); // !!THIS ORDER IS IMPORTANT!!\n      // demux the streams\n\n      pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);\n      pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);\n      pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream); // Hook up CEA-608/708 caption stream\n\n      pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);\n      pipeline.elementaryStream.on('data', function (data) {\n        var i;\n\n        if (data.type === 'metadata') {\n          i = data.tracks.length; // scan the tracks listed in the metadata\n\n          while (i--) {\n            if (!videoTrack && data.tracks[i].type === 'video') {\n              videoTrack = data.tracks[i];\n              videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n            } else if (!audioTrack && data.tracks[i].type === 'audio') {\n              audioTrack = data.tracks[i];\n              audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n            }\n          } // hook up the video segment stream to the first track with h264 data\n\n\n          if (videoTrack && !pipeline.videoSegmentStream) {\n            pipeline.coalesceStream.numberOfTracks++;\n            pipeline.videoSegmentStream = new _VideoSegmentStream$1(videoTrack, options);\n            pipeline.videoSegmentStream.on('log', self.getLogTrigger_('videoSegmentStream'));\n            pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n              // When video emits timelineStartInfo data after a flush, we forward that\n              // info to the AudioSegmentStream, if it exists, because video timeline\n              // data takes precedence.  Do not do this if keepOriginalTimestamps is set,\n              // because this is a particularly subtle form of timestamp alteration.\n              if (audioTrack && !options.keepOriginalTimestamps) {\n                audioTrack.timelineStartInfo = timelineStartInfo; // On the first segment we trim AAC frames that exist before the\n                // very earliest DTS we have seen in video because Chrome will\n                // interpret any video track with a baseMediaDecodeTime that is\n                // non-zero as a gap.\n\n                pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);\n              }\n            });\n            pipeline.videoSegmentStream.on('processedGopsInfo', self.trigger.bind(self, 'gopInfo'));\n            pipeline.videoSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'videoSegmentTimingInfo'));\n            pipeline.videoSegmentStream.on('baseMediaDecodeTime', function (baseMediaDecodeTime) {\n              if (audioTrack) {\n                pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n              }\n            });\n            pipeline.videoSegmentStream.on('timingInfo', self.trigger.bind(self, 'videoTimingInfo')); // Set up the final part of the video pipeline\n\n            pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);\n          }\n\n          if (audioTrack && !pipeline.audioSegmentStream) {\n            // hook up the audio segment stream to the first track with aac data\n            pipeline.coalesceStream.numberOfTracks++;\n            pipeline.audioSegmentStream = new _AudioSegmentStream$1(audioTrack, options);\n            pipeline.audioSegmentStream.on('log', self.getLogTrigger_('audioSegmentStream'));\n            pipeline.audioSegmentStream.on('timingInfo', self.trigger.bind(self, 'audioTimingInfo'));\n            pipeline.audioSegmentStream.on('segmentTimingInfo', self.trigger.bind(self, 'audioSegmentTimingInfo')); // Set up the final part of the audio pipeline\n\n            pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);\n          } // emit pmt info\n\n\n          self.trigger('trackinfo', {\n            hasAudio: !!audioTrack,\n            hasVideo: !!videoTrack\n          });\n        }\n      }); // Re-emit any data coming from the coalesce stream to the outside world\n\n      pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n      pipeline.coalesceStream.on('id3Frame', function (id3Frame) {\n        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;\n        self.trigger('id3Frame', id3Frame);\n      });\n      pipeline.coalesceStream.on('caption', this.trigger.bind(this, 'caption')); // Let the consumer know we have finished flushing the entire pipeline\n\n      pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n      addPipelineLogRetriggers(this, pipeline);\n    }; // hook up the segment streams once track metadata is delivered\n\n\n    this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      var pipeline = this.transmuxPipeline_;\n\n      if (!options.keepOriginalTimestamps) {\n        this.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n\n      if (audioTrack) {\n        audioTrack.timelineStartInfo.dts = undefined;\n        audioTrack.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(audioTrack);\n\n        if (pipeline.audioTimestampRolloverStream) {\n          pipeline.audioTimestampRolloverStream.discontinuity();\n        }\n      }\n\n      if (videoTrack) {\n        if (pipeline.videoSegmentStream) {\n          pipeline.videoSegmentStream.gopCache_ = [];\n        }\n\n        videoTrack.timelineStartInfo.dts = undefined;\n        videoTrack.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(videoTrack);\n        pipeline.captionStream.reset();\n      }\n\n      if (pipeline.timestampRolloverStream) {\n        pipeline.timestampRolloverStream.discontinuity();\n      }\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      if (audioTrack) {\n        this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n      }\n    };\n\n    this.setRemux = function (val) {\n      var pipeline = this.transmuxPipeline_;\n      options.remux = val;\n\n      if (pipeline && pipeline.coalesceStream) {\n        pipeline.coalesceStream.setRemux(val);\n      }\n    };\n\n    this.alignGopsWith = function (gopsToAlignWith) {\n      if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n        this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n      }\n    };\n\n    this.getLogTrigger_ = function (key) {\n      var self = this;\n      return function (event) {\n        event.stream = key;\n        self.trigger('log', event);\n      };\n    }; // feed incoming data to the front of the parsing pipeline\n\n\n    this.push = function (data) {\n      if (hasFlushed) {\n        var isAac = isLikelyAacData$1(data);\n\n        if (isAac && this.transmuxPipeline_.type !== 'aac') {\n          this.setupAacPipeline();\n        } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n          this.setupTsPipeline();\n        }\n\n        hasFlushed = false;\n      }\n\n      this.transmuxPipeline_.headOfPipeline.push(data);\n    }; // flush any buffered data\n\n\n    this.flush = function () {\n      hasFlushed = true; // Start at the top of the pipeline and flush all pending work\n\n      this.transmuxPipeline_.headOfPipeline.flush();\n    };\n\n    this.endTimeline = function () {\n      this.transmuxPipeline_.headOfPipeline.endTimeline();\n    };\n\n    this.reset = function () {\n      if (this.transmuxPipeline_.headOfPipeline) {\n        this.transmuxPipeline_.headOfPipeline.reset();\n      }\n    }; // Caption data has to be reset when seeking outside buffered range\n\n\n    this.resetCaptions = function () {\n      if (this.transmuxPipeline_.captionStream) {\n        this.transmuxPipeline_.captionStream.reset();\n      }\n    };\n  };\n\n  _Transmuxer$1.prototype = new stream();\n  var transmuxer$2 = {\n    Transmuxer: _Transmuxer$1,\n    VideoSegmentStream: _VideoSegmentStream$1,\n    AudioSegmentStream: _AudioSegmentStream$1,\n    AUDIO_PROPERTIES: audioProperties,\n    VIDEO_PROPERTIES: videoProperties,\n    // exported for testing\n    generateSegmentTimingInfo: generateSegmentTimingInfo\n  };\n\n  var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;\n  var CaptionStream = captionStream.CaptionStream;\n  /**\n    * Maps an offset in the mdat to a sample based on the the size of the samples.\n    * Assumes that `parseSamples` has been called first.\n    *\n    * @param {Number} offset - The offset into the mdat\n    * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n    * @return {?Object} The matching sample, or null if no match was found.\n    *\n    * @see ISO-BMFF-12/2015, Section 8.8.8\n   **/\n\n  var mapToSample = function mapToSample(offset, samples) {\n    var approximateOffset = offset;\n\n    for (var i = 0; i < samples.length; i++) {\n      var sample = samples[i];\n\n      if (approximateOffset < sample.size) {\n        return sample;\n      }\n\n      approximateOffset -= sample.size;\n    }\n\n    return null;\n  };\n  /**\n    * Finds SEI nal units contained in a Media Data Box.\n    * Assumes that `parseSamples` has been called first.\n    *\n    * @param {Uint8Array} avcStream - The bytes of the mdat\n    * @param {Object[]} samples - The samples parsed out by `parseSamples`\n    * @param {Number} trackId - The trackId of this video track\n    * @return {Object[]} seiNals - the parsed SEI NALUs found.\n    *   The contents of the seiNal should match what is expected by\n    *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n    *\n    * @see ISO-BMFF-12/2015, Section 8.1.1\n    * @see Rec. ITU-T H.264, 7.3.2.3.1\n   **/\n\n\n  var findSeiNals = function findSeiNals(avcStream, samples, trackId) {\n    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n        result = {\n      logs: [],\n      seiNals: []\n    },\n        seiNal,\n        i,\n        length,\n        lastMatchedSample;\n\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4; // Bail if this doesn't appear to be an H264 stream\n\n      if (length <= 0) {\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n        case 0x06:\n          var data = avcStream.subarray(i + 1, i + 1 + length);\n          var matchingSample = mapToSample(i, samples);\n          seiNal = {\n            nalUnitType: 'sei_rbsp',\n            size: length,\n            data: data,\n            escapedRBSP: discardEmulationPreventionBytes(data),\n            trackId: trackId\n          };\n\n          if (matchingSample) {\n            seiNal.pts = matchingSample.pts;\n            seiNal.dts = matchingSample.dts;\n            lastMatchedSample = matchingSample;\n          } else if (lastMatchedSample) {\n            // If a matching sample cannot be found, use the last\n            // sample's values as they should be as close as possible\n            seiNal.pts = lastMatchedSample.pts;\n            seiNal.dts = lastMatchedSample.dts;\n          } else {\n            result.logs.push({\n              level: 'warn',\n              message: 'We\\'ve encountered a nal unit without data at ' + i + ' for trackId ' + trackId + '. See mux.js#223.'\n            });\n            break;\n          }\n\n          result.seiNals.push(seiNal);\n          break;\n      }\n    }\n\n    return result;\n  };\n  /**\n    * Parses sample information out of Track Run Boxes and calculates\n    * the absolute presentation and decode timestamps of each sample.\n    *\n    * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n    * @param {Number|BigInt} baseMediaDecodeTime - base media decode time from tfdt\n        @see ISO-BMFF-12/2015, Section 8.8.12\n    * @param {Object} tfhd - The parsed Track Fragment Header\n    *   @see inspect.parseTfhd\n    * @return {Object[]} the parsed samples\n    *\n    * @see ISO-BMFF-12/2015, Section 8.8.8\n   **/\n\n\n  var parseSamples = function parseSamples(truns, baseMediaDecodeTime, tfhd) {\n    var currentDts = baseMediaDecodeTime;\n    var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n    var defaultSampleSize = tfhd.defaultSampleSize || 0;\n    var trackId = tfhd.trackId;\n    var allSamples = [];\n    truns.forEach(function (trun) {\n      // Note: We currently do not parse the sample table as well\n      // as the trun. It's possible some sources will require this.\n      // moov > trak > mdia > minf > stbl\n      var trackRun = parseTrun(trun);\n      var samples = trackRun.samples;\n      samples.forEach(function (sample) {\n        if (sample.duration === undefined) {\n          sample.duration = defaultSampleDuration;\n        }\n\n        if (sample.size === undefined) {\n          sample.size = defaultSampleSize;\n        }\n\n        sample.trackId = trackId;\n        sample.dts = currentDts;\n\n        if (sample.compositionTimeOffset === undefined) {\n          sample.compositionTimeOffset = 0;\n        }\n\n        if (typeof currentDts === 'bigint') {\n          sample.pts = currentDts + window__default['default'].BigInt(sample.compositionTimeOffset);\n          currentDts += window__default['default'].BigInt(sample.duration);\n        } else {\n          sample.pts = currentDts + sample.compositionTimeOffset;\n          currentDts += sample.duration;\n        }\n      });\n      allSamples = allSamples.concat(samples);\n    });\n    return allSamples;\n  };\n  /**\n    * Parses out caption nals from an FMP4 segment's video tracks.\n    *\n    * @param {Uint8Array} segment - The bytes of a single segment\n    * @param {Number} videoTrackId - The trackId of a video track in the segment\n    * @return {Object.<Number, Object[]>} A mapping of video trackId to\n    *   a list of seiNals found in that track\n   **/\n\n\n  var parseCaptionNals = function parseCaptionNals(segment, videoTrackId) {\n    // To get the samples\n    var trafs = findBox_1(segment, ['moof', 'traf']); // To get SEI NAL units\n\n    var mdats = findBox_1(segment, ['mdat']);\n    var captionNals = {};\n    var mdatTrafPairs = []; // Pair up each traf with a mdat as moofs and mdats are in pairs\n\n    mdats.forEach(function (mdat, index) {\n      var matchingTraf = trafs[index];\n      mdatTrafPairs.push({\n        mdat: mdat,\n        traf: matchingTraf\n      });\n    });\n    mdatTrafPairs.forEach(function (pair) {\n      var mdat = pair.mdat;\n      var traf = pair.traf;\n      var tfhd = findBox_1(traf, ['tfhd']); // Exactly 1 tfhd per traf\n\n      var headerInfo = parseTfhd(tfhd[0]);\n      var trackId = headerInfo.trackId;\n      var tfdt = findBox_1(traf, ['tfdt']); // Either 0 or 1 tfdt per traf\n\n      var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n      var truns = findBox_1(traf, ['trun']);\n      var samples;\n      var result; // Only parse video data for the chosen video track\n\n      if (videoTrackId === trackId && truns.length > 0) {\n        samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n        result = findSeiNals(mdat, samples, trackId);\n\n        if (!captionNals[trackId]) {\n          captionNals[trackId] = {\n            seiNals: [],\n            logs: []\n          };\n        }\n\n        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);\n        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);\n      }\n    });\n    return captionNals;\n  };\n  /**\n    * Parses out inband captions from an MP4 container and returns\n    * caption objects that can be used by WebVTT and the TextTrack API.\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n    * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number} trackId - The id of the video track to parse\n    * @param {Number} timescale - The timescale for the video track from the init segment\n    *\n    * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n    * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n    * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n    * @return {String} parsedCaptions[].text - The visible content of the caption\n   **/\n\n\n  var parseEmbeddedCaptions = function parseEmbeddedCaptions(segment, trackId, timescale) {\n    var captionNals; // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n\n    if (trackId === null) {\n      return null;\n    }\n\n    captionNals = parseCaptionNals(segment, trackId);\n    var trackNals = captionNals[trackId] || {};\n    return {\n      seiNals: trackNals.seiNals,\n      logs: trackNals.logs,\n      timescale: timescale\n    };\n  };\n  /**\n    * Converts SEI NALUs into captions that can be used by video.js\n   **/\n\n\n  var CaptionParser = function CaptionParser() {\n    var isInitialized = false;\n    var captionStream; // Stores segments seen before trackId and timescale are set\n\n    var segmentCache; // Stores video track ID of the track being parsed\n\n    var trackId; // Stores the timescale of the track being parsed\n\n    var timescale; // Stores captions parsed so far\n\n    var parsedCaptions; // Stores whether we are receiving partial data or not\n\n    var parsingPartial;\n    /**\n      * A method to indicate whether a CaptionParser has been initalized\n      * @returns {Boolean}\n     **/\n\n    this.isInitialized = function () {\n      return isInitialized;\n    };\n    /**\n      * Initializes the underlying CaptionStream, SEI NAL parsing\n      * and management, and caption collection\n     **/\n\n\n    this.init = function (options) {\n      captionStream = new CaptionStream();\n      isInitialized = true;\n      parsingPartial = options ? options.isPartial : false; // Collect dispatched captions\n\n      captionStream.on('data', function (event) {\n        // Convert to seconds in the source's timescale\n        event.startTime = event.startPts / timescale;\n        event.endTime = event.endPts / timescale;\n        parsedCaptions.captions.push(event);\n        parsedCaptions.captionStreams[event.stream] = true;\n      });\n      captionStream.on('log', function (log) {\n        parsedCaptions.logs.push(log);\n      });\n    };\n    /**\n      * Determines if a new video track will be selected\n      * or if the timescale changed\n      * @return {Boolean}\n     **/\n\n\n    this.isNewInit = function (videoTrackIds, timescales) {\n      if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === 'object' && Object.keys(timescales).length === 0) {\n        return false;\n      }\n\n      return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];\n    };\n    /**\n      * Parses out SEI captions and interacts with underlying\n      * CaptionStream to return dispatched captions\n      *\n      * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n      * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n      * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n      * @see parseEmbeddedCaptions\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.parse = function (segment, videoTrackIds, timescales) {\n      var parsedData;\n\n      if (!this.isInitialized()) {\n        return null; // This is not likely to be a video segment\n      } else if (!videoTrackIds || !timescales) {\n        return null;\n      } else if (this.isNewInit(videoTrackIds, timescales)) {\n        // Use the first video track only as there is no\n        // mechanism to switch to other video tracks\n        trackId = videoTrackIds[0];\n        timescale = timescales[trackId]; // If an init segment has not been seen yet, hold onto segment\n        // data until we have one.\n        // the ISO-BMFF spec says that trackId can't be zero, but there's some broken content out there\n      } else if (trackId === null || !timescale) {\n        segmentCache.push(segment);\n        return null;\n      } // Now that a timescale and trackId is set, parse cached segments\n\n\n      while (segmentCache.length > 0) {\n        var cachedSegment = segmentCache.shift();\n        this.parse(cachedSegment, videoTrackIds, timescales);\n      }\n\n      parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n      if (parsedData && parsedData.logs) {\n        parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);\n      }\n\n      if (parsedData === null || !parsedData.seiNals) {\n        if (parsedCaptions.logs.length) {\n          return {\n            logs: parsedCaptions.logs,\n            captions: [],\n            captionStreams: []\n          };\n        }\n\n        return null;\n      }\n\n      this.pushNals(parsedData.seiNals); // Force the parsed captions to be dispatched\n\n      this.flushStream();\n      return parsedCaptions;\n    };\n    /**\n      * Pushes SEI NALUs onto CaptionStream\n      * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n      * Assumes that `parseCaptionNals` has been called first\n      * @see m2ts/caption-stream.js\n      **/\n\n\n    this.pushNals = function (nals) {\n      if (!this.isInitialized() || !nals || nals.length === 0) {\n        return null;\n      }\n\n      nals.forEach(function (nal) {\n        captionStream.push(nal);\n      });\n    };\n    /**\n      * Flushes underlying CaptionStream to dispatch processed, displayable captions\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.flushStream = function () {\n      if (!this.isInitialized()) {\n        return null;\n      }\n\n      if (!parsingPartial) {\n        captionStream.flush();\n      } else {\n        captionStream.partialFlush();\n      }\n    };\n    /**\n      * Reset caption buckets for new data\n     **/\n\n\n    this.clearParsedCaptions = function () {\n      parsedCaptions.captions = [];\n      parsedCaptions.captionStreams = {};\n      parsedCaptions.logs = [];\n    };\n    /**\n      * Resets underlying CaptionStream\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.resetCaptionStream = function () {\n      if (!this.isInitialized()) {\n        return null;\n      }\n\n      captionStream.reset();\n    };\n    /**\n      * Convenience method to clear all captions flushed from the\n      * CaptionStream and still being parsed\n      * @see m2ts/caption-stream.js\n     **/\n\n\n    this.clearAllCaptions = function () {\n      this.clearParsedCaptions();\n      this.resetCaptionStream();\n    };\n    /**\n      * Reset caption parser\n     **/\n\n\n    this.reset = function () {\n      segmentCache = [];\n      trackId = null;\n      timescale = null;\n\n      if (!parsedCaptions) {\n        parsedCaptions = {\n          captions: [],\n          // CC1, CC2, CC3, CC4\n          captionStreams: {},\n          logs: []\n        };\n      } else {\n        this.clearParsedCaptions();\n      }\n\n      this.resetCaptionStream();\n    };\n\n    this.reset();\n  };\n\n  var captionParser = CaptionParser;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var mp4 = {\n    generator: mp4Generator,\n    probe: probe$2,\n    Transmuxer: transmuxer$2.Transmuxer,\n    AudioSegmentStream: transmuxer$2.AudioSegmentStream,\n    VideoSegmentStream: transmuxer$2.VideoSegmentStream,\n    CaptionParser: captionParser\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   *\n   * An object that stores the bytes of an FLV tag and methods for\n   * querying and manipulating that data.\n   * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n   */\n\n  var _FlvTag; // (type:uint, extraData:Boolean = false) extends ByteArray\n\n\n  _FlvTag = function FlvTag(type, extraData) {\n    var // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0,\n        // :uint\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n        // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function prepareWrite(flv, count) {\n      var bytes,\n          minLength = flv.position + count;\n\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      } // allocate a new buffer and copy over the data that will not be modified\n\n\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n        // commonly used metadata properties\n    widthBytes = _FlvTag.widthBytes || new Uint8Array('width'.length),\n        heightBytes = _FlvTag.heightBytes || new Uint8Array('height'.length),\n        videocodecidBytes = _FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n        i;\n\n    if (!_FlvTag.widthBytes) {\n      // calculating the bytes of common metadata names ahead of time makes the\n      // corresponding writes faster because we don't have to loop over the\n      // characters\n      // re-test with test/perf.html if you're planning on changing this\n      for (i = 0; i < 'width'.length; i++) {\n        widthBytes[i] = 'width'.charCodeAt(i);\n      }\n\n      for (i = 0; i < 'height'.length; i++) {\n        heightBytes[i] = 'height'.charCodeAt(i);\n      }\n\n      for (i = 0; i < 'videocodecid'.length; i++) {\n        videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n      }\n\n      _FlvTag.widthBytes = widthBytes;\n      _FlvTag.heightBytes = heightBytes;\n      _FlvTag.videocodecidBytes = videocodecidBytes;\n    }\n\n    this.keyFrame = false; // :Boolean\n\n    switch (type) {\n      case _FlvTag.VIDEO_TAG:\n        this.length = 16; // Start the buffer at 256k\n\n        bufferStartSize *= 6;\n        break;\n\n      case _FlvTag.AUDIO_TAG:\n        this.length = 13;\n        this.keyFrame = true;\n        break;\n\n      case _FlvTag.METADATA_TAG:\n        this.length = 29;\n        this.keyFrame = true;\n        break;\n\n      default:\n        throw new Error('Unknown FLV tag type');\n    }\n\n    this.bytes = new Uint8Array(bufferStartSize);\n    this.view = new DataView(this.bytes.buffer);\n    this.bytes[0] = type;\n    this.position = this.length;\n    this.keyFrame = extraData; // Defaults to false\n    // presentation timestamp\n\n    this.pts = 0; // decoder timestamp\n\n    this.dts = 0; // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n\n    this.writeBytes = function (bytes, offset, length) {\n      var start = offset || 0,\n          end;\n      length = length || bytes.byteLength;\n      end = start + length;\n      prepareWrite(this, length);\n      this.bytes.set(bytes.subarray(start, end), this.position);\n      this.position += length;\n      this.length = Math.max(this.length, this.position);\n    }; // ByteArray#writeByte(value:int):void\n\n\n    this.writeByte = function (byte) {\n      prepareWrite(this, 1);\n      this.bytes[this.position] = byte;\n      this.position++;\n      this.length = Math.max(this.length, this.position);\n    }; // ByteArray#writeShort(value:int):void\n\n\n    this.writeShort = function (short) {\n      prepareWrite(this, 2);\n      this.view.setUint16(this.position, short);\n      this.position += 2;\n      this.length = Math.max(this.length, this.position);\n    }; // Negative index into array\n    // (pos:uint):int\n\n\n    this.negIndex = function (pos) {\n      return this.bytes[this.length - pos];\n    }; // The functions below ONLY work when this[0] == VIDEO_TAG.\n    // We are not going to check for that because we dont want the overhead\n    // (nal:ByteArray = null):int\n\n\n    this.nalUnitSize = function () {\n      if (adHoc === 0) {\n        return 0;\n      }\n\n      return this.length - (adHoc + 4);\n    };\n\n    this.startNalUnit = function () {\n      // remember position and add 4 bytes\n      if (adHoc > 0) {\n        throw new Error('Attempted to create new NAL wihout closing the old one');\n      } // reserve 4 bytes for nal unit size\n\n\n      adHoc = this.length;\n      this.length += 4;\n      this.position = this.length;\n    }; // (nal:ByteArray = null):void\n\n\n    this.endNalUnit = function (nalContainer) {\n      var nalStart, // :uint\n      nalLength; // :uint\n      // Rewind to the marker and write the size\n\n      if (this.length === adHoc + 4) {\n        // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n        this.length -= 4;\n      } else if (adHoc > 0) {\n        nalStart = adHoc + 4;\n        nalLength = this.length - nalStart;\n        this.position = adHoc;\n        this.view.setUint32(this.position, nalLength);\n        this.position = this.length;\n\n        if (nalContainer) {\n          // Add the tag to the NAL unit\n          nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n        }\n      }\n\n      adHoc = 0;\n    };\n    /**\n     * Write out a 64-bit floating point valued metadata property. This method is\n     * called frequently during a typical parse and needs to be fast.\n     */\n    // (key:String, val:Number):void\n\n\n    this.writeMetaDataDouble = function (key, val) {\n      var i;\n      prepareWrite(this, 2 + key.length + 9); // write size of property name\n\n      this.view.setUint16(this.position, key.length);\n      this.position += 2; // this next part looks terrible but it improves parser throughput by\n      // 10kB/s in my testing\n      // write property name\n\n      if (key === 'width') {\n        this.bytes.set(widthBytes, this.position);\n        this.position += 5;\n      } else if (key === 'height') {\n        this.bytes.set(heightBytes, this.position);\n        this.position += 6;\n      } else if (key === 'videocodecid') {\n        this.bytes.set(videocodecidBytes, this.position);\n        this.position += 12;\n      } else {\n        for (i = 0; i < key.length; i++) {\n          this.bytes[this.position] = key.charCodeAt(i);\n          this.position++;\n        }\n      } // skip null byte\n\n\n      this.position++; // write property value\n\n      this.view.setFloat64(this.position, val);\n      this.position += 8; // update flv tag length\n\n      this.length = Math.max(this.length, this.position);\n      ++adHoc;\n    }; // (key:String, val:Boolean):void\n\n\n    this.writeMetaDataBoolean = function (key, val) {\n      var i;\n      prepareWrite(this, 2);\n      this.view.setUint16(this.position, key.length);\n      this.position += 2;\n\n      for (i = 0; i < key.length; i++) {\n        // if key.charCodeAt(i) >= 255, handle error\n        prepareWrite(this, 1);\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n\n      prepareWrite(this, 2);\n      this.view.setUint8(this.position, 0x01);\n      this.position++;\n      this.view.setUint8(this.position, val ? 0x01 : 0x00);\n      this.position++;\n      this.length = Math.max(this.length, this.position);\n      ++adHoc;\n    }; // ():ByteArray\n\n\n    this.finalize = function () {\n      var dtsDelta, // :int\n      len; // :int\n\n      switch (this.bytes[0]) {\n        // Video Data\n        case _FlvTag.VIDEO_TAG:\n          // We only support AVC, 1 = key frame (for AVC, a seekable\n          // frame), 2 = inter frame (for AVC, a non-seekable frame)\n          this.bytes[11] = (this.keyFrame || extraData ? 0x10 : 0x20) | 0x07;\n          this.bytes[12] = extraData ? 0x00 : 0x01;\n          dtsDelta = this.pts - this.dts;\n          this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n          this.bytes[14] = (dtsDelta & 0x0000FF00) >>> 8;\n          this.bytes[15] = (dtsDelta & 0x000000FF) >>> 0;\n          break;\n\n        case _FlvTag.AUDIO_TAG:\n          this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n\n          this.bytes[12] = extraData ? 0x00 : 0x01;\n          break;\n\n        case _FlvTag.METADATA_TAG:\n          this.position = 11;\n          this.view.setUint8(this.position, 0x02); // String type\n\n          this.position++;\n          this.view.setUint16(this.position, 0x0A); // 10 Bytes\n\n          this.position += 2; // set \"onMetaData\"\n\n          this.bytes.set([0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61, 0x44, 0x61, 0x74, 0x61], this.position);\n          this.position += 10;\n          this.bytes[this.position] = 0x08; // Array type\n\n          this.position++;\n          this.view.setUint32(this.position, adHoc);\n          this.position = this.length;\n          this.bytes.set([0, 0, 9], this.position);\n          this.position += 3; // End Data Tag\n\n          this.length = this.position;\n          break;\n      }\n\n      len = this.length - 11; // write the DataSize field\n\n      this.bytes[1] = (len & 0x00FF0000) >>> 16;\n      this.bytes[2] = (len & 0x0000FF00) >>> 8;\n      this.bytes[3] = (len & 0x000000FF) >>> 0; // write the Timestamp\n\n      this.bytes[4] = (this.dts & 0x00FF0000) >>> 16;\n      this.bytes[5] = (this.dts & 0x0000FF00) >>> 8;\n      this.bytes[6] = (this.dts & 0x000000FF) >>> 0;\n      this.bytes[7] = (this.dts & 0xFF000000) >>> 24; // write the StreamID\n\n      this.bytes[8] = 0;\n      this.bytes[9] = 0;\n      this.bytes[10] = 0; // Sometimes we're at the end of the view and have one slot to write a\n      // uint32, so, prepareWrite of count 4, since, view is uint8\n\n      prepareWrite(this, 4);\n      this.view.setUint32(this.length, this.length);\n      this.length += 4;\n      this.position += 4; // trim down the byte buffer to what is actually being used\n\n      this.bytes = this.bytes.subarray(0, this.length);\n      this.frameTime = _FlvTag.frameTime(this.bytes); // if bytes.bytelength isn't equal to this.length, handle error\n\n      return this;\n    };\n  };\n\n  _FlvTag.AUDIO_TAG = 0x08; // == 8, :uint\n\n  _FlvTag.VIDEO_TAG = 0x09; // == 9, :uint\n\n  _FlvTag.METADATA_TAG = 0x12; // == 18, :uint\n  // (tag:ByteArray):Boolean {\n\n  _FlvTag.isAudioFrame = function (tag) {\n    return _FlvTag.AUDIO_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isVideoFrame = function (tag) {\n    return _FlvTag.VIDEO_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isMetaData = function (tag) {\n    return _FlvTag.METADATA_TAG === tag[0];\n  }; // (tag:ByteArray):Boolean {\n\n\n  _FlvTag.isKeyFrame = function (tag) {\n    if (_FlvTag.isVideoFrame(tag)) {\n      return tag[11] === 0x17;\n    }\n\n    if (_FlvTag.isAudioFrame(tag)) {\n      return true;\n    }\n\n    if (_FlvTag.isMetaData(tag)) {\n      return true;\n    }\n\n    return false;\n  }; // (tag:ByteArray):uint {\n\n\n  _FlvTag.frameTime = function (tag) {\n    var pts = tag[4] << 16; // :uint\n\n    pts |= tag[5] << 8;\n    pts |= tag[6] << 0;\n    pts |= tag[7] << 24;\n    return pts;\n  };\n\n  var flvTag = _FlvTag;\n\n  /**\n   * The final stage of the transmuxer that emits the flv tags\n   * for audio, video, and metadata. Also tranlates in time and\n   * outputs caption data and id3 cues.\n   */\n\n\n  var CoalesceStream = function CoalesceStream(options) {\n    // Number of Tracks per output segment\n    // If greater than 1, we combine multiple\n    // tracks into a single segment\n    this.numberOfTracks = 0;\n    this.metadataStream = options.metadataStream;\n    this.videoTags = [];\n    this.audioTags = [];\n    this.videoTrack = null;\n    this.audioTrack = null;\n    this.pendingCaptions = [];\n    this.pendingMetadata = [];\n    this.pendingTracks = 0;\n    this.processedTracks = 0;\n    CoalesceStream.prototype.init.call(this); // Take output from multiple\n\n    this.push = function (output) {\n      // buffer incoming captions until the associated video segment\n      // finishes\n      if (output.text) {\n        return this.pendingCaptions.push(output);\n      } // buffer incoming id3 tags until the final flush\n\n\n      if (output.frames) {\n        return this.pendingMetadata.push(output);\n      }\n\n      if (output.track.type === 'video') {\n        this.videoTrack = output.track;\n        this.videoTags = output.tags;\n        this.pendingTracks++;\n      }\n\n      if (output.track.type === 'audio') {\n        this.audioTrack = output.track;\n        this.audioTags = output.tags;\n        this.pendingTracks++;\n      }\n    };\n  };\n\n  CoalesceStream.prototype = new stream();\n\n  CoalesceStream.prototype.flush = function (flushSource) {\n    var id3,\n        caption,\n        i,\n        timelineStartPts,\n        event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n\n    if (this.pendingTracks < this.numberOfTracks) {\n      if (flushSource !== 'VideoSegmentStream' && flushSource !== 'AudioSegmentStream') {\n        // Return because we haven't received a flush from a data-generating\n        // portion of the segment (meaning that we have only recieved meta-data\n        // or captions.)\n        return;\n      } else if (this.pendingTracks === 0) {\n        // In the case where we receive a flush without any data having been\n        // received we consider it an emitted track for the purposes of coalescing\n        // `done` events.\n        // We do this for the case where there is an audio and video track in the\n        // segment but no audio data. (seen in several playlists with alternate\n        // audio tracks and no audio present in the main TS segments.)\n        this.processedTracks++;\n\n        if (this.processedTracks < this.numberOfTracks) {\n          return;\n        }\n      }\n    }\n\n    this.processedTracks += this.pendingTracks;\n    this.pendingTracks = 0;\n\n    if (this.processedTracks < this.numberOfTracks) {\n      return;\n    }\n\n    if (this.videoTrack) {\n      timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    } else if (this.audioTrack) {\n      timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    }\n\n    event.tags.videoTags = this.videoTags;\n    event.tags.audioTags = this.audioTags; // Translate caption PTS times into second offsets into the\n    // video timeline for the segment, and add track info\n\n    for (i = 0; i < this.pendingCaptions.length; i++) {\n      caption = this.pendingCaptions[i];\n      caption.startTime = caption.startPts - timelineStartPts;\n      caption.startTime /= 90e3;\n      caption.endTime = caption.endPts - timelineStartPts;\n      caption.endTime /= 90e3;\n      event.captionStreams[caption.stream] = true;\n      event.captions.push(caption);\n    } // Translate ID3 frame PTS times into second offsets into the\n    // video timeline for the segment\n\n\n    for (i = 0; i < this.pendingMetadata.length; i++) {\n      id3 = this.pendingMetadata[i];\n      id3.cueTime = id3.pts - timelineStartPts;\n      id3.cueTime /= 90e3;\n      event.metadata.push(id3);\n    } // We add this to every single emitted segment even though we only need\n    // it for the first\n\n\n    event.metadata.dispatchType = this.metadataStream.dispatchType; // Reset stream state\n\n    this.videoTrack = null;\n    this.audioTrack = null;\n    this.videoTags = [];\n    this.audioTags = [];\n    this.pendingCaptions.length = 0;\n    this.pendingMetadata.length = 0;\n    this.pendingTracks = 0;\n    this.processedTracks = 0; // Emit the final segment\n\n    this.trigger('data', event);\n    this.trigger('done');\n  };\n\n  var coalesceStream = CoalesceStream;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var TagList = function TagList() {\n    var self = this;\n    this.list = [];\n\n    this.push = function (tag) {\n      this.list.push({\n        bytes: tag.bytes,\n        dts: tag.dts,\n        pts: tag.pts,\n        keyFrame: tag.keyFrame,\n        metaDataTag: tag.metaDataTag\n      });\n    };\n\n    Object.defineProperty(this, 'length', {\n      get: function get() {\n        return self.list.length;\n      }\n    });\n  };\n\n  var tagList = TagList;\n\n  var H264Stream = h264.H264Stream;\n\n  var _Transmuxer, _VideoSegmentStream, _AudioSegmentStream, collectTimelineInfo, metaDataTag, extraDataTag;\n  /**\n   * Store information about the start and end of the tracka and the\n   * duration for each frame/sample we process in order to calculate\n   * the baseMediaDecodeTime\n   */\n\n\n  collectTimelineInfo = function collectTimelineInfo(track, data) {\n    if (typeof data.pts === 'number') {\n      if (track.timelineStartInfo.pts === undefined) {\n        track.timelineStartInfo.pts = data.pts;\n      } else {\n        track.timelineStartInfo.pts = Math.min(track.timelineStartInfo.pts, data.pts);\n      }\n    }\n\n    if (typeof data.dts === 'number') {\n      if (track.timelineStartInfo.dts === undefined) {\n        track.timelineStartInfo.dts = data.dts;\n      } else {\n        track.timelineStartInfo.dts = Math.min(track.timelineStartInfo.dts, data.dts);\n      }\n    }\n  };\n\n  metaDataTag = function metaDataTag(track, pts) {\n    var tag = new flvTag(flvTag.METADATA_TAG); // :FlvTag\n\n    tag.dts = pts;\n    tag.pts = pts;\n    tag.writeMetaDataDouble('videocodecid', 7);\n    tag.writeMetaDataDouble('width', track.width);\n    tag.writeMetaDataDouble('height', track.height);\n    return tag;\n  };\n\n  extraDataTag = function extraDataTag(track, pts) {\n    var i,\n        tag = new flvTag(flvTag.VIDEO_TAG, true);\n    tag.dts = pts;\n    tag.pts = pts;\n    tag.writeByte(0x01); // version\n\n    tag.writeByte(track.profileIdc); // profile\n\n    tag.writeByte(track.profileCompatibility); // compatibility\n\n    tag.writeByte(track.levelIdc); // level\n\n    tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n\n    tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n\n    tag.writeShort(track.sps[0].length); // data of SPS\n\n    tag.writeBytes(track.sps[0]); // SPS\n\n    tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n\n    for (i = 0; i < track.pps.length; ++i) {\n      tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n\n      tag.writeBytes(track.pps[i]); // data of PPS\n    }\n\n    return tag;\n  };\n  /**\n   * Constructs a single-track, media segment from AAC data\n   * events. The output of this stream can be fed to flash.\n   */\n\n\n  _AudioSegmentStream = function AudioSegmentStream(track) {\n    var adtsFrames = [],\n        videoKeyFrames = [],\n        oldExtraData;\n\n    _AudioSegmentStream.prototype.init.call(this);\n\n    this.push = function (data) {\n      collectTimelineInfo(track, data);\n\n      if (track) {\n        track.audioobjecttype = data.audioobjecttype;\n        track.channelcount = data.channelcount;\n        track.samplerate = data.samplerate;\n        track.samplingfrequencyindex = data.samplingfrequencyindex;\n        track.samplesize = data.samplesize;\n        track.extraData = track.audioobjecttype << 11 | track.samplingfrequencyindex << 7 | track.channelcount << 3;\n      }\n\n      data.pts = Math.round(data.pts / 90);\n      data.dts = Math.round(data.dts / 90); // buffer audio data until end() is called\n\n      adtsFrames.push(data);\n    };\n\n    this.flush = function () {\n      var currentFrame,\n          adtsFrame,\n          lastMetaPts,\n          tags = new tagList(); // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        this.trigger('done', 'AudioSegmentStream');\n        return;\n      }\n\n      lastMetaPts = -Infinity;\n\n      while (adtsFrames.length) {\n        currentFrame = adtsFrames.shift(); // write out a metadata frame at every video key frame\n\n        if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n          lastMetaPts = videoKeyFrames.shift();\n          this.writeMetaDataTags(tags, lastMetaPts);\n        } // also write out metadata tags every 1 second so that the decoder\n        // is re-initialized quickly after seeking into a different\n        // audio configuration.\n\n\n        if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n          this.writeMetaDataTags(tags, currentFrame.pts);\n          oldExtraData = track.extraData;\n          lastMetaPts = currentFrame.pts;\n        }\n\n        adtsFrame = new flvTag(flvTag.AUDIO_TAG);\n        adtsFrame.pts = currentFrame.pts;\n        adtsFrame.dts = currentFrame.dts;\n        adtsFrame.writeBytes(currentFrame.data);\n        tags.push(adtsFrame.finalize());\n      }\n\n      videoKeyFrames.length = 0;\n      oldExtraData = null;\n      this.trigger('data', {\n        track: track,\n        tags: tags.list\n      });\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.writeMetaDataTags = function (tags, pts) {\n      var adtsFrame;\n      adtsFrame = new flvTag(flvTag.METADATA_TAG); // For audio, DTS is always the same as PTS. We want to set the DTS\n      // however so we can compare with video DTS to determine approximate\n      // packet order\n\n      adtsFrame.pts = pts;\n      adtsFrame.dts = pts; // AAC is always 10\n\n      adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n      adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n      adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate); // Is AAC always 16 bit?\n\n      adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n      tags.push(adtsFrame.finalize());\n      adtsFrame = new flvTag(flvTag.AUDIO_TAG, true); // For audio, DTS is always the same as PTS. We want to set the DTS\n      // however so we can compare with video DTS to determine approximate\n      // packet order\n\n      adtsFrame.pts = pts;\n      adtsFrame.dts = pts;\n      adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n      adtsFrame.position += 2;\n      adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n      tags.push(adtsFrame.finalize());\n    };\n\n    this.onVideoKeyFrame = function (pts) {\n      videoKeyFrames.push(pts);\n    };\n  };\n\n  _AudioSegmentStream.prototype = new stream();\n  /**\n   * Store FlvTags for the h264 stream\n   * @param track {object} track metadata configuration\n   */\n\n  _VideoSegmentStream = function VideoSegmentStream(track) {\n    var nalUnits = [],\n        config,\n        h264Frame;\n\n    _VideoSegmentStream.prototype.init.call(this);\n\n    this.finishFrame = function (tags, frame) {\n      if (!frame) {\n        return;\n      } // Check if keyframe and the length of tags.\n      // This makes sure we write metadata on the first frame of a segment.\n\n\n      if (config && track && track.newMetadata && (frame.keyFrame || tags.length === 0)) {\n        // Push extra data on every IDR frame in case we did a stream change + seek\n        var metaTag = metaDataTag(config, frame.dts).finalize();\n        var extraTag = extraDataTag(track, frame.dts).finalize();\n        metaTag.metaDataTag = extraTag.metaDataTag = true;\n        tags.push(metaTag);\n        tags.push(extraTag);\n        track.newMetadata = false;\n        this.trigger('keyframe', frame.dts);\n      }\n\n      frame.endNalUnit();\n      tags.push(frame.finalize());\n      h264Frame = null;\n    };\n\n    this.push = function (data) {\n      collectTimelineInfo(track, data);\n      data.pts = Math.round(data.pts / 90);\n      data.dts = Math.round(data.dts / 90); // buffer video until flush() is called\n\n      nalUnits.push(data);\n    };\n\n    this.flush = function () {\n      var currentNal,\n          tags = new tagList(); // Throw away nalUnits at the start of the byte stream until we find\n      // the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      while (nalUnits.length) {\n        currentNal = nalUnits.shift(); // record the track config\n\n        if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n          track.newMetadata = true;\n          config = currentNal.config;\n          track.width = config.width;\n          track.height = config.height;\n          track.sps = [currentNal.data];\n          track.profileIdc = config.profileIdc;\n          track.levelIdc = config.levelIdc;\n          track.profileCompatibility = config.profileCompatibility;\n          h264Frame.endNalUnit();\n        } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n          track.newMetadata = true;\n          track.pps = [currentNal.data];\n          h264Frame.endNalUnit();\n        } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n          if (h264Frame) {\n            this.finishFrame(tags, h264Frame);\n          }\n\n          h264Frame = new flvTag(flvTag.VIDEO_TAG);\n          h264Frame.pts = currentNal.pts;\n          h264Frame.dts = currentNal.dts;\n        } else {\n          if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n            // the current sample is a key frame\n            h264Frame.keyFrame = true;\n          }\n\n          h264Frame.endNalUnit();\n        }\n\n        h264Frame.startNalUnit();\n        h264Frame.writeBytes(currentNal.data);\n      }\n\n      if (h264Frame) {\n        this.finishFrame(tags, h264Frame);\n      }\n\n      this.trigger('data', {\n        track: track,\n        tags: tags.list\n      }); // Continue with the flush process now\n\n      this.trigger('done', 'VideoSegmentStream');\n    };\n  };\n\n  _VideoSegmentStream.prototype = new stream();\n  /**\n   * An object that incrementally transmuxes MPEG2 Trasport Stream\n   * chunks into an FLV.\n   */\n\n  _Transmuxer = function Transmuxer(options) {\n    var self = this,\n        packetStream,\n        parseStream,\n        elementaryStream,\n        videoTimestampRolloverStream,\n        audioTimestampRolloverStream,\n        timedMetadataTimestampRolloverStream,\n        adtsStream,\n        h264Stream,\n        videoSegmentStream,\n        audioSegmentStream,\n        captionStream,\n        coalesceStream$1;\n\n    _Transmuxer.prototype.init.call(this);\n\n    options = options || {}; // expose the metadata stream\n\n    this.metadataStream = new m2ts_1.MetadataStream();\n    options.metadataStream = this.metadataStream; // set up the parsing pipeline\n\n    packetStream = new m2ts_1.TransportPacketStream();\n    parseStream = new m2ts_1.TransportParseStream();\n    elementaryStream = new m2ts_1.ElementaryStream();\n    videoTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('video');\n    audioTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('audio');\n    timedMetadataTimestampRolloverStream = new m2ts_1.TimestampRolloverStream('timed-metadata');\n    adtsStream = new adts();\n    h264Stream = new H264Stream();\n    coalesceStream$1 = new coalesceStream(options); // disassemble MPEG2-TS packets into elementary streams\n\n    packetStream.pipe(parseStream).pipe(elementaryStream); // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n\n    elementaryStream.pipe(videoTimestampRolloverStream).pipe(h264Stream);\n    elementaryStream.pipe(audioTimestampRolloverStream).pipe(adtsStream);\n    elementaryStream.pipe(timedMetadataTimestampRolloverStream).pipe(this.metadataStream).pipe(coalesceStream$1); // if CEA-708 parsing is available, hook up a caption stream\n\n    captionStream = new m2ts_1.CaptionStream(options);\n    h264Stream.pipe(captionStream).pipe(coalesceStream$1); // hook up the segment streams once track metadata is delivered\n\n    elementaryStream.on('data', function (data) {\n      var i, videoTrack, audioTrack;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length; // scan the tracks listed in the metadata\n\n        while (i--) {\n          if (data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n          } else if (data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n          }\n        } // hook up the video segment stream to the first track with h264 data\n\n\n        if (videoTrack && !videoSegmentStream) {\n          coalesceStream$1.numberOfTracks++;\n          videoSegmentStream = new _VideoSegmentStream(videoTrack); // Set up the final part of the video pipeline\n\n          h264Stream.pipe(videoSegmentStream).pipe(coalesceStream$1);\n        }\n\n        if (audioTrack && !audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          coalesceStream$1.numberOfTracks++;\n          audioSegmentStream = new _AudioSegmentStream(audioTrack); // Set up the final part of the audio pipeline\n\n          adtsStream.pipe(audioSegmentStream).pipe(coalesceStream$1);\n\n          if (videoSegmentStream) {\n            videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n          }\n        }\n      }\n    }); // feed incoming data to the front of the parsing pipeline\n\n    this.push = function (data) {\n      packetStream.push(data);\n    }; // flush any buffered data\n\n\n    this.flush = function () {\n      // Start at the top of the pipeline and flush all pending work\n      packetStream.flush();\n    }; // Caption data has to be reset when seeking outside buffered range\n\n\n    this.resetCaptions = function () {\n      captionStream.reset();\n    }; // Re-emit any data coming from the coalesce stream to the outside world\n\n\n    coalesceStream$1.on('data', function (event) {\n      self.trigger('data', event);\n    }); // Let the consumer know we have finished flushing the entire pipeline\n\n    coalesceStream$1.on('done', function () {\n      self.trigger('done');\n    });\n  };\n\n  _Transmuxer.prototype = new stream(); // forward compatibility\n\n  var transmuxer$1 = _Transmuxer;\n\n  // http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\n  // Technically, this function returns the header and a metadata FLV tag\n  // if duration is greater than zero\n  // duration in seconds\n  // @return {object} the bytes of the FLV header as a Uint8Array\n\n\n  var getFlvHeader = function getFlvHeader(duration, audio, video) {\n    // :ByteArray {\n    var headBytes = new Uint8Array(3 + 1 + 1 + 4),\n        head = new DataView(headBytes.buffer),\n        metadata,\n        result,\n        metadataLength; // default arguments\n\n    duration = duration || 0;\n    audio = audio === undefined ? true : audio;\n    video = video === undefined ? true : video; // signature\n\n    head.setUint8(0, 0x46); // 'F'\n\n    head.setUint8(1, 0x4c); // 'L'\n\n    head.setUint8(2, 0x56); // 'V'\n    // version\n\n    head.setUint8(3, 0x01); // flags\n\n    head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00)); // data offset, should be 9 for FLV v1\n\n    head.setUint32(5, headBytes.byteLength); // init the first FLV tag\n\n    if (duration <= 0) {\n      // no duration available so just write the first field of the first\n      // FLV tag\n      result = new Uint8Array(headBytes.byteLength + 4);\n      result.set(headBytes);\n      result.set([0, 0, 0, 0], headBytes.byteLength);\n      return result;\n    } // write out the duration metadata tag\n\n\n    metadata = new flvTag(flvTag.METADATA_TAG);\n    metadata.pts = metadata.dts = 0;\n    metadata.writeMetaDataDouble('duration', duration);\n    metadataLength = metadata.finalize().length;\n    result = new Uint8Array(headBytes.byteLength + metadataLength);\n    result.set(headBytes);\n    result.set(head.byteLength, metadataLength);\n    return result;\n  };\n\n  var flvHeader = getFlvHeader;\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var flv = {\n    tag: flvTag,\n    Transmuxer: transmuxer$1,\n    getFlvHeader: flvHeader\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var m2ts = m2ts_1;\n\n  var ONE_SECOND_IN_TS$1 = clock.ONE_SECOND_IN_TS;\n  /**\n   * Constructs a single-track, ISO BMFF media segment from AAC data\n   * events. The output of this stream can be fed to a SourceBuffer\n   * configured with a suitable initialization segment.\n   */\n\n  var AudioSegmentStream = function AudioSegmentStream(track, options) {\n    var adtsFrames = [],\n        sequenceNumber = 0,\n        earliestAllowedDts = 0,\n        audioAppendStartTs = 0,\n        videoBaseMediaDecodeTime = Infinity,\n        segmentStartPts = null,\n        segmentEndPts = null;\n    options = options || {};\n    AudioSegmentStream.prototype.init.call(this);\n\n    this.push = function (data) {\n      trackDecodeInfo.collectDtsInfo(track, data);\n\n      if (track) {\n        audioProperties.forEach(function (prop) {\n          track[prop] = data[prop];\n        });\n      } // buffer audio data until end() is called\n\n\n      adtsFrames.push(data);\n    };\n\n    this.setEarliestDts = function (earliestDts) {\n      earliestAllowedDts = earliestDts;\n    };\n\n    this.setVideoBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      videoBaseMediaDecodeTime = baseMediaDecodeTime;\n    };\n\n    this.setAudioAppendStart = function (timestamp) {\n      audioAppendStartTs = timestamp;\n    };\n\n    this.processFrames_ = function () {\n      var frames, moof, mdat, boxes, timingInfo; // return early if no audio data has been observed\n\n      if (adtsFrames.length === 0) {\n        return;\n      }\n\n      frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);\n\n      if (frames.length === 0) {\n        // return early if the frames are all after the earliest allowed DTS\n        // TODO should we clear the adtsFrames?\n        return;\n      }\n\n      track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n      audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime); // we have to build the index from byte locations to\n      // samples (that is, adts frames) in the audio data\n\n      track.samples = audioFrameUtils.generateSampleTable(frames); // concatenate the audio data to constuct the mdat\n\n      mdat = mp4Generator.mdat(audioFrameUtils.concatenateFrameData(frames));\n      adtsFrames = [];\n      moof = mp4Generator.moof(sequenceNumber, [track]); // bump the sequence number for next time\n\n      sequenceNumber++;\n      track.initSegment = mp4Generator.initSegment([track]); // it would be great to allocate this array up front instead of\n      // throwing away hundreds of media segment fragments\n\n      boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n      boxes.set(moof);\n      boxes.set(mdat, moof.byteLength);\n      trackDecodeInfo.clearDtsInfo(track);\n\n      if (segmentStartPts === null) {\n        segmentEndPts = segmentStartPts = frames[0].pts;\n      }\n\n      segmentEndPts += frames.length * (ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);\n      timingInfo = {\n        start: segmentStartPts\n      };\n      this.trigger('timingInfo', timingInfo);\n      this.trigger('data', {\n        track: track,\n        boxes: boxes\n      });\n    };\n\n    this.flush = function () {\n      this.processFrames_(); // trigger final timing info\n\n      this.trigger('timingInfo', {\n        start: segmentStartPts,\n        end: segmentEndPts\n      });\n      this.resetTiming_();\n      this.trigger('done', 'AudioSegmentStream');\n    };\n\n    this.partialFlush = function () {\n      this.processFrames_();\n      this.trigger('partialdone', 'AudioSegmentStream');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline', 'AudioSegmentStream');\n    };\n\n    this.resetTiming_ = function () {\n      trackDecodeInfo.clearDtsInfo(track);\n      segmentStartPts = null;\n      segmentEndPts = null;\n    };\n\n    this.reset = function () {\n      this.resetTiming_();\n      adtsFrames = [];\n      this.trigger('reset');\n    };\n  };\n\n  AudioSegmentStream.prototype = new stream();\n  var audioSegmentStream = AudioSegmentStream;\n\n  var VideoSegmentStream = function VideoSegmentStream(track, options) {\n    var sequenceNumber = 0,\n        nalUnits = [],\n        frameCache = [],\n        // gopsToAlignWith = [],\n    config,\n        pps,\n        segmentStartPts = null,\n        segmentEndPts = null,\n        gops,\n        ensureNextFrameIsKeyFrame = true;\n    options = options || {};\n    VideoSegmentStream.prototype.init.call(this);\n\n    this.push = function (nalUnit) {\n      trackDecodeInfo.collectDtsInfo(track, nalUnit);\n\n      if (typeof track.timelineStartInfo.dts === 'undefined') {\n        track.timelineStartInfo.dts = nalUnit.dts;\n      } // record the track config\n\n\n      if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n        config = nalUnit.config;\n        track.sps = [nalUnit.data];\n        videoProperties.forEach(function (prop) {\n          track[prop] = config[prop];\n        }, this);\n      }\n\n      if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' && !pps) {\n        pps = nalUnit.data;\n        track.pps = [nalUnit.data];\n      } // buffer video until flush() is called\n\n\n      nalUnits.push(nalUnit);\n    };\n\n    this.processNals_ = function (cacheLastFrame) {\n      var i;\n      nalUnits = frameCache.concat(nalUnits); // Throw away nalUnits at the start of the byte stream until\n      // we find the first AUD\n\n      while (nalUnits.length) {\n        if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n          break;\n        }\n\n        nalUnits.shift();\n      } // Return early if no video data has been observed\n\n\n      if (nalUnits.length === 0) {\n        return;\n      }\n\n      var frames = frameUtils.groupNalsIntoFrames(nalUnits);\n\n      if (!frames.length) {\n        return;\n      } // note that the frame cache may also protect us from cases where we haven't\n      // pushed data for the entire first or last frame yet\n\n\n      frameCache = frames[frames.length - 1];\n\n      if (cacheLastFrame) {\n        frames.pop();\n        frames.duration -= frameCache.duration;\n        frames.nalCount -= frameCache.length;\n        frames.byteLength -= frameCache.byteLength;\n      }\n\n      if (!frames.length) {\n        nalUnits = [];\n        return;\n      }\n\n      this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n      if (ensureNextFrameIsKeyFrame) {\n        gops = frameUtils.groupFramesIntoGops(frames);\n\n        if (!gops[0][0].keyFrame) {\n          gops = frameUtils.extendFirstKeyFrame(gops);\n\n          if (!gops[0][0].keyFrame) {\n            // we haven't yet gotten a key frame, so reset nal units to wait for more nal\n            // units\n            nalUnits = [].concat.apply([], frames).concat(frameCache);\n            frameCache = [];\n            return;\n          }\n\n          frames = [].concat.apply([], gops);\n          frames.duration = gops.duration;\n        }\n\n        ensureNextFrameIsKeyFrame = false;\n      }\n\n      if (segmentStartPts === null) {\n        segmentStartPts = frames[0].pts;\n        segmentEndPts = segmentStartPts;\n      }\n\n      segmentEndPts += frames.duration;\n      this.trigger('timingInfo', {\n        start: segmentStartPts,\n        end: segmentEndPts\n      });\n\n      for (i = 0; i < frames.length; i++) {\n        var frame = frames[i];\n        track.samples = frameUtils.generateSampleTableForFrame(frame);\n        var mdat = mp4Generator.mdat(frameUtils.concatenateNalDataForFrame(frame));\n        trackDecodeInfo.clearDtsInfo(track);\n        trackDecodeInfo.collectDtsInfo(track, frame);\n        track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);\n        var moof = mp4Generator.moof(sequenceNumber, [track]);\n        sequenceNumber++;\n        track.initSegment = mp4Generator.initSegment([track]);\n        var boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n        boxes.set(moof);\n        boxes.set(mdat, moof.byteLength);\n        this.trigger('data', {\n          track: track,\n          boxes: boxes,\n          sequence: sequenceNumber,\n          videoFrameDts: frame.dts,\n          videoFramePts: frame.pts\n        });\n      }\n\n      nalUnits = [];\n    };\n\n    this.resetTimingAndConfig_ = function () {\n      config = undefined;\n      pps = undefined;\n      segmentStartPts = null;\n      segmentEndPts = null;\n    };\n\n    this.partialFlush = function () {\n      this.processNals_(true);\n      this.trigger('partialdone', 'VideoSegmentStream');\n    };\n\n    this.flush = function () {\n      this.processNals_(false); // reset config and pps because they may differ across segments\n      // for instance, when we are rendition switching\n\n      this.resetTimingAndConfig_();\n      this.trigger('done', 'VideoSegmentStream');\n    };\n\n    this.endTimeline = function () {\n      this.flush();\n      this.trigger('endedtimeline', 'VideoSegmentStream');\n    };\n\n    this.reset = function () {\n      this.resetTimingAndConfig_();\n      frameCache = [];\n      nalUnits = [];\n      ensureNextFrameIsKeyFrame = true;\n      this.trigger('reset');\n    };\n  };\n\n  VideoSegmentStream.prototype = new stream();\n  var videoSegmentStream = VideoSegmentStream;\n\n  var isLikelyAacData = utils.isLikelyAacData;\n\n  var createPipeline = function createPipeline(object) {\n    object.prototype = new stream();\n    object.prototype.init.call(object);\n    return object;\n  };\n\n  var tsPipeline = function tsPipeline(options) {\n    var pipeline = {\n      type: 'ts',\n      tracks: {\n        audio: null,\n        video: null\n      },\n      packet: new m2ts_1.TransportPacketStream(),\n      parse: new m2ts_1.TransportParseStream(),\n      elementary: new m2ts_1.ElementaryStream(),\n      timestampRollover: new m2ts_1.TimestampRolloverStream(),\n      adts: new codecs.Adts(),\n      h264: new codecs.h264.H264Stream(),\n      captionStream: new m2ts_1.CaptionStream(options),\n      metadataStream: new m2ts_1.MetadataStream()\n    };\n    pipeline.headOfPipeline = pipeline.packet; // Transport Stream\n\n    pipeline.packet.pipe(pipeline.parse).pipe(pipeline.elementary).pipe(pipeline.timestampRollover); // H264\n\n    pipeline.timestampRollover.pipe(pipeline.h264); // Hook up CEA-608/708 caption stream\n\n    pipeline.h264.pipe(pipeline.captionStream);\n    pipeline.timestampRollover.pipe(pipeline.metadataStream); // ADTS\n\n    pipeline.timestampRollover.pipe(pipeline.adts);\n    pipeline.elementary.on('data', function (data) {\n      if (data.type !== 'metadata') {\n        return;\n      }\n\n      for (var i = 0; i < data.tracks.length; i++) {\n        if (!pipeline.tracks[data.tracks[i].type]) {\n          pipeline.tracks[data.tracks[i].type] = data.tracks[i];\n          pipeline.tracks[data.tracks[i].type].timelineStartInfo.baseMediaDecodeTime = options.baseMediaDecodeTime;\n        }\n      }\n\n      if (pipeline.tracks.video && !pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream = new videoSegmentStream(pipeline.tracks.video, options);\n        pipeline.videoSegmentStream.on('timelineStartInfo', function (timelineStartInfo) {\n          if (pipeline.tracks.audio && !options.keepOriginalTimestamps) {\n            pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - options.baseMediaDecodeTime);\n          }\n        });\n        pipeline.videoSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'videoTimingInfo'));\n        pipeline.videoSegmentStream.on('data', function (data) {\n          pipeline.trigger('data', {\n            type: 'video',\n            data: data\n          });\n        });\n        pipeline.videoSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n        pipeline.videoSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n        pipeline.videoSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n        pipeline.h264.pipe(pipeline.videoSegmentStream);\n      }\n\n      if (pipeline.tracks.audio && !pipeline.audioSegmentStream) {\n        pipeline.audioSegmentStream = new audioSegmentStream(pipeline.tracks.audio, options);\n        pipeline.audioSegmentStream.on('data', function (data) {\n          pipeline.trigger('data', {\n            type: 'audio',\n            data: data\n          });\n        });\n        pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n        pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n        pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n        pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo'));\n        pipeline.adts.pipe(pipeline.audioSegmentStream);\n      } // emit pmt info\n\n\n      pipeline.trigger('trackinfo', {\n        hasAudio: !!pipeline.tracks.audio,\n        hasVideo: !!pipeline.tracks.video\n      });\n    });\n    pipeline.captionStream.on('data', function (caption) {\n      var timelineStartPts;\n\n      if (pipeline.tracks.video) {\n        timelineStartPts = pipeline.tracks.video.timelineStartInfo.pts || 0;\n      } else {\n        // This will only happen if we encounter caption packets before\n        // video data in a segment. This is an unusual/unlikely scenario,\n        // so we assume the timeline starts at zero for now.\n        timelineStartPts = 0;\n      } // Translate caption PTS times into second offsets into the\n      // video timeline for the segment\n\n\n      caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, options.keepOriginalTimestamps);\n      caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, options.keepOriginalTimestamps);\n      pipeline.trigger('caption', caption);\n    });\n    pipeline = createPipeline(pipeline);\n    pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n    return pipeline;\n  };\n\n  var aacPipeline = function aacPipeline(options) {\n    var pipeline = {\n      type: 'aac',\n      tracks: {\n        audio: null\n      },\n      metadataStream: new m2ts_1.MetadataStream(),\n      aacStream: new aac(),\n      audioRollover: new m2ts_1.TimestampRolloverStream('audio'),\n      timedMetadataRollover: new m2ts_1.TimestampRolloverStream('timed-metadata'),\n      adtsStream: new adts(true)\n    }; // set up the parsing pipeline\n\n    pipeline.headOfPipeline = pipeline.aacStream;\n    pipeline.aacStream.pipe(pipeline.audioRollover).pipe(pipeline.adtsStream);\n    pipeline.aacStream.pipe(pipeline.timedMetadataRollover).pipe(pipeline.metadataStream);\n    pipeline.metadataStream.on('timestamp', function (frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n    pipeline.aacStream.on('data', function (data) {\n      if (data.type !== 'timed-metadata' && data.type !== 'audio' || pipeline.audioSegmentStream) {\n        return;\n      }\n\n      pipeline.tracks.audio = pipeline.tracks.audio || {\n        timelineStartInfo: {\n          baseMediaDecodeTime: options.baseMediaDecodeTime\n        },\n        codec: 'adts',\n        type: 'audio'\n      }; // hook up the audio segment stream to the first track with aac data\n\n      pipeline.audioSegmentStream = new audioSegmentStream(pipeline.tracks.audio, options);\n      pipeline.audioSegmentStream.on('data', function (data) {\n        pipeline.trigger('data', {\n          type: 'audio',\n          data: data\n        });\n      });\n      pipeline.audioSegmentStream.on('partialdone', pipeline.trigger.bind(pipeline, 'partialdone'));\n      pipeline.audioSegmentStream.on('done', pipeline.trigger.bind(pipeline, 'done'));\n      pipeline.audioSegmentStream.on('endedtimeline', pipeline.trigger.bind(pipeline, 'endedtimeline'));\n      pipeline.audioSegmentStream.on('timingInfo', pipeline.trigger.bind(pipeline, 'audioTimingInfo')); // Set up the final part of the audio pipeline\n\n      pipeline.adtsStream.pipe(pipeline.audioSegmentStream);\n      pipeline.trigger('trackinfo', {\n        hasAudio: !!pipeline.tracks.audio,\n        hasVideo: !!pipeline.tracks.video\n      });\n    }); // set the pipeline up as a stream before binding to get access to the trigger function\n\n    pipeline = createPipeline(pipeline);\n    pipeline.metadataStream.on('data', pipeline.trigger.bind(pipeline, 'id3Frame'));\n    return pipeline;\n  };\n\n  var setupPipelineListeners = function setupPipelineListeners(pipeline, transmuxer) {\n    pipeline.on('data', transmuxer.trigger.bind(transmuxer, 'data'));\n    pipeline.on('done', transmuxer.trigger.bind(transmuxer, 'done'));\n    pipeline.on('partialdone', transmuxer.trigger.bind(transmuxer, 'partialdone'));\n    pipeline.on('endedtimeline', transmuxer.trigger.bind(transmuxer, 'endedtimeline'));\n    pipeline.on('audioTimingInfo', transmuxer.trigger.bind(transmuxer, 'audioTimingInfo'));\n    pipeline.on('videoTimingInfo', transmuxer.trigger.bind(transmuxer, 'videoTimingInfo'));\n    pipeline.on('trackinfo', transmuxer.trigger.bind(transmuxer, 'trackinfo'));\n    pipeline.on('id3Frame', function (event) {\n      // add this to every single emitted segment even though it's only needed for the first\n      event.dispatchType = pipeline.metadataStream.dispatchType; // keep original time, can be adjusted if needed at a higher level\n\n      event.cueTime = clock.videoTsToSeconds(event.pts);\n      transmuxer.trigger('id3Frame', event);\n    });\n    pipeline.on('caption', function (event) {\n      transmuxer.trigger('caption', event);\n    });\n  };\n\n  var Transmuxer = function Transmuxer(options) {\n    var pipeline = null,\n        hasFlushed = true;\n    options = options || {};\n    Transmuxer.prototype.init.call(this);\n    options.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n\n    this.push = function (bytes) {\n      if (hasFlushed) {\n        var isAac = isLikelyAacData(bytes);\n\n        if (isAac && (!pipeline || pipeline.type !== 'aac')) {\n          pipeline = aacPipeline(options);\n          setupPipelineListeners(pipeline, this);\n        } else if (!isAac && (!pipeline || pipeline.type !== 'ts')) {\n          pipeline = tsPipeline(options);\n          setupPipelineListeners(pipeline, this);\n        }\n\n        hasFlushed = false;\n      }\n\n      pipeline.headOfPipeline.push(bytes);\n    };\n\n    this.flush = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      hasFlushed = true;\n      pipeline.headOfPipeline.flush();\n    };\n\n    this.partialFlush = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.partialFlush();\n    };\n\n    this.endTimeline = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.endTimeline();\n    };\n\n    this.reset = function () {\n      if (!pipeline) {\n        return;\n      }\n\n      pipeline.headOfPipeline.reset();\n    };\n\n    this.setBaseMediaDecodeTime = function (baseMediaDecodeTime) {\n      if (!options.keepOriginalTimestamps) {\n        options.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n\n      if (!pipeline) {\n        return;\n      }\n\n      if (pipeline.tracks.audio) {\n        pipeline.tracks.audio.timelineStartInfo.dts = undefined;\n        pipeline.tracks.audio.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(pipeline.tracks.audio);\n\n        if (pipeline.audioRollover) {\n          pipeline.audioRollover.discontinuity();\n        }\n      }\n\n      if (pipeline.tracks.video) {\n        if (pipeline.videoSegmentStream) {\n          pipeline.videoSegmentStream.gopCache_ = [];\n        }\n\n        pipeline.tracks.video.timelineStartInfo.dts = undefined;\n        pipeline.tracks.video.timelineStartInfo.pts = undefined;\n        trackDecodeInfo.clearDtsInfo(pipeline.tracks.video); // pipeline.captionStream.reset();\n      }\n\n      if (pipeline.timestampRollover) {\n        pipeline.timestampRollover.discontinuity();\n      }\n    };\n\n    this.setRemux = function (val) {\n      options.remux = val;\n\n      if (pipeline && pipeline.coalesceStream) {\n        pipeline.coalesceStream.setRemux(val);\n      }\n    };\n\n    this.setAudioAppendStart = function (audioAppendStart) {\n      if (!pipeline || !pipeline.tracks.audio || !pipeline.audioSegmentStream) {\n        return;\n      }\n\n      pipeline.audioSegmentStream.setAudioAppendStart(audioAppendStart);\n    }; // TODO GOP alignment support\n    // Support may be a bit trickier than with full segment appends, as GOPs may be split\n    // and processed in a more granular fashion\n\n\n    this.alignGopsWith = function (gopsToAlignWith) {\n      return;\n    };\n  };\n\n  Transmuxer.prototype = new stream();\n  var transmuxer = Transmuxer;\n\n  var partial = {\n    Transmuxer: transmuxer\n  };\n\n  var getUint64$1 = numbers.getUint64;\n\n  var parseSidx = function parseSidx(data) {\n    var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n      version: data[0],\n      flags: new Uint8Array(data.subarray(1, 4)),\n      references: [],\n      referenceId: view.getUint32(4),\n      timescale: view.getUint32(8)\n    },\n        i = 12;\n\n    if (result.version === 0) {\n      result.earliestPresentationTime = view.getUint32(i);\n      result.firstOffset = view.getUint32(i + 4);\n      i += 8;\n    } else {\n      // read 64 bits\n      result.earliestPresentationTime = getUint64$1(data.subarray(i));\n      result.firstOffset = getUint64$1(data.subarray(i + 8));\n      i += 16;\n    }\n\n    i += 2; // reserved\n\n    var referenceCount = view.getUint16(i);\n    i += 2; // start of references\n\n    for (; referenceCount > 0; i += 12, referenceCount--) {\n      result.references.push({\n        referenceType: (data[i] & 0x80) >>> 7,\n        referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n        subsegmentDuration: view.getUint32(i + 4),\n        startsWithSap: !!(data[i + 8] & 0x80),\n        sapType: (data[i + 8] & 0x70) >>> 4,\n        sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n      });\n    }\n\n    return result;\n  };\n\n  var parseSidx_1 = parseSidx;\n\n  var getUint64 = numbers.getUint64;\n\n  var inspectMp4,\n      _textifyMp,\n      parseMp4Date = function parseMp4Date(seconds) {\n    return new Date(seconds * 1000 - 2082844800000);\n  },\n      nalParse = function nalParse(avcStream) {\n    var avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n        result = [],\n        i,\n        length;\n\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4; // bail if this doesn't appear to be an H264 stream\n\n      if (length <= 0) {\n        result.push('<span style=\\'color:red;\\'>MALFORMED DATA</span>');\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n        case 0x01:\n          result.push('slice_layer_without_partitioning_rbsp');\n          break;\n\n        case 0x05:\n          result.push('slice_layer_without_partitioning_rbsp_idr');\n          break;\n\n        case 0x06:\n          result.push('sei_rbsp');\n          break;\n\n        case 0x07:\n          result.push('seq_parameter_set_rbsp');\n          break;\n\n        case 0x08:\n          result.push('pic_parameter_set_rbsp');\n          break;\n\n        case 0x09:\n          result.push('access_unit_delimiter_rbsp');\n          break;\n\n        default:\n          result.push('UNKNOWN NAL - ' + avcStream[i] & 0x1F);\n          break;\n      }\n    }\n\n    return result;\n  },\n      // registry of handlers for individual mp4 box types\n  parse = {\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    avc1: function avc1(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        dataReferenceIndex: view.getUint16(6),\n        width: view.getUint16(24),\n        height: view.getUint16(26),\n        horizresolution: view.getUint16(28) + view.getUint16(30) / 16,\n        vertresolution: view.getUint16(32) + view.getUint16(34) / 16,\n        frameCount: view.getUint16(40),\n        depth: view.getUint16(74),\n        config: inspectMp4(data.subarray(78, data.byteLength))\n      };\n    },\n    avcC: function avcC(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        configurationVersion: data[0],\n        avcProfileIndication: data[1],\n        profileCompatibility: data[2],\n        avcLevelIndication: data[3],\n        lengthSizeMinusOne: data[4] & 0x03,\n        sps: [],\n        pps: []\n      },\n          numOfSequenceParameterSets = data[5] & 0x1f,\n          numOfPictureParameterSets,\n          nalSize,\n          offset,\n          i; // iterate past any SPSs\n\n      offset = 6;\n\n      for (i = 0; i < numOfSequenceParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      } // iterate past any PPSs\n\n\n      numOfPictureParameterSets = data[offset];\n      offset++;\n\n      for (i = 0; i < numOfPictureParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n\n      return result;\n    },\n    btrt: function btrt(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        bufferSizeDB: view.getUint32(0),\n        maxBitrate: view.getUint32(4),\n        avgBitrate: view.getUint32(8)\n      };\n    },\n    edts: function edts(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    elst: function elst(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        edits: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; entryCount--) {\n        if (result.version === 0) {\n          result.edits.push({\n            segmentDuration: view.getUint32(i),\n            mediaTime: view.getInt32(i + 4),\n            mediaRate: view.getUint16(i + 8) + view.getUint16(i + 10) / (256 * 256)\n          });\n          i += 12;\n        } else {\n          result.edits.push({\n            segmentDuration: getUint64(data.subarray(i)),\n            mediaTime: getUint64(data.subarray(i + 8)),\n            mediaRate: view.getUint16(i + 16) + view.getUint16(i + 18) / (256 * 256)\n          });\n          i += 20;\n        }\n      }\n\n      return result;\n    },\n    esds: function esds(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        esId: data[6] << 8 | data[7],\n        streamPriority: data[8] & 0x1f,\n        decoderConfig: {\n          objectProfileIndication: data[11],\n          streamType: data[12] >>> 2 & 0x3f,\n          bufferSize: data[13] << 16 | data[14] << 8 | data[15],\n          maxBitrate: data[16] << 24 | data[17] << 16 | data[18] << 8 | data[19],\n          avgBitrate: data[20] << 24 | data[21] << 16 | data[22] << 8 | data[23],\n          decoderConfigDescriptor: {\n            tag: data[24],\n            length: data[25],\n            audioObjectType: data[26] >>> 3 & 0x1f,\n            samplingFrequencyIndex: (data[26] & 0x07) << 1 | data[27] >>> 7 & 0x01,\n            channelConfiguration: data[27] >>> 3 & 0x0f\n          }\n        }\n      };\n    },\n    ftyp: function ftyp(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        majorBrand: parseType_1(data.subarray(0, 4)),\n        minorVersion: view.getUint32(4),\n        compatibleBrands: []\n      },\n          i = 8;\n\n      while (i < data.byteLength) {\n        result.compatibleBrands.push(parseType_1(data.subarray(i, i + 4)));\n        i += 4;\n      }\n\n      return result;\n    },\n    dinf: function dinf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    dref: function dref(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        dataReferences: inspectMp4(data.subarray(8))\n      };\n    },\n    hdlr: function hdlr(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        handlerType: parseType_1(data.subarray(8, 12)),\n        name: ''\n      },\n          i = 8; // parse out the name field\n\n      for (i = 24; i < data.byteLength; i++) {\n        if (data[i] === 0x00) {\n          // the name field is null-terminated\n          i++;\n          break;\n        }\n\n        result.name += String.fromCharCode(data[i]);\n      } // decode UTF-8 to javascript's internal representation\n      // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n\n\n      result.name = decodeURIComponent(escape(result.name));\n      return result;\n    },\n    mdat: function mdat(data) {\n      return {\n        byteLength: data.byteLength,\n        nals: nalParse(data)\n      };\n    },\n    mdhd: function mdhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          language,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        language: ''\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4; // language is stored as an ISO-639-2/T code in an array of three 5-bit fields\n      // each field is the packed difference between its ASCII value and 0x60\n\n      language = view.getUint16(i);\n      result.language += String.fromCharCode((language >> 10) + 0x60);\n      result.language += String.fromCharCode(((language & 0x03e0) >> 5) + 0x60);\n      result.language += String.fromCharCode((language & 0x1f) + 0x60);\n      return result;\n    },\n    mdia: function mdia(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mfhd: function mfhd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sequenceNumber: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]\n      };\n    },\n    minf: function minf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    mp4a: function mp4a(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        // 6 bytes reserved\n        dataReferenceIndex: view.getUint16(6),\n        // 4 + 4 bytes reserved\n        channelcount: view.getUint16(16),\n        samplesize: view.getUint16(18),\n        // 2 bytes pre_defined\n        // 2 bytes reserved\n        samplerate: view.getUint16(24) + view.getUint16(26) / 65536\n      }; // if there are more bytes to process, assume this is an ISO/IEC\n      // 14496-14 MP4AudioSampleEntry and parse the ESDBox\n\n      if (data.byteLength > 28) {\n        result.streamDescriptor = inspectMp4(data.subarray(28))[0];\n      }\n\n      return result;\n    },\n    moof: function moof(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    moov: function moov(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvex: function mvex(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvhd: function mvhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4; // convert fixed-point, base 16 back to a number\n\n      result.rate = view.getUint16(i) + view.getUint16(i + 2) / 16;\n      i += 4;\n      result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n      i += 2;\n      i += 2;\n      i += 2 * 4;\n      result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n      i += 9 * 4;\n      i += 6 * 4;\n      result.nextTrackId = view.getUint32(i);\n      return result;\n    },\n    pdin: function pdin(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        rate: view.getUint32(4),\n        initialDelay: view.getUint32(8)\n      };\n    },\n    sdtp: function sdtp(data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        samples: []\n      },\n          i;\n\n      for (i = 4; i < data.byteLength; i++) {\n        result.samples.push({\n          dependsOn: (data[i] & 0x30) >> 4,\n          isDependedOn: (data[i] & 0x0c) >> 2,\n          hasRedundancy: data[i] & 0x03\n        });\n      }\n\n      return result;\n    },\n    sidx: parseSidx_1,\n    smhd: function smhd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        balance: data[4] + data[5] / 256\n      };\n    },\n    stbl: function stbl(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    ctts: function ctts(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        compositionOffsets: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.compositionOffsets.push({\n          sampleCount: view.getUint32(i),\n          sampleOffset: view[result.version === 0 ? 'getUint32' : 'getInt32'](i + 4)\n        });\n      }\n\n      return result;\n    },\n    stss: function stss(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        syncSamples: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.syncSamples.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stco: function stco(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        chunkOffsets: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.chunkOffsets.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stsc: function stsc(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          entryCount = view.getUint32(4),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleToChunks: []\n      },\n          i;\n\n      for (i = 8; entryCount; i += 12, entryCount--) {\n        result.sampleToChunks.push({\n          firstChunk: view.getUint32(i),\n          samplesPerChunk: view.getUint32(i + 4),\n          sampleDescriptionIndex: view.getUint32(i + 8)\n        });\n      }\n\n      return result;\n    },\n    stsd: function stsd(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleDescriptions: inspectMp4(data.subarray(8))\n      };\n    },\n    stsz: function stsz(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleSize: view.getUint32(4),\n        entries: []\n      },\n          i;\n\n      for (i = 12; i < data.byteLength; i += 4) {\n        result.entries.push(view.getUint32(i));\n      }\n\n      return result;\n    },\n    stts: function stts(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        timeToSamples: []\n      },\n          entryCount = view.getUint32(4),\n          i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.timeToSamples.push({\n          sampleCount: view.getUint32(i),\n          sampleDelta: view.getUint32(i + 4)\n        });\n      }\n\n      return result;\n    },\n    styp: function styp(data) {\n      return parse.ftyp(data);\n    },\n    tfdt: parseTfdt,\n    tfhd: parseTfhd,\n    tkhd: function tkhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          i = 4,\n          result = {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n\n      i += 4;\n      i += 2 * 4;\n      result.layer = view.getUint16(i);\n      i += 2;\n      result.alternateGroup = view.getUint16(i);\n      i += 2; // convert fixed-point, base 16 back to a number\n\n      result.volume = view.getUint8(i) + view.getUint8(i + 1) / 8;\n      i += 2;\n      i += 2;\n      result.matrix = new Uint32Array(data.subarray(i, i + 9 * 4));\n      i += 9 * 4;\n      result.width = view.getUint16(i) + view.getUint16(i + 2) / 65536;\n      i += 4;\n      result.height = view.getUint16(i) + view.getUint16(i + 2) / 65536;\n      return result;\n    },\n    traf: function traf(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trak: function trak(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trex: function trex(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        trackId: view.getUint32(4),\n        defaultSampleDescriptionIndex: view.getUint32(8),\n        defaultSampleDuration: view.getUint32(12),\n        defaultSampleSize: view.getUint32(16),\n        sampleDependsOn: data[20] & 0x03,\n        sampleIsDependedOn: (data[21] & 0xc0) >> 6,\n        sampleHasRedundancy: (data[21] & 0x30) >> 4,\n        samplePaddingValue: (data[21] & 0x0e) >> 1,\n        sampleIsDifferenceSample: !!(data[21] & 0x01),\n        sampleDegradationPriority: view.getUint16(22)\n      };\n    },\n    trun: parseTrun,\n    'url ': function url(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n    },\n    vmhd: function vmhd(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        graphicsmode: view.getUint16(4),\n        opcolor: new Uint16Array([view.getUint16(6), view.getUint16(8), view.getUint16(10)])\n      };\n    }\n  };\n  /**\n   * Return a javascript array of box objects parsed from an ISO base\n   * media file.\n   * @param data {Uint8Array} the binary data of the media to be inspected\n   * @return {array} a javascript array of potentially nested box objects\n   */\n\n\n  inspectMp4 = function inspectMp4(data) {\n    var i = 0,\n        result = [],\n        view,\n        size,\n        type,\n        end,\n        box; // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API\n\n    var ab = new ArrayBuffer(data.length);\n    var v = new Uint8Array(ab);\n\n    for (var z = 0; z < data.length; ++z) {\n      v[z] = data[z];\n    }\n\n    view = new DataView(ab);\n\n    while (i < data.byteLength) {\n      // parse box data\n      size = view.getUint32(i);\n      type = parseType_1(data.subarray(i + 4, i + 8));\n      end = size > 1 ? i + size : data.byteLength; // parse type-specific data\n\n      box = (parse[type] || function (data) {\n        return {\n          data: data\n        };\n      })(data.subarray(i + 8, end));\n\n      box.size = size;\n      box.type = type; // store this box and move to the next\n\n      result.push(box);\n      i = end;\n    }\n\n    return result;\n  };\n  /**\n   * Returns a textual representation of the javascript represtentation\n   * of an MP4 file. You can use it as an alternative to\n   * JSON.stringify() to compare inspected MP4s.\n   * @param inspectedMp4 {array} the parsed array of boxes in an MP4\n   * file\n   * @param depth {number} (optional) the number of ancestor boxes of\n   * the elements of inspectedMp4. Assumed to be zero if unspecified.\n   * @return {string} a text representation of the parsed MP4\n   */\n\n\n  _textifyMp = function textifyMp4(inspectedMp4, depth) {\n    var indent;\n    depth = depth || 0;\n    indent = new Array(depth * 2 + 1).join(' '); // iterate over all the boxes\n\n    return inspectedMp4.map(function (box, index) {\n      // list the box type first at the current indentation level\n      return indent + box.type + '\\n' + // the type is already included and handle child boxes separately\n      Object.keys(box).filter(function (key) {\n        return key !== 'type' && key !== 'boxes'; // output all the box properties\n      }).map(function (key) {\n        var prefix = indent + '  ' + key + ': ',\n            value = box[key]; // print out raw bytes as hexademical\n\n        if (value instanceof Uint8Array || value instanceof Uint32Array) {\n          var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength)).map(function (byte) {\n            return ' ' + ('00' + byte.toString(16)).slice(-2);\n          }).join('').match(/.{1,24}/g);\n\n          if (!bytes) {\n            return prefix + '<>';\n          }\n\n          if (bytes.length === 1) {\n            return prefix + '<' + bytes.join('').slice(1) + '>';\n          }\n\n          return prefix + '<\\n' + bytes.map(function (line) {\n            return indent + '  ' + line;\n          }).join('\\n') + '\\n' + indent + '  >';\n        } // stringify generic objects\n\n\n        return prefix + JSON.stringify(value, null, 2).split('\\n').map(function (line, index) {\n          if (index === 0) {\n            return line;\n          }\n\n          return indent + '  ' + line;\n        }).join('\\n');\n      }).join('\\n') + ( // recursively textify the child boxes\n      box.boxes ? '\\n' + _textifyMp(box.boxes, depth + 1) : '');\n    }).join('\\n');\n  };\n\n  var mp4Inspector = {\n    inspect: inspectMp4,\n    textify: _textifyMp,\n    parseType: parseType_1,\n    findBox: findBox_1,\n    parseTraf: parse.traf,\n    parseTfdt: parse.tfdt,\n    parseHdlr: parse.hdlr,\n    parseTfhd: parse.tfhd,\n    parseTrun: parse.trun,\n    parseSidx: parse.sidx\n  };\n\n  /**\n   * mux.js\n   *\n   * Copyright (c) Brightcove\n   * Licensed Apache-2.0 https://github.com/videojs/mux.js/blob/master/LICENSE\n   */\n\n  var tagTypes = {\n    0x08: 'audio',\n    0x09: 'video',\n    0x12: 'metadata'\n  },\n      hex = function hex(val) {\n    return '0x' + ('00' + val.toString(16)).slice(-2).toUpperCase();\n  },\n      hexStringList = function hexStringList(data) {\n    var arr = [],\n        i;\n\n    while (data.byteLength > 0) {\n      i = 0;\n      arr.push(hex(data[i++]));\n      data = data.subarray(i);\n    }\n\n    return arr.join(' ');\n  },\n      parseAVCTag = function parseAVCTag(tag, obj) {\n    var avcPacketTypes = ['AVC Sequence Header', 'AVC NALU', 'AVC End-of-Sequence'],\n        compositionTime = tag[1] & parseInt('01111111', 2) << 16 | tag[2] << 8 | tag[3];\n    obj = obj || {};\n    obj.avcPacketType = avcPacketTypes[tag[0]];\n    obj.CompositionTime = tag[1] & parseInt('10000000', 2) ? -compositionTime : compositionTime;\n\n    if (tag[0] === 1) {\n      obj.nalUnitTypeRaw = hexStringList(tag.subarray(4, 100));\n    } else {\n      obj.data = hexStringList(tag.subarray(4));\n    }\n\n    return obj;\n  },\n      parseVideoTag = function parseVideoTag(tag, obj) {\n    var frameTypes = ['Unknown', 'Keyframe (for AVC, a seekable frame)', 'Inter frame (for AVC, a nonseekable frame)', 'Disposable inter frame (H.263 only)', 'Generated keyframe (reserved for server use only)', 'Video info/command frame'],\n        codecID = tag[0] & parseInt('00001111', 2);\n    obj = obj || {};\n    obj.frameType = frameTypes[(tag[0] & parseInt('11110000', 2)) >>> 4];\n    obj.codecID = codecID;\n\n    if (codecID === 7) {\n      return parseAVCTag(tag.subarray(1), obj);\n    }\n\n    return obj;\n  },\n      parseAACTag = function parseAACTag(tag, obj) {\n    var packetTypes = ['AAC Sequence Header', 'AAC Raw'];\n    obj = obj || {};\n    obj.aacPacketType = packetTypes[tag[0]];\n    obj.data = hexStringList(tag.subarray(1));\n    return obj;\n  },\n      parseAudioTag = function parseAudioTag(tag, obj) {\n    var formatTable = ['Linear PCM, platform endian', 'ADPCM', 'MP3', 'Linear PCM, little endian', 'Nellymoser 16-kHz mono', 'Nellymoser 8-kHz mono', 'Nellymoser', 'G.711 A-law logarithmic PCM', 'G.711 mu-law logarithmic PCM', 'reserved', 'AAC', 'Speex', 'MP3 8-Khz', 'Device-specific sound'],\n        samplingRateTable = ['5.5-kHz', '11-kHz', '22-kHz', '44-kHz'],\n        soundFormat = (tag[0] & parseInt('11110000', 2)) >>> 4;\n    obj = obj || {};\n    obj.soundFormat = formatTable[soundFormat];\n    obj.soundRate = samplingRateTable[(tag[0] & parseInt('00001100', 2)) >>> 2];\n    obj.soundSize = (tag[0] & parseInt('00000010', 2)) >>> 1 ? '16-bit' : '8-bit';\n    obj.soundType = tag[0] & parseInt('00000001', 2) ? 'Stereo' : 'Mono';\n\n    if (soundFormat === 10) {\n      return parseAACTag(tag.subarray(1), obj);\n    }\n\n    return obj;\n  },\n      parseGenericTag = function parseGenericTag(tag) {\n    return {\n      tagType: tagTypes[tag[0]],\n      dataSize: tag[1] << 16 | tag[2] << 8 | tag[3],\n      timestamp: tag[7] << 24 | tag[4] << 16 | tag[5] << 8 | tag[6],\n      streamID: tag[8] << 16 | tag[9] << 8 | tag[10]\n    };\n  },\n      inspectFlvTag = function inspectFlvTag(tag) {\n    var header = parseGenericTag(tag);\n\n    switch (tag[0]) {\n      case 0x08:\n        parseAudioTag(tag.subarray(11), header);\n        break;\n\n      case 0x09:\n        parseVideoTag(tag.subarray(11), header);\n        break;\n    }\n\n    return header;\n  },\n      inspectFlv = function inspectFlv(bytes) {\n    var i = 9,\n        // header\n    dataSize,\n        parsedResults = [],\n        tag; // traverse the tags\n\n    i += 4; // skip previous tag size\n\n    while (i < bytes.byteLength) {\n      dataSize = bytes[i + 1] << 16;\n      dataSize |= bytes[i + 2] << 8;\n      dataSize |= bytes[i + 3];\n      dataSize += 11;\n      tag = bytes.subarray(i, i + dataSize);\n      parsedResults.push(inspectFlvTag(tag));\n      i += dataSize + 4;\n    }\n\n    return parsedResults;\n  },\n      textifyFlv = function textifyFlv(flvTagArray) {\n    return JSON.stringify(flvTagArray, null, 2);\n  };\n\n  var flvInspector = {\n    inspectTag: inspectFlvTag,\n    inspect: inspectFlv,\n    textify: textifyFlv\n  };\n\n  var parsePid = function parsePid(packet) {\n    var pid = packet[1] & 0x1f;\n    pid <<= 8;\n    pid |= packet[2];\n    return pid;\n  };\n\n  var parsePayloadUnitStartIndicator = function parsePayloadUnitStartIndicator(packet) {\n    return !!(packet[1] & 0x40);\n  };\n\n  var parseAdaptionField = function parseAdaptionField(packet) {\n    var offset = 0; // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n\n    if ((packet[3] & 0x30) >>> 4 > 0x01) {\n      offset += packet[4] + 1;\n    }\n\n    return offset;\n  };\n\n  var parseType = function parseType(packet, pmtPid) {\n    var pid = parsePid(packet);\n\n    if (pid === 0) {\n      return 'pat';\n    } else if (pid === pmtPid) {\n      return 'pmt';\n    } else if (pmtPid) {\n      return 'pes';\n    }\n\n    return null;\n  };\n\n  var parsePat = function parsePat(packet) {\n    var pusi = parsePayloadUnitStartIndicator(packet);\n    var offset = 4 + parseAdaptionField(packet);\n\n    if (pusi) {\n      offset += packet[offset] + 1;\n    }\n\n    return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n  };\n\n  var parsePmt = function parsePmt(packet) {\n    var programMapTable = {};\n    var pusi = parsePayloadUnitStartIndicator(packet);\n    var payloadOffset = 4 + parseAdaptionField(packet);\n\n    if (pusi) {\n      payloadOffset += packet[payloadOffset] + 1;\n    } // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n\n\n    if (!(packet[payloadOffset + 5] & 0x01)) {\n      return;\n    }\n\n    var sectionLength, tableEnd, programInfoLength; // the mapping table ends at the end of the current section\n\n    sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n    tableEnd = 3 + sectionLength - 4; // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n\n    programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11]; // advance the offset to the first entry in the mapping table\n\n    var offset = 12 + programInfoLength;\n\n    while (offset < tableEnd) {\n      var i = payloadOffset + offset; // add an entry that maps the elementary_pid to the stream_type\n\n      programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i]; // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n\n      offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n    }\n\n    return programMapTable;\n  };\n\n  var parsePesType = function parsePesType(packet, programMapTable) {\n    var pid = parsePid(packet);\n    var type = programMapTable[pid];\n\n    switch (type) {\n      case streamTypes.H264_STREAM_TYPE:\n        return 'video';\n\n      case streamTypes.ADTS_STREAM_TYPE:\n        return 'audio';\n\n      case streamTypes.METADATA_STREAM_TYPE:\n        return 'timed-metadata';\n\n      default:\n        return null;\n    }\n  };\n\n  var parsePesTime = function parsePesTime(packet) {\n    var pusi = parsePayloadUnitStartIndicator(packet);\n\n    if (!pusi) {\n      return null;\n    }\n\n    var offset = 4 + parseAdaptionField(packet);\n\n    if (offset >= packet.byteLength) {\n      // From the H 222.0 MPEG-TS spec\n      // \"For transport stream packets carrying PES packets, stuffing is needed when there\n      //  is insufficient PES packet data to completely fill the transport stream packet\n      //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n      //  the sum of the lengths of the data elements in it, so that the payload bytes\n      //  remaining after the adaptation field exactly accommodates the available PES packet\n      //  data.\"\n      //\n      // If the offset is >= the length of the packet, then the packet contains no data\n      // and instead is just adaption field stuffing bytes\n      return null;\n    }\n\n    var pes = null;\n    var ptsDtsFlags; // PES packets may be annotated with a PTS value, or a PTS value\n    // and a DTS value. Determine what combination of values is\n    // available to work with.\n\n    ptsDtsFlags = packet[offset + 7]; // PTS and DTS are normally stored as a 33-bit number.  Javascript\n    // performs all bitwise operations on 32-bit integers but javascript\n    // supports a much greater range (52-bits) of integer using standard\n    // mathematical operations.\n    // We construct a 31-bit value using bitwise operators over the 31\n    // most significant bits and then multiply by 4 (equal to a left-shift\n    // of 2) before we add the final 2 least significant bits of the\n    // timestamp (equal to an OR.)\n\n    if (ptsDtsFlags & 0xC0) {\n      pes = {}; // the PTS and DTS are not written out directly. For information\n      // on how they are encoded, see\n      // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n\n      pes.pts = (packet[offset + 9] & 0x0E) << 27 | (packet[offset + 10] & 0xFF) << 20 | (packet[offset + 11] & 0xFE) << 12 | (packet[offset + 12] & 0xFF) << 5 | (packet[offset + 13] & 0xFE) >>> 3;\n      pes.pts *= 4; // Left shift by 2\n\n      pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n\n      pes.dts = pes.pts;\n\n      if (ptsDtsFlags & 0x40) {\n        pes.dts = (packet[offset + 14] & 0x0E) << 27 | (packet[offset + 15] & 0xFF) << 20 | (packet[offset + 16] & 0xFE) << 12 | (packet[offset + 17] & 0xFF) << 5 | (packet[offset + 18] & 0xFE) >>> 3;\n        pes.dts *= 4; // Left shift by 2\n\n        pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n      }\n    }\n\n    return pes;\n  };\n\n  var parseNalUnitType = function parseNalUnitType(type) {\n    switch (type) {\n      case 0x05:\n        return 'slice_layer_without_partitioning_rbsp_idr';\n\n      case 0x06:\n        return 'sei_rbsp';\n\n      case 0x07:\n        return 'seq_parameter_set_rbsp';\n\n      case 0x08:\n        return 'pic_parameter_set_rbsp';\n\n      case 0x09:\n        return 'access_unit_delimiter_rbsp';\n\n      default:\n        return null;\n    }\n  };\n\n  var videoPacketContainsKeyFrame = function videoPacketContainsKeyFrame(packet) {\n    var offset = 4 + parseAdaptionField(packet);\n    var frameBuffer = packet.subarray(offset);\n    var frameI = 0;\n    var frameSyncPoint = 0;\n    var foundKeyFrame = false;\n    var nalType; // advance the sync point to a NAL start, if necessary\n\n    for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n      if (frameBuffer[frameSyncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        frameI = frameSyncPoint + 5;\n        break;\n      }\n    }\n\n    while (frameI < frameBuffer.byteLength) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (frameBuffer[frameI]) {\n        case 0:\n          // skip past non-sync sequences\n          if (frameBuffer[frameI - 1] !== 0) {\n            frameI += 2;\n            break;\n          } else if (frameBuffer[frameI - 2] !== 0) {\n            frameI++;\n            break;\n          }\n\n          if (frameSyncPoint + 3 !== frameI - 2) {\n            nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n            if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n              foundKeyFrame = true;\n            }\n          } // drop trailing zeroes\n\n\n          do {\n            frameI++;\n          } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n\n          frameSyncPoint = frameI - 2;\n          frameI += 3;\n          break;\n\n        case 1:\n          // skip past non-sync sequences\n          if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {\n            frameI += 3;\n            break;\n          }\n\n          nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n          if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n            foundKeyFrame = true;\n          }\n\n          frameSyncPoint = frameI - 2;\n          frameI += 3;\n          break;\n\n        default:\n          // the current byte isn't a one or zero, so it cannot be part\n          // of a sync sequence\n          frameI += 3;\n          break;\n      }\n    }\n\n    frameBuffer = frameBuffer.subarray(frameSyncPoint);\n    frameI -= frameSyncPoint;\n    frameSyncPoint = 0; // parse the final nal\n\n    if (frameBuffer && frameBuffer.byteLength > 3) {\n      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n\n      if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n        foundKeyFrame = true;\n      }\n    }\n\n    return foundKeyFrame;\n  };\n\n  var probe$1 = {\n    parseType: parseType,\n    parsePat: parsePat,\n    parsePmt: parsePmt,\n    parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n    parsePesType: parsePesType,\n    parsePesTime: parsePesTime,\n    videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n  };\n\n  var handleRollover = timestampRolloverStream.handleRollover;\n  var probe = {};\n  probe.ts = probe$1;\n  probe.aac = utils;\n  var ONE_SECOND_IN_TS = clock.ONE_SECOND_IN_TS;\n  var MP2T_PACKET_LENGTH = 188,\n      // bytes\n  SYNC_BYTE = 0x47;\n  /**\n   * walks through segment data looking for pat and pmt packets to parse out\n   * program map table information\n   */\n\n  var parsePsi_ = function parsePsi_(bytes, pmt) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type;\n\n    while (endIndex < bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pat':\n            pmt.pid = probe.ts.parsePat(packet);\n            break;\n\n          case 'pmt':\n            var table = probe.ts.parsePmt(packet);\n            pmt.table = pmt.table || {};\n            Object.keys(table).forEach(function (key) {\n              pmt.table[key] = table[key];\n            });\n            break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    }\n  };\n  /**\n   * walks through the segment data from the start and end to get timing information\n   * for the first and last audio pes packets\n   */\n\n\n  var parseAudioPes_ = function parseAudioPes_(bytes, pmt, result) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type,\n        pesType,\n        pusi,\n        parsed;\n    var endLoop = false; // Start walking from start of segment to get first audio packet\n\n    while (endIndex <= bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'audio' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'audio';\n                result.audio.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    } // Start walking from end of segment to get last audio packet\n\n\n    endIndex = bytes.byteLength;\n    startIndex = endIndex - MP2T_PACKET_LENGTH;\n    endLoop = false;\n\n    while (startIndex >= 0) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'audio' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'audio';\n                result.audio.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex -= MP2T_PACKET_LENGTH;\n        endIndex -= MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex--;\n      endIndex--;\n    }\n  };\n  /**\n   * walks through the segment data from the start and end to get timing information\n   * for the first and last video pes packets as well as timing information for the first\n   * key frame.\n   */\n\n\n  var parseVideoPes_ = function parseVideoPes_(bytes, pmt, result) {\n    var startIndex = 0,\n        endIndex = MP2T_PACKET_LENGTH,\n        packet,\n        type,\n        pesType,\n        pusi,\n        parsed,\n        frame,\n        i,\n        pes;\n    var endLoop = false;\n    var currentFrame = {\n      data: [],\n      size: 0\n    }; // Start walking from start of segment to get first video packet\n\n    while (endIndex < bytes.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'video') {\n              if (pusi && !endLoop) {\n                parsed = probe.ts.parsePesTime(packet);\n\n                if (parsed) {\n                  parsed.type = 'video';\n                  result.video.push(parsed);\n                  endLoop = true;\n                }\n              }\n\n              if (!result.firstKeyFrame) {\n                if (pusi) {\n                  if (currentFrame.size !== 0) {\n                    frame = new Uint8Array(currentFrame.size);\n                    i = 0;\n\n                    while (currentFrame.data.length) {\n                      pes = currentFrame.data.shift();\n                      frame.set(pes, i);\n                      i += pes.byteLength;\n                    }\n\n                    if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                      var firstKeyFrame = probe.ts.parsePesTime(frame); // PTS/DTS may not be available. Simply *not* setting\n                      // the keyframe seems to work fine with HLS playback\n                      // and definitely preferable to a crash with TypeError...\n\n                      if (firstKeyFrame) {\n                        result.firstKeyFrame = firstKeyFrame;\n                        result.firstKeyFrame.type = 'video';\n                      } else {\n                        // eslint-disable-next-line\n                        console.warn('Failed to extract PTS/DTS from PES at first keyframe. ' + 'This could be an unusual TS segment, or else mux.js did not ' + 'parse your TS segment correctly. If you know your TS ' + 'segments do contain PTS/DTS on keyframes please file a bug ' + 'report! You can try ffprobe to double check for yourself.');\n                      }\n                    }\n\n                    currentFrame.size = 0;\n                  }\n                }\n\n                currentFrame.data.push(packet);\n                currentFrame.size += packet.byteLength;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop && result.firstKeyFrame) {\n          break;\n        }\n\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex++;\n      endIndex++;\n    } // Start walking from end of segment to get last video packet\n\n\n    endIndex = bytes.byteLength;\n    startIndex = endIndex - MP2T_PACKET_LENGTH;\n    endLoop = false;\n\n    while (startIndex >= 0) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n        // We found a packet\n        packet = bytes.subarray(startIndex, endIndex);\n        type = probe.ts.parseType(packet, pmt.pid);\n\n        switch (type) {\n          case 'pes':\n            pesType = probe.ts.parsePesType(packet, pmt.table);\n            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n\n            if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n\n            break;\n        }\n\n        if (endLoop) {\n          break;\n        }\n\n        startIndex -= MP2T_PACKET_LENGTH;\n        endIndex -= MP2T_PACKET_LENGTH;\n        continue;\n      } // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n\n\n      startIndex--;\n      endIndex--;\n    }\n  };\n  /**\n   * Adjusts the timestamp information for the segment to account for\n   * rollover and convert to seconds based on pes packet timescale (90khz clock)\n   */\n\n\n  var adjustTimestamp_ = function adjustTimestamp_(segmentInfo, baseTimestamp) {\n    if (segmentInfo.audio && segmentInfo.audio.length) {\n      var audioBaseTimestamp = baseTimestamp;\n\n      if (typeof audioBaseTimestamp === 'undefined' || isNaN(audioBaseTimestamp)) {\n        audioBaseTimestamp = segmentInfo.audio[0].dts;\n      }\n\n      segmentInfo.audio.forEach(function (info) {\n        info.dts = handleRollover(info.dts, audioBaseTimestamp);\n        info.pts = handleRollover(info.pts, audioBaseTimestamp); // time in seconds\n\n        info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n        info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n      });\n    }\n\n    if (segmentInfo.video && segmentInfo.video.length) {\n      var videoBaseTimestamp = baseTimestamp;\n\n      if (typeof videoBaseTimestamp === 'undefined' || isNaN(videoBaseTimestamp)) {\n        videoBaseTimestamp = segmentInfo.video[0].dts;\n      }\n\n      segmentInfo.video.forEach(function (info) {\n        info.dts = handleRollover(info.dts, videoBaseTimestamp);\n        info.pts = handleRollover(info.pts, videoBaseTimestamp); // time in seconds\n\n        info.dtsTime = info.dts / ONE_SECOND_IN_TS;\n        info.ptsTime = info.pts / ONE_SECOND_IN_TS;\n      });\n\n      if (segmentInfo.firstKeyFrame) {\n        var frame = segmentInfo.firstKeyFrame;\n        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n        frame.pts = handleRollover(frame.pts, videoBaseTimestamp); // time in seconds\n\n        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;\n        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;\n      }\n    }\n  };\n  /**\n   * inspects the aac data stream for start and end time information\n   */\n\n\n  var inspectAac_ = function inspectAac_(bytes) {\n    var endLoop = false,\n        audioCount = 0,\n        sampleRate = null,\n        timestamp = null,\n        frameSize = 0,\n        byteIndex = 0,\n        packet;\n\n    while (bytes.length - byteIndex >= 3) {\n      var type = probe.aac.parseType(bytes, byteIndex);\n\n      switch (type) {\n        case 'timed-metadata':\n          // Exit early because we don't have enough to parse\n          // the ID3 tag header\n          if (bytes.length - byteIndex < 10) {\n            endLoop = true;\n            break;\n          }\n\n          frameSize = probe.aac.parseId3TagSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (frameSize > bytes.length) {\n            endLoop = true;\n            break;\n          }\n\n          if (timestamp === null) {\n            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n            timestamp = probe.aac.parseAacTimestamp(packet);\n          }\n\n          byteIndex += frameSize;\n          break;\n\n        case 'audio':\n          // Exit early because we don't have enough to parse\n          // the ADTS frame header\n          if (bytes.length - byteIndex < 7) {\n            endLoop = true;\n            break;\n          }\n\n          frameSize = probe.aac.parseAdtsSize(bytes, byteIndex); // Exit early if we don't have enough in the buffer\n          // to emit a full packet\n\n          if (frameSize > bytes.length) {\n            endLoop = true;\n            break;\n          }\n\n          if (sampleRate === null) {\n            packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n            sampleRate = probe.aac.parseSampleRate(packet);\n          }\n\n          audioCount++;\n          byteIndex += frameSize;\n          break;\n\n        default:\n          byteIndex++;\n          break;\n      }\n\n      if (endLoop) {\n        return null;\n      }\n    }\n\n    if (sampleRate === null || timestamp === null) {\n      return null;\n    }\n\n    var audioTimescale = ONE_SECOND_IN_TS / sampleRate;\n    var result = {\n      audio: [{\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      }, {\n        type: 'audio',\n        dts: timestamp + audioCount * 1024 * audioTimescale,\n        pts: timestamp + audioCount * 1024 * audioTimescale\n      }]\n    };\n    return result;\n  };\n  /**\n   * inspects the transport stream segment data for start and end time information\n   * of the audio and video tracks (when present) as well as the first key frame's\n   * start time.\n   */\n\n\n  var inspectTs_ = function inspectTs_(bytes) {\n    var pmt = {\n      pid: null,\n      table: null\n    };\n    var result = {};\n    parsePsi_(bytes, pmt);\n\n    for (var pid in pmt.table) {\n      if (pmt.table.hasOwnProperty(pid)) {\n        var type = pmt.table[pid];\n\n        switch (type) {\n          case streamTypes.H264_STREAM_TYPE:\n            result.video = [];\n            parseVideoPes_(bytes, pmt, result);\n\n            if (result.video.length === 0) {\n              delete result.video;\n            }\n\n            break;\n\n          case streamTypes.ADTS_STREAM_TYPE:\n            result.audio = [];\n            parseAudioPes_(bytes, pmt, result);\n\n            if (result.audio.length === 0) {\n              delete result.audio;\n            }\n\n            break;\n        }\n      }\n    }\n\n    return result;\n  };\n  /**\n   * Inspects segment byte data and returns an object with start and end timing information\n   *\n   * @param {Uint8Array} bytes The segment byte data\n   * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n   *  timestamps for rollover. This value must be in 90khz clock.\n   * @return {Object} Object containing start and end frame timing info of segment.\n   */\n\n\n  var inspect = function inspect(bytes, baseTimestamp) {\n    var isAacData = probe.aac.isLikelyAacData(bytes);\n    var result;\n\n    if (isAacData) {\n      result = inspectAac_(bytes);\n    } else {\n      result = inspectTs_(bytes);\n    }\n\n    if (!result || !result.audio && !result.video) {\n      return null;\n    }\n\n    adjustTimestamp_(result, baseTimestamp);\n    return result;\n  };\n\n  var tsInspector = {\n    inspect: inspect,\n    parseAudioPes_: parseAudioPes_\n  };\n\n  var muxjs = {\n    codecs: codecs,\n    mp4: mp4,\n    flv: flv,\n    mp2t: m2ts,\n    partial: partial\n  }; // include all the tools when the full library is required\n\n  muxjs.mp4.tools = mp4Inspector;\n  muxjs.flv.tools = flvInspector;\n  muxjs.mp2t.tools = tsInspector;\n  var lib = muxjs;\n\n  return lib;\n\n})));\n","export default function _AwaitValue(value) {\n  this.wrapped = value;\n}","import AwaitValue from \"./AwaitValue.js\";\nexport default function _awaitAsyncGenerator(value) {\n  return new AwaitValue(value);\n}","import AwaitValue from \"./AwaitValue.js\";\nexport default function AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen[\"return\"] !== \"function\") {\n    this[\"return\"] = undefined;\n  }\n}\n\nAsyncGenerator.prototype[typeof Symbol === \"function\" && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n};\n\nAsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\nAsyncGenerator.prototype[\"throw\"] = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\nAsyncGenerator.prototype[\"return\"] = function (arg) {\n  return this._invoke(\"return\", arg);\n};","import AsyncGenerator from \"./AsyncGenerator.js\";\nexport default function _wrapAsyncGenerator(fn) {\n  return function () {\n    return new AsyncGenerator(fn.apply(this, arguments));\n  };\n}"],"names":["win","window","global","self","module","exports","_interopDefaultLegacy","e","window__default","Stream","this","init","listeners","on","type","listener","concat","off","index","indexOf","slice","splice","trigger","callbacks","i","length","args","arguments","call","push","apply","dispose","prototype","pipe","destination","data","flushSource","flush","partialFlush","endTimeline","reset","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","audioTsToVideoTs","videoTsToAudioTs","metadataTsToSeconds","stream","ONE_SECOND_IN_TS$5","timestamp","sampleRate","timelineStartPts","keepOriginalTimestamps","_AdtsStream","clock","ONE_SECOND_IN_TS","seconds","ONE_SECOND_IN_TS$4","ADTS_SAMPLING_FREQUENCIES$1","handlePartialSegments","buffer","frameNum","skipWarn_","start","end","level","message","packet","frameLength","protectionSkipBytes","oldBuffer","sampleCount","adtsFrameDuration","skip","Uint8Array","byteLength","set","pts","dts","audioobjecttype","channelcount","samplerate","samplingfrequencyindex","samplesize","subarray","_H264Stream","_NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","adts","expGolomb","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","position","workingBytes","availableBytes","Math","min","Error","DataView","getUint32","skipBits","count","skipBytes","floor","readBits","size","bits","valu","skipLeadingZeros","leadingZeroCount","skipUnsignedExpGolomb","skipExpGolomb","readUnsignedExpGolomb","clz","readExpGolomb","readBoolean","readUnsignedByte","syncPoint","swapBuffer","len","trackId","currentPts","currentDts","discardEmulationPreventionBytes","readSequenceParameterSet","skipScalingList","nalByteStream","event","nalUnitTypeCode","nalUnitType","escapedRBSP","config","expGolombDecoder","j","lastScale","nextScale","newLength","newData","emulationPreventionBytesPositions","sourceIndex","shift","profileIdc","levelIdc","profileCompatibility","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","sarRatio","width","height","box","dinf","esds","ftyp","mdat","mfhd","minf","moof","moov","mvex","mvhd","trak","tkhd","mdia","mdhd","hdlr","sdtp","stbl","stsd","traf","trex","trun$1","types","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","h264","H264Stream","NalByteStream","codecs","Adts","MAX_UINT32$1","pow","numbers","getUint64","uint8","value","dv","byteOffset","getBigUint64","Number","MAX_SAFE_INTEGER","MAX_UINT32","avc1","avcC","btrt","dref","mp4a","pasp","smhd","stco","stsc","stsz","stts","styp","tfdt","tfhd","trun","vmhd","hasOwnProperty","charCodeAt","video","audio","result","payload","setUint32","track","duration","sequenceNumber","tracks","trackFragments","boxes","bytes","flags","samples","dependsOn","isDependedOn","hasRedundancy","videoSample","audioSample","avc1Box","sps","pps","sequenceParameterSets","pictureParameterSets","Array","hSpacing","vSpacing","id","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","dataOffset","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","baseMediaDecodeTime","audioTrun","videoTrun","trunHeader","offset","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","undefined","bytesOffest","header","sample","isLeading","paddingValue","isNonSyncSample","degradationPriority","timescale","startTime","compositionStartTime","getVideoTrackIds","getTracks","getTimescaleFromMediaHeader","mp4Generator","initSegment","fileType","movie","bin","toUnsigned","toHexString","toString","parseType_1","String","fromCharCode","toUnsigned$2","findBox","path","subresults","results","findBox_1","parseTfhd","view","version","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","baseDataOffset","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","parseSampleFlags_1","parseTrun","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","getInt32","toUnsigned$1","getUint64$3","parseTfdt","getUint64$2","reduce","fragment","lowestTime","acc","baseTime","scale","BigInt","isNaN","Infinity","isFinite","timescales","trafBoxes","parsedTrun","traks","videoTrackIds","forEach","hdlrs","tkhds","handlerType","getUint8","tkhdVersion","sampleDescriptions","codec","codecConfig","codecBox","test","replace","toLowerCase","silence","probe$2","parseType","createDefaultSample","sampleForFrame","frame","keyFrame","frameUtils","groupNalsIntoFrames","nalUnits","currentNal","currentFrame","frames","nalCount","groupFramesIntoGops","currentGop","gops","extendFirstKeyFrame","generateSampleTable","h","concatenateNalData","nalsByteLength","numberOfNals","generateSampleTableForFrame","concatenateNalDataForFrame","highPrefix","lowPrefix","zeroFill","a","makeTable","metaTable","Object","keys","obj","key","arr","part","silence_1","coneOfSilence","sumFrameByteLengths","array","sum","audioFrameUtils","prefixWithSilence","audioAppendStartTs","videoBaseMediaDecodeTime","baseMediaDecodeTimeTs","silentFrame","firstFrame","frameDuration","audioGapDuration","audioFillFrameCount","audioFillDuration","ceil","max","trimAdtsFramesByEarliestDts","adtsFrames","earliestAllowedDts","minSegmentDts","filter","minSegmentPts","concatenateFrameData","ONE_SECOND_IN_TS$3","trackDecodeInfo","clearDtsInfo","maxSegmentDts","maxSegmentPts","calculateTrackBaseMediaDecodeTime","timelineStartInfo","collectDtsInfo","USER_DATA_REGISTERED_ITU_T_T35","RBSP_TRAILING_BITS","captionPacketParser","parseSei","payloadType","payloadSize","parseUserData","sei","parseCaptionPackets","userData","ccData","CaptionStream$1","CaptionStream","options","parse708captions_","parse708captions","captionPackets_","ccStreams_","Cea608Stream","cc708Stream_","Cea708Stream","captionServices","cc","bind","newCaptionPackets","latestDts_","ignoreNextEqualDts_","numSameDts_","flushCCStreams","flushType","flushStream","elem","idx","presortIndex","sort","b","dispatchCea608Packet","dispatchCea708Packet","activeCea608Channel_","ccStream","setsTextOrXDSActive","setsChannel1Active","setsChannel2Active","CHARACTER_TRANSLATION_708","get708CharFromCode","code","newCode","within708TextBlock","Cea708Window","windowNum","clearText","pendingNewLine","winAttr","penAttr","penLoc","penColor","visible","rowLock","columnLock","priority","relativePositioning","anchorVertical","anchorHorizontal","anchorPoint","rowCount","virtualRowCount","columnCount","windowStyle","penStyle","getText","rows","join","rowIdx","newLine","beforeRowOverflow","isEmpty","addText","text","backspace","row","substr","Cea708Service","serviceNum","encoding","currentWindow","windows","createTextDecoder","startPts","setCurrentWindow","TextDecoder","textDecoder_","error","serviceProps","captionServiceEncodings","serviceName","serviceEncodings","current708Packet","services","new708Packet","add708Bytes","push708Packet","ptsVals","byte0","byte1","packet708","packetData","blockSize","seq","sizeCode","pushServiceBlock","service","initService","handleText","multiByteCharacter","extendedCommands","defineWindow","clearWindows","deleteWindows","displayWindows","hideWindows","toggleWindows","setWindowAttributes","setPenAttributes","setPenColor","setPenLocation","isExtended","getPts","byteIndex","flushDisplayed","char","charCodeArray","isMultiByte","extended","currentByte","nextByte","decode","firstByte","secondByte","fillOpacity","fillRed","fillGreen","fillBlue","borderType","borderRed","borderGreen","borderBlue","wordWrap","printDirection","scrollDirection","justify","effectSpeed","effectDirection","displayEffect","displayedText","winId","endPts","pushCaption","textTag","penSize","italics","underline","edgeType","fontStyle","fgOpacity","fgRed","fgGreen","fgBlue","bgOpacity","bgRed","bgGreen","bgBlue","edgeRed","edgeGreen","edgeBlue","column","CHARACTER_TRANSLATION","getCharFromCode","BOTTOM_ROW","ROWS","createDisplayBuffer","field","dataChannel","field_","dataChannel_","name_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","formatting_","isColorPAC","isNormalChar","content","map","trim","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","newBaseRow","format","reverse","popOn","baseRow","rollUp","paintOn","captionStream","streamTypes","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","MAX_TS","RO_THRESH","TYPE_SHARED","handleRollover$1","reference","direction","abs","TimestampRolloverStream$1","TimestampRolloverStream","lastDTS","referenceDTS","type_","discontinuity","_MetadataStream","timestampRolloverStream","handleRollover","typedArrayIndexOf$1","typedArray","element","fromIndex","currentIndex","typedArrayIndexOf","textEncodingDescriptionByte","Iso88591","Utf16","Utf16be","Utf8","percentEncode$1","parseUtf8","decodeURIComponent","parseIso88591$1","unescape","parseSyncSafeInteger$1","frameParsers","mimeTypeEndIndex","descriptionEndIndex","LINK_MIME_TYPE","mimeType","pictureType","description","url","pictureData","values","split","owner","privateData","settings","descriptor","tagSize","bufferSize","dispatchType","chunk","tag","frameStart","frameSize","dataAlignmentIndicator","d","timeStamp","_TransportPacketStream","_TransportParseStream","_ElementaryStream","metadataStream","MP2T_PACKET_LENGTH$1","SYNC_BYTE$1","bytesInBuffer","everything","startIndex","endIndex","parsePsi","parsePat","parsePmt","packetsWaitingForPmt","programMapTable","psi","payloadUnitStartIndicator","pat","section_number","last_section_number","pmtPid","pmt","tableEnd","streamType","pid","processPes_","STREAM_TYPES","segmentHadPmt","timedMetadata","parsePes","pes","ptsDtsFlags","startPrefix","packetLength","forceFlush","packetFlushable","flushStreams_","m2ts$1","PAT_PID","MP2T_PACKET_LENGTH","TransportPacketStream","TransportParseStream","ElementaryStream","MetadataStream","_AacStream","m2ts_1","ADTS_SAMPLING_FREQUENCIES","parseId3TagSize","returnSize","getId3Offset","parseSyncSafeInteger","percentEncode","parseIso88591","utils","isLikelyAacData","parseAdtsSize","lowThree","middle","parseSampleRate","parseAacTimestamp","setTimestamp","bytesLeft","tempLength","_VideoSegmentStream$1","_AudioSegmentStream$1","_Transmuxer$1","_CoalesceStream","aac","audioProperties","videoProperties","H264Stream$1","isLikelyAacData$1","ONE_SECOND_IN_TS$2","retriggerForStream","addPipelineLogRetriggers","transmuxer","pipeline","arrayEquals","generateSegmentTimingInfo","startDts","endDts","prependedContentDuration","firstSequenceNumber","prop","setEarliestDts","earliestDts","setVideoBaseMediaDecodeTime","setAudioAppendStart","segmentDuration","videoClockCyclesOfSilencePrefixed","gopsToAlignWith","minPTS","gopCache_","nalUnit","gopForFusion","firstGop","lastGop","resetStream_","getGopForFusion_","unshift","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","pop","dtsDistance","nearestGopObj","currentGopObj","halfSecond","allowableOverlap","nearestDistance","alignIndex","gopIndex","align","alignEndIndex","matchFound","trimIndex","metadata","total","alignGopsWith","newGopsToAlignWith","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","audioTrack","caption","id3","captions","captionStreams","info","endTime","cueTime","setRemux","val","hasFlushed","transmuxPipeline_","setupAacPipeline","aacStream","audioTimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","audioSegmentStream","getLogTrigger_","hasAudio","hasVideo","setupTsPipeline","packetStream","parseStream","elementaryStream","h264Stream","videoSegmentStream","id3Frame","setBaseMediaDecodeTime","isAac","resetCaptions","_FlvTag","transmuxer$2","Transmuxer","VideoSegmentStream","AudioSegmentStream","AUDIO_PROPERTIES","VIDEO_PROPERTIES","mapToSample","approximateOffset","findSeiNals","avcStream","seiNal","lastMatchedSample","avcView","logs","seiNals","matchingSample","parseSamples","truns","allSamples","parseCaptionNals","segment","videoTrackId","trafs","mdats","captionNals","mdatTrafPairs","matchingTraf","pair","headerInfo","parseEmbeddedCaptions","trackNals","CaptionParser","segmentCache","parsedCaptions","parsingPartial","isInitialized","isPartial","log","isNewInit","parse","parsedData","cachedSegment","pushNals","nals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","captionParser","mp4","generator","probe","extraData","adHoc","bufferStartSize","prepareWrite","flv","minLength","widthBytes","heightBytes","videocodecidBytes","VIDEO_TAG","AUDIO_TAG","METADATA_TAG","writeBytes","writeByte","byte","writeShort","short","setUint16","negIndex","pos","nalUnitSize","startNalUnit","endNalUnit","nalContainer","nalStart","nalLength","writeMetaDataDouble","setFloat64","writeMetaDataBoolean","setUint8","finalize","dtsDelta","frameTime","isAudioFrame","isVideoFrame","isMetaData","isKeyFrame","flvTag","CoalesceStream","videoTags","audioTags","processedTracks","tags","_Transmuxer","_VideoSegmentStream","_AudioSegmentStream","collectTimelineInfo","metaDataTag","extraDataTag","tagList","list","defineProperty","get","oldExtraData","videoKeyFrames","round","adtsFrame","lastMetaPts","writeMetaDataTags","onVideoKeyFrame","h264Frame","finishFrame","newMetadata","metaTag","extraTag","videoTimestampRolloverStream","coalesceStream$1","getFlvHeader","metadataLength","headBytes","head","m2ts","ONE_SECOND_IN_TS$1","segmentStartPts","segmentEndPts","processFrames_","timingInfo","resetTiming_","frameCache","ensureNextFrameIsKeyFrame","processNals_","cacheLastFrame","sequence","videoFrameDts","videoFramePts","resetTimingAndConfig_","createPipeline","object","tsPipeline","elementary","timestampRollover","aacPipeline","audioRollover","timedMetadataRollover","setupPipelineListeners","audioAppendStart","inspectMp4","_textifyMp","partial","getUint64$1","parseSidx_1","references","referenceId","earliestPresentationTime","firstOffset","referenceCount","getUint16","referenceType","referencedSize","subsegmentDuration","startsWithSap","sapType","sapDeltaTime","parseMp4Date","Date","nalParse","dataReferenceIndex","horizresolution","vertresolution","frameCount","depth","numOfPictureParameterSets","nalSize","configurationVersion","avcProfileIndication","avcLevelIndication","lengthSizeMinusOne","numOfSequenceParameterSets","bufferSizeDB","maxBitrate","avgBitrate","edts","elst","edits","entryCount","mediaTime","mediaRate","esId","streamPriority","decoderConfig","objectProfileIndication","decoderConfigDescriptor","audioObjectType","samplingFrequencyIndex","channelConfiguration","majorBrand","minorVersion","compatibleBrands","dataReferences","name","escape","language","creationTime","modificationTime","streamDescriptor","rate","volume","matrix","Uint32Array","nextTrackId","pdin","initialDelay","sidx","balance","ctts","compositionOffsets","sampleOffset","stss","syncSamples","chunkOffsets","sampleToChunks","firstChunk","samplesPerChunk","sampleSize","entries","timeToSamples","sampleDelta","layer","alternateGroup","defaultSampleDescriptionIndex","sampleDependsOn","sampleIsDependedOn","sampleHasRedundancy","samplePaddingValue","sampleIsDifferenceSample","sampleDegradationPriority","graphicsmode","opcolor","Uint16Array","ab","ArrayBuffer","v","z","inspectedMp4","indent","prefix","match","line","JSON","stringify","mp4Inspector","inspect","textify","parseTraf","parseHdlr","parseSidx","tagTypes","hex","toUpperCase","hexStringList","parseAVCTag","avcPacketTypes","compositionTime","parseInt","avcPacketType","CompositionTime","nalUnitTypeRaw","parseVideoTag","frameTypes","codecID","frameType","parseAACTag","packetTypes","aacPacketType","parseAudioTag","formatTable","samplingRateTable","soundFormat","soundRate","soundSize","soundType","parseGenericTag","tagType","dataSize","streamID","inspectFlvTag","inspectFlv","parsedResults","flvInspector","inspectTag","flvTagArray","parsePid","parsePayloadUnitStartIndicator","parseAdaptionField","parsePesType","parsePesTime","parseNalUnitType","probe$1","pusi","payloadOffset","videoPacketContainsKeyFrame","frameBuffer","frameI","frameSyncPoint","foundKeyFrame","ts","SYNC_BYTE","parsePsi_","table","parseAudioPes_","pesType","parsed","endLoop","parseVideoPes_","firstKeyFrame","console","warn","adjustTimestamp_","segmentInfo","baseTimestamp","audioBaseTimestamp","dtsTime","ptsTime","videoBaseTimestamp","inspectAac_","audioCount","audioTimescale","inspectTs_","tsInspector","muxjs","mp2t","tools","factory","require","_AwaitValue","wrapped","_awaitAsyncGenerator","AsyncGenerator","gen","front","back","resume","arg","wrappedAwait","AwaitValue","Promise","resolve","then","settle","done","err","reject","next","_invoke","request","_wrapAsyncGenerator","fn","Symbol","asyncIterator"],"sourceRoot":""}