{"version":3,"file":"static/js/727.8f9df4b5.chunk.js","mappings":"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","sources":["components/MediaElement/components/VideoHandler.tsx"],"sourcesContent":["import muxjs from 'mux.js';\nimport { useEffect, useRef } from \"react\";\n\n\n\nexport default function VideoHandler({ videoInfo, audio, onLoadingComplete }) {\n    if (!videoInfo?.hasAudio && !!audio) {\n        return <SeparateAudioVideoHandler videoUrl={videoInfo.url} audioUrl={audio} onLoadingComplete={onLoadingComplete} />\n    } else {\n        return <video className=\"max-h-screen\"\n            controls={true} autoPlay={false} muted loop preload=\"auto\" playsInline draggable={false}\n            onLoadStart={onLoadingComplete}>\n            <source data-src={videoInfo.url} src={videoInfo.url} type=\"video/mp4\" />\n        </video>\n    }\n}\n\nasync function* loadVideoSegments(url) {\n    try {\n        const reader = await fetch(url).then((response) => {\n            if (response?.body === null) {\n                throw new Error(\"response null, no video\");\n            }\n            return response.body.getReader();\n        });\n        while (true) {\n            const result = await reader.read();\n            if (result.done) {\n                break;\n            }\n            yield result.value;\n        }\n    } catch (error) {\n        console.error(error);\n    }\n    return;\n}\nfunction getMimeType(firstSegment) {\n    const probe = muxjs.mp4.probe.tracks(firstSegment)\n    const codec = probe[0].codec;\n    return `video/mp4; codecs=\"${codec}\"`;\n}\n\nasync function loadVideoUrl(url) {\n    try {\n        const vidBlob = await (await fetch(url)).blob();\n        const vidBuff = await vidBlob.arrayBuffer();\n        const vidInt8 = new Int8Array(vidBuff);\n        const mimeCodec = getMimeType(vidInt8);\n        if (!MediaSource.isTypeSupported(mimeCodec)) {\n            throw new Error(`Unsupported MIME type or codec: ${mimeCodec}`);\n        }\n        return {\n            arrayBuffer: vidBuff,\n            mimeCodec,\n        }\n    } catch (error) {\n        return { error };\n    }\n}\n\nexport function SeparateAudioVideoHandler({ videoUrl, audioUrl, onLoadingComplete }) {\n    const video = useRef<HTMLVideoElement>(null);\n    useEffect(() => {\n        async function loadVideo() {\n            if (!('MediaSource' in window)) {\n                console.error(\"MediaSource unsupported\");\n                return;\n            }\n            if (video.current === null) {\n                console.error('videoRef not set');\n                return;\n            }\n\n            let mediaSource = new MediaSource();\n\n            const generator = loadVideoSegments(videoUrl);\n\n            mediaSource.addEventListener('sourceopen', async () => {\n                const firstSegmentResult = await generator.next();\n                if (firstSegmentResult.done) {\n                    throw new Error(\"no first segment\");\n                }\n                const mimeCodec = getMimeType(firstSegmentResult.value);\n                const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n                const addBuffer = async () => {\n                    const result = await generator.next();\n                    if (result.done) {\n                        mediaSource.endOfStream();\n                        video.current?.play();\n                    } else {\n                        sourceBuffer.appendBuffer(result.value.buffer);\n                    }\n                }\n                sourceBuffer.addEventListener('updateend', addBuffer);\n                sourceBuffer.appendBuffer(firstSegmentResult.value.buffer);\n                video.current?.play();\n            });\n\n            const audioData = await loadVideoUrl(audioUrl);\n            let { arrayBuffer, mimeCodec, error } = audioData;\n            if (error) {\n                console.error(error);\n            } else {\n                mediaSource.addEventListener('sourceopen', () => {\n                    const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec as any);\n                    sourceBuffer.addEventListener('updateend', () => {\n                    });\n                    sourceBuffer.appendBuffer(arrayBuffer as any);\n                });\n            }\n\n            const url = URL.createObjectURL(mediaSource);\n            video.current.src = URL.createObjectURL(mediaSource);\n            URL.revokeObjectURL(url);\n        }\n        loadVideo();\n    }, [audioUrl, videoUrl]);\n    return <video className=\"max-h-screen\"\n        ref={video} controls={true} autoPlay={false} muted loop preload=\"auto\" playsInline draggable={false}\n        onLoadStart={onLoadingComplete}>\n    </video>\n}\n\n\n\n\n\n\n\n\n// const videoData = await loadVideoUrl(videoUrl);\n// if (videoData.error) {\n//     console.error(videoData.error);\n//     return;\n// }\n// if (!videoData.arrayBuffer) {\n//     return;\n// }\n// const NUM_CHUNKS = 20;\n// const segments: any[] = [];\n// for (let i = 0; i < NUM_CHUNKS; ++i) {\n//     const chunkSize = Math.ceil(videoData.arrayBuffer?.byteLength / NUM_CHUNKS);\n//     const startByte = chunkSize * i;\n//     const chunk = videoData.arrayBuffer.slice(startByte, startByte + chunkSize);\n//     segments.push(chunk);\n// }\n// console.log({segments});\n// mediaSource.addEventListener('sourceopen', () => {\n//     console.log(segments[0]);\n//     const mimeCodec = getMimeType(new Uint8Array(segments[0]));\n//     console.log({mimeCodec});\n//     const sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);\n//     const addBuffer = async () => {\n//         if (segments.length === 0) {\n//             console.log('done done')\n//             mediaSource.endOfStream();\n//             video.current?.play();\n//         } else {\n//             console.log('append buffer')\n//             sourceBuffer.appendBuffer(segments.shift());\n//         }\n//     }\n//     sourceBuffer.addEventListener('updateend', addBuffer);\n//     addBuffer();\n// });"],"names":["VideoHandler","videoInfo","audio","onLoadingComplete","hasAudio","className","controls","autoPlay","muted","loop","preload","playsInline","draggable","onLoadStart","url","src","type","SeparateAudioVideoHandler","videoUrl","audioUrl","loadVideoSegments","fetch","then","response","body","Error","getReader","reader","read","result","done","value","console","error","getMimeType","firstSegment","codec","muxjs","loadVideoUrl","blob","vidBlob","arrayBuffer","vidBuff","vidInt8","Int8Array","mimeCodec","MediaSource","isTypeSupported","video","useRef","useEffect","window","current","mediaSource","generator","addEventListener","next","firstSegmentResult","sourceBuffer","addSourceBuffer","addBuffer","endOfStream","play","appendBuffer","buffer","audioData","URL","createObjectURL","revokeObjectURL","loadVideo","ref"],"sourceRoot":""}